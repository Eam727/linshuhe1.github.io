<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Redis数据库]]></title>
      <url>http://yoursite.com/2016/09/08/Redis%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h2 id="Redis简介："><a href="#Redis简介：" class="headerlink" title="Redis简介："></a>Redis简介：</h2><p><strong>Redis</strong>是一种常用的Nosql（Not Only SQL，非关系型）数据库，遵守BSD协议，是一个高性能的<strong>key-value数据库</strong>，一般用来代替Memcached做缓存服务，同时，它也支持数据的持久化。</p>
<p>更详细的介绍可以查看<a href="http://redis.io/" target="_blank" rel="external">redis官网</a>，这里我们主要讲解一下如何安装和使用它。</p>
<a id="more"></a>
<p>Redis相比于其他key-value缓存产品，具有以下特点：</p>
<ul>
<li>支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；</li>
<li>不仅支持简单的key-value类型的数据，还提供对于list、set、zset、hash等数据结构的存储；</li>
<li>支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h2 id="Redis的安装和配置："><a href="#Redis的安装和配置：" class="headerlink" title="Redis的安装和配置："></a>Redis的安装和配置：</h2><h3 id="1-安装："><a href="#1-安装：" class="headerlink" title="1.安装："></a>1.安装：</h3><p>这里我下载的是最新的版本3.2.3：<a href="http://download.redis.io/releases/redis-3.2.3.tar.gz" target="_blank" rel="external">redis-3.2.3.tar.gz</a></p>
<p>下载</p>
<h3 id="2-配置："><a href="#2-配置：" class="headerlink" title="2.配置："></a>2.配置：</h3><h2 id="Redis的使用操作："><a href="#Redis的使用操作：" class="headerlink" title="Redis的使用操作："></a>Redis的使用操作：</h2><h3 id="1-启动："><a href="#1-启动：" class="headerlink" title="1.启动："></a>1.启动：</h3><h3 id="2-访问："><a href="#2-访问：" class="headerlink" title="2.访问："></a>2.访问：</h3><h3 id="3-关闭："><a href="#3-关闭：" class="headerlink" title="3.关闭："></a>3.关闭：</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity ShaderLab基础（三）Unity创建一个Shader]]></title>
      <url>http://yoursite.com/2016/09/07/Unity-ShaderLab%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Unity引擎是一个非常强大的支持跨平台开发的游戏引擎，基于Mono这个开源.Net的框架设计而成，在Unity中定义了<strong>ShaderLab</strong>来组织Shader的内容，针对不同平台进行编译。了解了Shader和Cg的一些基础知识之后，接下来我们要做的就是：学会如何在Unity中使用Cg编写Shader并实现一些简单的Shader效果。</p>
<h2 id="Unity-Shader："><a href="#Unity-Shader：" class="headerlink" title="Unity Shader："></a>Unity Shader：</h2><p>说到底，Shader其实只是一段规定好输入（颜色，贴图等）和输出（渲染器能读懂的点和颜色的对应关系）的程序。那么，<strong>设计一个Shader的过程其实就是根据输入，进行计算变换从而产生输出而已</strong>。</p>
<h3 id="1-分类："><a href="#1-分类：" class="headerlink" title="1.分类："></a>1.分类：</h3><p>在Unity中的Shader分为两类：</p>
<ul>
<li><strong>表面着色器</strong>（Surface Shader）:已经为我们完成了大部分的工作，只需要简单的操作即可得到不错的效果；</li>
<li><strong>片段着色器</strong>（Fragment Shader）:可以自己设计出很多东西，因为可自行设置的内容更多，但也更加难写。使用片段着色器的目的是可以在更加底层进行更复杂（或者针对目标设备更高效）的开发。</li>
</ul>
<h3 id="2-Shader程序基本结构："><a href="#2-Shader程序基本结构：" class="headerlink" title="2.Shader程序基本结构："></a>2.Shader程序基本结构：</h3><p>使用Unity中的框架来编写Shader程序，其实相对于其他游戏引擎要简单一些，在Cocos2d中还得从OpenGL层面开始编写逻辑，但是在Unity只需要往框架中填入需要控制的内容即可，一个Shader程序的基本结构如下图所示：</p>
<p><img src="http://i.imgur.com/a6T9fF8.png" alt=""></p>
<ul>
<li>首先，定义一些属性，用来指定代码将有哪些输入；</li>
<li>其次，会有一个或者多个子着色器，但是在实际运行中哪一个子着色器被使用是由运行的平台所决定的；</li>
<li>子着色器是代码的主体，每个子着色器包含一个或多个Pass；</li>
<li>最后指定一个回滚，用来处理所有Subshader都不能运行的情况（比如设备太老）。</li>
</ul>
<p>执行着色时，平台选择最优先可以使用的子着色器，然后依次执行该子着色器中的Pass，然后输出结果。</p>
<h3 id="3-Unity创建第一个Shader："><a href="#3-Unity创建第一个Shader：" class="headerlink" title="3.Unity创建第一个Shader："></a>3.Unity创建第一个Shader：</h3><p>在Unity的Project面板中，<code>右键</code>-<code>Create</code>-<code>Shader</code>，取名为<code>Diffuse_Texture</code>，使用VS打开可以查看新建的Shader的内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Shader &quot;Custom/Diffuse_Texture&quot; &#123;</div><div class="line">	Properties &#123;</div><div class="line">		_MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</div><div class="line">	&#125;</div><div class="line">	SubShader &#123;</div><div class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</div><div class="line">		LOD 200</div><div class="line">		</div><div class="line">		CGPROGRAM</div><div class="line">		#pragma surface surf Lambert</div><div class="line"></div><div class="line">		sampler2D _MainTex;</div><div class="line"></div><div class="line">		struct Input &#123;</div><div class="line">			float2 uv_MainTex;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		void surf (Input IN, inout SurfaceOutput o) &#123;</div><div class="line">			half4 c = tex2D (_MainTex, IN.uv_MainTex);</div><div class="line">			o.Albedo = c.rgb;</div><div class="line">			o.Alpha = c.a;</div><div class="line">		&#125;</div><div class="line">		ENDCG</div><div class="line">	&#125; </div><div class="line">	FallBack &quot;Diffuse&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们要做的，就是解析这个Shader中每一行的含义和作用，包括了属性、Tags、LOD、光照模型等。</p>
<h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a><strong>解析：</strong></h4><p>第一行指定了此Shader的名字，严格来说是指定了它的路径，在材质面板中选择Shader时，我们可以根据这个路径找到此Shader。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a><strong>属性</strong></h4><p>在<code>Properties{}</code>块中定义的内容就是着色器的属性，【可以理解为一些CPU语言例如java类在开始处定义的一些属性（全局变量或常量）】，<strong>这些属性将作为输入提供给所有的子着色器</strong>。每个属性定义的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_Name(&quot;Display_Name&quot;,type) = defaultValue[&#123;options&#125;]</div></pre></td></tr></table></figure></p>
<ul>
<li><code>_Name</code>：属性的名称，或者理解为变量名，在之后整个    Shader代码中通过此名称获取属性内容；</li>
</ul>
<ul>
<li><code>Display_Name</code>：此字符串是Shader在Unity的材质编辑器中作为Shader可视化信息；</li>
</ul>
<ul>
<li><code>type</code>：此属性的类型，Unity中支持的类型有：<ul>
<li>Color：颜色，由RGBA(红绿蓝和透明度)四个量定义；</li>
<li>2D：一张2的阶数大小（256，512等）的贴图，此贴图将在采样后被转为对应基于模型UV的每个像素的颜色，最终显示出来；</li>
<li>Rect：一个非2阶数大小的贴图；</li>
<li>Cube：即Cub map texture(立方体纹理)，即6张有联系的2D贴图的组合，主要用来做<strong>反射效果</strong>（比如：天空盒和动态反射），也会被转换为对应点的采样；</li>
<li>Range(min,max)：一个介于最大值max和最小值min之间的浮点数，一般用作调整Shader某些特性的参数（例如：透明度从0到1）；</li>
<li>Float：一个浮点数；</li>
<li>Vector：一个四维数；</li>
</ul>
</li>
<li><code>defaultValue</code>：定义的这个属性的默认值或者初始值，但不同属性类型的默认值格式不同，例如：<ul>
<li>Color：咦0~1定义的rgba颜色，可以赋值(1,1,1,1);</li>
<li>2D/Rect/Cube：贴图默认值需要是一个代表tini颜色的字符串，可以是空字符串或者”white”,”black”,”gray”,”bump”中的一个；</li>
<li>Float、Range：任意浮点数即可；</li>
<li>Vector：四维数，格式(x,y,z,w)；</li>
</ul>
</li>
<li><code>{option}</code>：只对2D、Rect和Cube贴图有关，初始值至少要在贴图后面写一对空白的<code>{}</code>，当需要打开特定选项时可以吧其写入到此花括号中，多个选项以空白分隔。可能的选项：ObjectLinear, EyeLinear, SphereMap, CubeReflect, CubeNormal，这些都是OpenGL中TexGen的模式。</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//颜色输入</div><div class="line">_MainColor (&quot;Main Color&quot;, Color) = (0,0.5,1,0.5)</div><div class="line">//2的阶数大小的贴图输入</div><div class="line">_Texture (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="Subshader"><a href="#Subshader" class="headerlink" title="Subshader"></a><strong>Subshader</strong></h4><p>上面已经解析了Shader代码的第一部分，接下来我们要将的就是Shader的代码主体，即SubShader的内容，在<code>SubShader{}</code>中的内容就是一个SubShader。</p>
<h5 id="1-Tags"><a href="#1-Tags" class="headerlink" title="(1) Tags"></a><strong>(1) Tags</strong></h5><p>SubShader中的第一句就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</div></pre></td></tr></table></figure></p>
<p>这是SubShader的标签，因为表面着色器可以被若干个标签（tags）所修饰，而<strong>硬件正是通过判定这些标签（Tags）来决定什么时候调用该着色器</strong>。所以，我们例子中的这一句<code>&quot;RenderType&quot;=&quot;Opaque&quot;</code>的意思：告诉系统应该在渲染非透明物体时调用此SubShader，这与RenderType是Opaque是相对应的。</p>
<p>此外，<strong>Tags其实也暗示了此Shader的输出情况</strong>，例如：输出中都是半透明的物体，那就写在Opaque里；如果想渲染透明或者半透明的像素，那就应该写在Transparent里。</p>
<p>另外比较有用的标签还有：</p>
<ul>
<li><code>&quot;IgnoreProjector&quot;=&quot;True&quot;</code>：不被Projects影响；</li>
<li>``”ForceNoShadowCasting”=”True”：从不产生阴影；</li>
<li><code>&quot;Queue&quot;=&quot;xxx&quot;</code>：<strong>指定渲染顺序队列</strong>。在Unity中，如果需要进行透明和不透明物体混合时，可能会遇到不透明物体无法呈现在透明物体之后的情况，这是由于Shader的渲染顺序不正确导致的。Queue指定物体渲染顺序，预定义的Queue有：<ul>
<li>Background：最早被调用的渲染，用于渲染天空盒或者背景；</li>
<li>Geometry：默认值，用来渲染非透明的物体；</li>
<li>AlphaTest：用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑；</li>
<li>Transparent：以后从后往前的顺序渲染透明物体；</li>
<li>Overlay：用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）；</li>
</ul>
</li>
</ul>
<p>以上这些预定义的值，本质上是一组定义<strong>整数</strong>，Background = 1000， Geometry = 2000, AlphaTest = 2450， Transparent = 3000，最后Overlay = 4000。当然，在实际设置Queue值时，不仅可以使用上述的预定义值，还可以指定自己的Queue值，例如：<code>&quot;Queue&quot;=&quot;Transparent+100&quot;</code>，表示一个在Transparent之后100的Queue上进行调用。</p>
<p><strong>通过调整Queue值，我们可以确保某些物体一定在另一个物体之前或之后被渲染</strong>。</p>
<h5 id="2-LOD"><a href="#2-LOD" class="headerlink" title="(2) LOD"></a><strong>(2) LOD</strong></h5><p>第二行中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOD 200</div></pre></td></tr></table></figure>
<p>LOD，即Level of Detail，这其实是<strong>Unity的内建Diffuse着色器的设定值，决定了我们能够用什么样的Shader</strong>。在Unity的Quality Settings中，我们可以设置允许的最大LOD，当设定的LOD小于SubShader的LOD时，这个SubShader将不可用。</p>
<p>Unity内建Shader定义了一组LOD的数值，我们在实现自己的Shader的时候可以将其作为参考来设定自己的LOD数值，这样在之后调整根据设备图形性能来调整画质时可以进行比较精确的控制。</p>
<ul>
<li>VertexLit及其系列 = 100</li>
<li>Decal, Reflective VertexLit = 150</li>
<li>Diffuse = 200</li>
<li>Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit = 250</li>
<li>Bumped, Specular = 300</li>
<li>Bumped Specular = 400</li>
<li>Parallax = 500</li>
<li>Parallax Specular = 600</li>
</ul>
<h5 id="2-CGPROGRAM…ENDCG"><a href="#2-CGPROGRAM…ENDCG" class="headerlink" title="(2) CGPROGRAM…ENDCG"></a><strong>(2) CGPROGRAM…ENDCG</strong></h5><p>用<code>CGPROGRAM</code>开始和<code>ENDCG</code>结束，表明这部分是Cg代码。这是SubShader的主体部分，我们前面已经提到了属性中定义了此Shader的输入，那么此处代码的作用，便是对输入进行处理，并输出。接下来我们逐句进行解析：</p>
<ul>
<li><code>#pragma surface surf Lambert</code>：这是一个编译指令，声明此Shader是一个表面着色器，并指定了着色器的自动调用的函数名称为surf,而且指定光照模型为Lambert(普通的diffuse)，它的一般语法如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#pragma surface surfaceFunction lightModel [optionalparams]</div></pre></td></tr></table></figure>
<ul>
<li>surface：声明的是一个表面着色器</li>
<li>surfaceFunction：着色器代码的方法名称，着色器其作用时被调用</li>
<li>lightModel：使用的光照模型</li>
</ul>
<hr>
<ul>
<li><code>sampler2D _MainTex;</code>：</li>
</ul>
<hr>
<pre><code>struct Input {
    float2 uv_MainTex;
};

void surf (Input IN, inout SurfaceOutput o) {
    half4 c = tex2D (_MainTex, IN.uv_MainTex);
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}
</code></pre><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ul>
<li>了解Shader的基础知识：<a href="https://onevcat.com/2013/07/shader-tutorial-1/" target="_blank" rel="external">猫都能学会的Unity3D Shader入门指南（一）</a></li>
<li>Unity官方关于Shader的一些资料：<a href="https://docs.unity3d.com/Manual/Shaders.html" target="_blank" rel="external">Materials, Shaders &amp; Textures</a></li>
<li>了解Shader的机制：<a href="http://blog.csdn.net/candycat1992/article/details/39994049" target="_blank" rel="external">【Unity Shaders】初探Surface Shader背后的机制</a></li>
</ul>
<h4 id="推荐书籍："><a href="#推荐书籍：" class="headerlink" title="推荐书籍："></a>推荐书籍：</h4><ul>
<li>《Unity Shader and Effect Cookbook》，中文版：《Unity着色器和屏幕特效开发秘笈》</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity ShaderLab基础（二）Cg语言]]></title>
      <url>http://yoursite.com/2016/09/06/Unity-ShaderLab%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>学习一门新的语言，有几个基本需要掌握的：数据类型（基本数据类型和结构类型），基本语法（表达式和控制语句等），编译和运行方式，这一点在CPU编程语言和GPU编程语言中是相似的，Cg作为一门GPU图形学语言也是如此。<br><a id="more"></a></p>
<h2 id="Cg的数据类型："><a href="#Cg的数据类型：" class="headerlink" title="Cg的数据类型："></a>Cg的数据类型：</h2><h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h3><p>Cg支持7种基本的数据类型，分别是：</p>
<ul>
<li><strong>float</strong>， 32 位浮点数据，一个符号位。浮点数据类型被所有的 profile 支持</li>
<li><strong>half</strong>，16 为浮点数据</li>
<li><strong>int</strong>，32 位整形数据，有些 profile 会将 int 类型作为 float 类型使用</li>
<li><strong>fixed</strong>，12 位定点数，被所有的 fragment profiles 所支持</li>
<li><strong>bool</strong>，布尔数据，通常用于 if 和条件操作符（ ?: ） ，布尔数据类型被所有的profiles 支持</li>
<li><strong>simpler*</strong>， 纹理对象的句柄（ the handle to a texture object ） ，分为 6 类：<br>sampler, sampler1D, sampler2D, sampler3D, samplerCUBE, 和 samplerRECT 。DirectX profiles 不支持 samplerRECT 类型， 除此之外这些类型被所有的 pixelprofiles 和 NV40 vertex program profile 所支持（ CgUsersManual 30 页） 。由此可见，在不远的未来，顶点程序也将广泛支持纹理操作</li>
<li><strong>string</strong>，字符类型，该类型不被当前存在的 profile 所支持，实际上也没有必要在 Cg 程序中用到字符类型，但是你可以通过 Cg runtime API 声明该类型变量，并赋值；因此，该类型变量可以保存 Cg 文件的信息。</li>
</ul>
<blockquote>
<p>前6种类型为常用类型，<strong>string</strong>类型几乎不使用。</p>
</blockquote>
<h3 id="2-其他内置数据类型："><a href="#2-其他内置数据类型：" class="headerlink" title="2.其他内置数据类型："></a>2.其他内置数据类型：</h3><ul>
<li><strong>向量</strong></li>
</ul>
<p>Cg还提供了内置的向量数据类型 (built-in vector data types) ，内置的向量数据类型基于基础数据类型。 例如： float4， 表示 float 类型的 4 元向量； bool4， 表示 bool类型 4 元向量。<br>（注意： <strong>向量最长不能超过 4 元</strong>， 即在 Cg 程序中可以声明 float1 、 float2 、 float3 、float4 类型的数组变量，但是不能声明超过 4 元的向量。）<br>向量初始化方式一般为：</p>
<pre><code>float4 array = float4(1.0, 2.0, 3.0, 4.0);
</code></pre><p>较长的向量还可以通过较短的向量进行构建：</p>
<pre><code>float2 a = float2(1.0, 1.0);  
float4 b = float4(a, 0.0, 0.0);  
</code></pre><ul>
<li><strong>矩阵</strong></li>
</ul>
<p>Cg还提供矩阵数据类型，不过<strong>最大的维数不能超过4X4阶</strong>，例如：</p>
<pre><code>float1x1 matrix1;//等价于float matirx1; x是字符，并不是乘号！  
float2x3 matrix2;//表示 2*3 阶矩阵，包含6个float类型数据  
float4x2 matrix3;//表示 4*2 阶矩阵，包含8个float类型数据  
float4x4 matrix4;//表示 4*4 阶矩阵，这是最大的维数  
</code></pre><p>矩阵初始化：</p>
<pre><code>float2x3 matrix5 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};  
</code></pre><ul>
<li><strong>数组</strong></li>
</ul>
<p><strong>数组数据类型在Cg中的作用：作为函数的形参，用于大量数据的传递</strong>，例如：顶点参数数组、光照参数数据等。</p>
<p>一维数组：</p>
<pre><code>float a[10];//声明了一个数组，包含 10 个 float 类型数据  
float a[4] = {1.0, 2.0, 3.0, 4.0}; //初始化一个数组  
int length = a.length;//获取数组长度  
</code></pre><p>多维数组：</p>
<pre><code>float b[2][3] = {{0.0, 0.0, 0.0},{1.0, 1.0, 1.0}};  
int length1 = b.length; // length1 值为 2  
int length2 = b[0].length; // length2 值为 3  
</code></pre><p>注：在Cg中，向量、矩阵与数组是完全不同的，向量和矩阵是内置的数据类型，而数组则是一种数据结构。</p>
<ul>
<li><strong>类型转换</strong></li>
</ul>
<p>Cg 中的类型转换和 C 语言中的类型转换很类似。 C 语言中类型转换可以是<strong>强制类型转换</strong>，也可以是<strong>隐式转换</strong>，如果是后者，则数据类型从低精度向高精度转换。在 Cg 语言中也是如此：</p>
<pre><code>float a = 1.0;  
half b = 2.0;  
float c = a+b; //等价于 float c = a + (float)b;  
</code></pre><p>当有类型变量和无类型常量数据进行运算时，该常量数据不做类型转换，例如：</p>
<pre><code>float a = 1.0;  
float b = a + 2.0;//2.0为无类型常量数据，编译时作为float 类型
</code></pre><p>Cg 语言中对于常量数据可以加上类型后缀，表示该数据的类型，例如：</p>
<pre><code>float a = 1.0;  
float b = a + 2.0h;//2.0h为half类型常量数据，运算是需要做类型转换
</code></pre><p>常量的类型后缀有3种：</p>
<ul>
<li>f：表示float</li>
<li>h：表示half</li>
<li>x：表示fixed</li>
</ul>
<hr>
<h2 id="Cg的语法："><a href="#Cg的语法：" class="headerlink" title="Cg的语法："></a>Cg的语法：</h2><p>Cg的关系操作符、逻辑操作符、位移操作符都与C语言有相似之处，需要特别注意的是<strong>Swizzle操作符</strong>，例如：</p>
<pre><code>float4(a, b, c, d).xyz     //等价于 float3(a, b, c)
float4(a, b, c, d).xyy     //等价于 float3(a, b, b)
float4(a, b, c, d).wzyx //等价于 float4(d, c, b, a)
float4(a, b, c, d).w     //等价于 float d
</code></pre><hr>
<h2 id="Cg的编译："><a href="#Cg的编译：" class="headerlink" title="Cg的编译："></a>Cg的编译：</h2><h3 id="1-编译方式："><a href="#1-编译方式：" class="headerlink" title="1.编译方式："></a>1.编译方式：</h3><ul>
<li><strong>编译程序</strong>：</li>
</ul>
<p>计算机只能理解和执行由 0 、 1 序列（电压序列）构成的机器语言，所以汇编语言和高级语言程序都需要进行翻译才能被计算机所理解， 担负这一任务的程序称为语言处理程序，通常也被称为编译程序。</p>
<ul>
<li><strong>静态编译</strong>：</li>
</ul>
<p>一旦编译后，除非改变程序代码，否则不需要重新编译，这种方式称为静态编译（ static compilation ） 。静态编译最重要的特征是：<strong>一旦编译为可执行文件，在可执行文件运行期间不再需要源码信息</strong>。</p>
<ul>
<li><strong>动态编译</strong>：</li>
</ul>
<p>编译程序和源码都要参与到程序的运行过程中，就像脚本语言（Lua、JavaScrpit等），源码嵌套到调用的宿主语言程序中，运行时进行编译。</p>
<p><strong>Cg通常采用动态编译的方式（Cg也支持静态编译方式），即在宿主程序运行时，利用Cg运行库（Cg Runtimer Library）动态编译Cg代码。使用动态编译的方式，可以将Cg程序当做一个脚本，随时修改随时运行，节省时间，在OGRE图形引擎中就采用了这种方式。</strong></p>
<h3 id="2-编译器："><a href="#2-编译器：" class="headerlink" title="2.编译器："></a>2.编译器：</h3><p>Cg 编译器首先将 Cg 程序翻译成可被图形 API （ OpenGL 和 Direct3D ）所接受的形式， 然后应用程序使用适当的 OpenGL 和 Direct3D 命令将翻译后的 Cg 程序传递给图形处理器， OpenGL 和 Direct3D 驱动程序最后把它翻译成图形处理器所需要的硬件可执行格式。<strong>NVIDIA 提供的 Cg 编译器为 cgc.exe</strong>。</p>
<ul>
<li>下载<a href="https://developer.nvidia.com/cg-toolkit-download" target="_blank" rel="external">Cg Toolkit</a>；</li>
<li>安装之后，在安装目录的Cg\bin中就有cgc.exe；</li>
<li>打开命令行窗口，输入 <code>cgc -h</code> ，假如不报错则说明安装成功。</li>
</ul>
<h3 id="3-Cg指令："><a href="#3-Cg指令：" class="headerlink" title="3.Cg指令："></a>3.Cg指令：</h3><p><strong>编译指令</strong></p>
<pre><code>cgc [options] file
</code></pre><ul>
<li><code>[options]</code> 表示可选配置项;</li>
<li><code>file</code> 表示 Cg 程序文件名。</li>
</ul>
<p>例如，比较典型的编译方式：</p>
<pre><code>cgc -profile glslv -entry main_v test.cg
</code></pre><ul>
<li><code>-profile</code> 是profile配置项名；</li>
<li><code>glslv</code> 是当前所使用的profile名称；</li>
<li><code>-entry</code> 着色程序的入口函数名称配置项；</li>
<li><code>main_v</code> 是顶点着色程序的入口函数名；</li>
<li><code>test.cg</code> 是当前的着色程序文件名（必须带后缀名）,Cg源码文件需以<strong>.cg</strong>为后缀名；</li>
</ul>
<p>将Cg语言所写的着色程序转换为使用<strong>GLSL</strong>或<strong>HLSL</strong>所编写的程序：</p>
<pre><code>cgc –profile glslv –o direct.glsl –entry main_v test.cg
</code></pre><p>表示编译文件 test.cg 中的顶点着色程序， 入口函数名为 main_v ， 并将顶点着色程序转换为 glsl 程序，然后保存成文件 direct.glsl 。</p>
<p><strong>备注</strong>：GPU编程，是无法跟踪调试着色程序的，一个着色程序，语法错误可以通过编译器发现，但是代码的逻辑错误只能认真查找。</p>
<blockquote>
<p>关于Cg的更详细的介绍可以参考这篇博客，利用OpenGL、C++和Cg进行Cg的测试：<a href="http://blog.csdn.net/xiajun07061225/article/details/6937272" target="_blank" rel="external">【GPU编程】开始Cg之旅，编译自己的第一个Cg程序</a></p>
</blockquote>
<h3 id="4-Cg-Profiles"><a href="#4-Cg-Profiles" class="headerlink" title="4.Cg Profiles:"></a>4.<strong>Cg Profiles:</strong></h3><p>Cg 程序的编译不但依赖于宿主程序所使用的三维编程接口，而且依赖于图形硬件环境，因为图形硬件自身的限制，不一定支持某种 Cg 语句。<br><strong>被特定的图形硬件环境或 AIP 所支持的 Cg 语言子集，被称为Cg Profiles</strong> 。</p>
<p>profile分为：<strong>顶点程序的profile</strong>和<strong>片段程序的profile</strong>，所以编译顶点着色程序时必须选用当前图形硬件支持的顶点profile ，同理，编译片段着色程序时必须选用当前图形硬件支持的片段profile 。</p>
<p>顶点 profile 和片段 profile 又基于 OpenGL 和 DirectX 的不同版本或扩展，划分为各种版本，当前 Cg compiler 所支持的 profiles 有：</p>
<pre><code>OpenGL ARB vertex programs
        Runtime profile: CG_PROFILE_ARBVP1
        Compiler option: _profile arbvp1
OpenGL ARB fragment programs
        Runtime profile: CG_PROFILE_ARBFP1
        Compiler option: _profile arbfp1
......
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity ShaderLab基础（一）概述]]></title>
      <url>http://yoursite.com/2016/09/05/Unity-ShaderLab%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="什么是Shader"><a href="#什么是Shader" class="headerlink" title="什么是Shader?"></a>什么是Shader?</h2><h3 id="1-Shader的概念："><a href="#1-Shader的概念：" class="headerlink" title="1.Shader的概念："></a>1.Shader的概念：</h3><p><strong>Shader</strong>，即着色器，是一种运行在GPU上的程序，用来对三维物体进行着色处理、光和影的计算、纹理颜色的呈现等，从而将一个个作为抽象的几何数据存在的模型、场景和特效，以近似于真实世界的光与影的形式呈现出来。（简单点的理解就是：利用GPU编程使得构件出来的对象近似于真实世界中的对象呈现出来的处理）<strong>通过Shader可以改变物体的形状、大小、位置以及旋转等</strong>。<br><a id="more"></a></p>
<h3 id="2-Shader和Material的关系："><a href="#2-Shader和Material的关系：" class="headerlink" title="2.Shader和Material的关系："></a>2.Shader和Material的关系：</h3><p>Shader负责将输入的Mesh(网格)以指定的方式和输入的贴图或者颜色等组合起来输出，绘图单元可以依据这个输出来将图像绘制在屏幕之上。输入的贴图或颜色，加上对应的Shader和Shader的特定参数设置，这些打包存储在一起就得到了一个Material。</p>
<h3 id="3-以面向对象的思想理解Shader："><a href="#3-以面向对象的思想理解Shader：" class="headerlink" title="3.以面向对象的思想理解Shader："></a>3.以面向对象的思想理解Shader：</h3><p>假设把Shader当做一个类，那么在对某个物体使用此Shader时，就需要实例化此Shader，得到一个对象，而<strong>Material就相当于是一个Shader的对象</strong>。</p>
<h3 id="4-Shader的分类："><a href="#4-Shader的分类：" class="headerlink" title="4.Shader的分类："></a>4.Shader的分类：</h3><p>Shader的基础类型有两种：<strong>顶点Shader</strong>和<strong>片段Shader</strong>，它们的特点：</p>
<ul>
<li><strong>顶点Shader</strong>：具有可以处理、变换，最终会渲染到屏幕上的网格物体的顶点位置的功能，但它不能生成新的顶点；</li>
<li><strong>片段Shader</strong>：会对一个片段（预备像素）进行各种测试，如Z深度测试、Alpha比较测试，能通过各种测试的片段，最终会被写入渲染的输出帧中，从而成为屏幕上的一个可见像素。</li>
</ul>
<h2 id="GPU编程和Shader的编程语言"><a href="#GPU编程和Shader的编程语言" class="headerlink" title="GPU编程和Shader的编程语言"></a>GPU编程和Shader的编程语言</h2><h3 id="1-GPU编程简介："><a href="#1-GPU编程简介：" class="headerlink" title="1.GPU编程简介："></a>1.GPU编程简介：</h3><p><strong>GPU</strong>——Programmable Graphics Processing Unit，即可编程图形处理单元，也成为可编程图形硬件，至于GPU上的编程，实质上就是GPU允许应用程序指定一个序列的指令进行顶点操作控制</p>
<h3 id="2-Shader的编程语言："><a href="#2-Shader的编程语言：" class="headerlink" title="2.Shader的编程语言："></a>2.Shader的编程语言：</h3><p>GPU与CPU是截然不同的，这不仅仅再其硬件结构的差异上，这也就决定了在两者运行环境下的编程过程也是不同的。目前面向GPU的编程，有<strong>3种高级图像语言</strong>，分别是：</p>
<ul>
<li>微软的 <strong>HLST</strong> (High Level Shading Language)，是通过Direct3D图形软件库来写Shader程序的语言；</li>
<li>OpenGL提供的 <strong>GLSL</strong> (OpenGL Shading Language)来写Shader程序；</li>
<li>NVIDIA提供的 <strong>Cg</strong> (C for graphics)语言（以HLST为基础，很相似），兼容Direct3D和OpenGL图形接口；</li>
</ul>
<p>考虑到最大化的跨平台支持，选择使用兼容性最高的 <strong>Cg</strong> 作为编写Shader的语言，但假如只针对Unity 3D引擎，也可以选择 <strong>GLSL</strong>。</p>
<h2 id="如何使用Cg编写Shader："><a href="#如何使用Cg编写Shader：" class="headerlink" title="如何使用Cg编写Shader："></a>如何使用Cg编写Shader：</h2><p>在开始进行实际的编程之前，我们应该先清楚实现步骤，这就需要我们了解一下GPU进行图形绘制的操作步骤。</p>
<h3 id="1-GPU图形绘制："><a href="#1-GPU图形绘制：" class="headerlink" title="1.GPU图形绘制："></a>1.GPU图形绘制：</h3><p>用图形绘制管线描述GPU渲染流程，即“给定视点、三维物体、光源、照明模式和纹理等元素，如何绘制一幅二维图像”。图像绘制其实分为三个阶段：<strong>应用程序阶段</strong>、<strong>几何阶段</strong>和<strong>光栅阶段</strong>：</p>
<ul>
<li><strong>应用程序阶段</strong>：使用高级语言（C、C++等）进行开发，主要和CPU、内存打交道，诸如：碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段。<strong>在该阶段末端，几何体数据（顶点坐标、法向量、纹理等）通过数据总线传送给图形硬件</strong>。</li>
<li><strong>几何阶段</strong>：主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，该阶段基于GPU进行计算。<strong>在该阶段末端，得到经过变换和投影之后的顶点坐标、颜色、以及纹理坐标</strong>。</li>
<li><strong>光栅阶段</strong>：基于几何阶段的输出数据，为像素（Pixel）正确配色，以便绘制完整图像，该阶段进行的都是单个像素的操作，每个像素的信息存储在颜色缓冲器（color buffer或者frame buffer）中。</li>
</ul>
<p>（例如：光照计算属于几何阶段、雾化以及涉及物体透明度的计算属于光栅阶段、深度信息（Z值）的计算属于几何阶段并传递给光栅阶段。）</p>
<h3 id="2-Unity中使用Cg写Shader："><a href="#2-Unity中使用Cg写Shader：" class="headerlink" title="2.Unity中使用Cg写Shader："></a>2.Unity中使用Cg写Shader：</h3><p>基本步骤如下：</p>
<ul>
<li>定义一些属性，用于指定此Shader将有哪些输入；</li>
<li>定义一个或者多个子着色器，每个着色器中包含一个或者多个Pass；</li>
<li>指定一个回滚，用于处理所有SubShader都不能运行的情况。 </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Next主题的fancybox展示图片]]></title>
      <url>http://yoursite.com/2016/09/03/Next%E4%B8%BB%E9%A2%98%E7%9A%84fancybox%E5%B1%95%E7%A4%BA%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在创建的文章开头假如图片，并且支持点击放大功能，这是Next主题包含的一个功能。</p>
<a id="more"></a>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>使用方法就是在开头匹配内容中假如<code>photos</code>字段，可以加图片链接列表：</p>
<pre><code>---
title: Next主题的fancybox展示图片
date: 2016-09-03 17:15:22
tags:
photos:
- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg
- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg
---
</code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>此案例的运行结果，如本文的开头所示。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BATCH批处理简记]]></title>
      <url>http://yoursite.com/2016/09/03/BATCH%E6%89%B9%E5%A4%84%E7%90%86%E7%AE%80%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文转载自原文<a href="http://www.jb51.net/article/7131_3.htm" target="_blank" rel="external">批处理经典入门教程！(从不懂到高手)</a>，只是原文作者太罗嗦了，我做了稍微的简化。</p>
</blockquote>
<ol>
<li>批处理定义</li>
<li>基本语法和常用命令</li>
<li>例子</li>
</ol>
<a id="more"></a>
<hr>
<h3 id="一-批处理定义"><a href="#一-批处理定义" class="headerlink" title="一.批处理定义"></a>一.批处理定义</h3><p>批处理的本质，其实是一堆DOS命令，他们按一定顺序排列而形成的集合就是批处理。批处理，也称为批处理脚本，英文译为BATCH，批处理文件后缀BAT就取的前三个字母。<br><strong>注意：</strong>批处理的每一行可视为一个命令，每个命令里可以含多条子命令，从第一行开始执行，直到最后一行结束，它运行的平台是DOS。</p>
<hr>
<h3 id="二-基本语法和常用命令"><a href="#二-基本语法和常用命令" class="headerlink" title="二.基本语法和常用命令"></a>二.基本语法和常用命令</h3><p>1.注释方式：<br>使用“::”双冒号的方式进行注释，注释符号之后的同一行中的内容在脚本执行时不显示，也不起任何作用，只是增加了脚本的可读性，在批处理脚本中和rem命令等效。例如：</p>
<pre><code>@echo off 
::close echo 
cls 
::clean screen 
</code></pre><p>2.@符号：<br>让脚本执行窗口不显示此符号之后指令内容的命令本身，而只显示执行结果，就像上例中的“@echo off”，@可以使得doc中不显示echo off，而直接显示其执行的结果。</p>
<p>3.echo:<br>可以看做是回写或者是反馈，但实际上它是一个开关，而控制它的指令就是echo on和echo off了，而直接执行echo指令则会显示当前echo所处的状态（on或off）。执行echo off将关闭回显，它后面的所有命令都不显示命令本身，只显示执行后的结果，除非执行echo on命令。<br>echo命令的另一种用法一：可以用它来显示信息，如：```echo hello world<code>,会在doc中打印“hello world”;
echo命令的另一种用法二：可以直接编辑文本文件,如：在doc窗口直接输入</code>echo nbtstat -A 192.168.0.1 &gt; a.bat ````，执行结果会在当前目录下创建一个a.bat文件。</p>
<p>4.pause:<br>直接可以看出它是“暂停”的意思，即让当前程序进程暂停一下，并显示一行信息：请按任意键继续. . .。</p>
<p>5.”goto”和”:”:<br>这两个指令是以一个组合形式出现的，goto是一个跳转指令，一般脚本执行到goto指令时，会跳转到：:标签定义的部分区执行。例如：</p>
<pre><code>goto usage
...
:usage
...
</code></pre><p>不难看出，goto命令就是根据这个冒号和标签名称来寻找它该跳转的地方，它们是一一对应的关系，goto命令也经常和if命令结合使用。<br>goto命令的另一种用法一：提前结束程序。在程序中间使用goto命令跳转到某一标签，而这一标签的内容却定义为退出。<br>如： </p>
<pre><code>…… 
goto end 
…… 
:end 
</code></pre><p>这里:end在脚本最后一行！</p>
<p>6.%:<br>单个%不算是命令，而相当于参数，例如：</p>
<pre><code>net use \\%1\ipc$ %3 /u:&quot;%2&quot; 
copy 11.BAT \\%1\admin$\system32 /y 
copy 13.BAT \\%1\admin$\system32 /y 
copy ipc2.BAT \\%1\admin$\system32 /y 
copy NWZI.EXE \\%1\admin$\system32 /y 
attrib \\%1\admin$\system32⏺.bat -r -h -s 
</code></pre><p>以上代码是Bat.Worm.Muma病毒中的一部分，%1代表的IP，2%代表的username，3%代表password。执行形式为：脚本文件名 参数一 参数二 ……。假设这个脚本被保存为a.bat，则执行形式如下：a IP username password。这里IP、username、password是三个参数，缺一不可（因为程序不能正确运行，并不是因为少了参数语法就不对）这样在脚本执行过程中，脚本就自动用用你的三个参数依次（记住，是依次！也是一一对应的关系。）代换1%、2%和3%，这样就达到了灵活运用的目的。 </p>
<hr>
<h3 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h3><p>将所需的命令都写在一个文件中，并且修改文件的后缀名为.bat，双击执行即会弹出doc窗口执行文件中的脚本命令。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python Web 1 —— python和MongoDB安装]]></title>
      <url>http://yoursite.com/2016/09/03/Python-Web-1-%E2%80%94%E2%80%94-python%E5%92%8CMongoDB%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<blockquote>
<p>做了很长时间的客户端，主要从事过Android软件开发和Unity 3D的游戏开发，之前还看过一段时间的Java Web，但是由于没有实际的应用，所以就搁置了很久。最近突然有对服务器后台编程产生了浓厚的兴趣，想试着用Python + Mongo DB进行游戏后台的开发。</p>
</blockquote>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python是一门具有强类型(即变量类型是强制要求的)、动态性、隐式类型(不需要做变量声明)、大小写敏感(var和VAR代表了不同的变量)以及面向对象等特点的编程语言。<strong>Python是一种解释型的语言，相比于C语言，Python的运行速度慢，且不能进行加密。</strong><br><a id="more"></a></p>
<h4 id="一、Python的安装："><a href="#一、Python的安装：" class="headerlink" title="一、Python的安装："></a>一、Python的安装：</h4><p>由于我使用的开发环境是Mac OS，所以自带了Python，但由于10.10自带的版本是2.7的，所以我们需要重新安装3.x的版本，安装方法：</p>
<p> 1.没有安装Homebrew的先安装此Mac插件，安装方法就是打开终端，输入以下指令：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></div></pre></td></tr></table></figure></p>
<p>2.使用以下指令安装Python3：</p>
<ul>
<li>先查看当前计算机的python版本：<strong>python</strong></li>
</ul>
<p><img src="http://img.blog.csdn.net/20160611163033678" alt="这里写图片描述"></p>
<ul>
<li>安装新版本：<strong>brew install python3</strong></li>
</ul>
<p><img src="http://img.blog.csdn.net/20160611163202196" alt="这里写图片描述"><br>这里我的安装出错了，出错不可怕，解决就好了，不难看出这个错误出现的原因是对/usr/local/share/man/man3目录的权限不够，那么解决方法：<strong>sudo chown -R linshuhe /usr/local/share/man/man3</strong><br><img src="http://img.blog.csdn.net/20160611172025531" alt="这里写图片描述"><br>但是，这里又出现了多版本的python共存和版本切换的问题了：<br><img src="http://img.blog.csdn.net/20160611172635305" alt="这里写图片描述"><br>假如不想修改或者删除系统自带的python，我们可以直接通过以下方式指定使用哪个版本执行代码：<br><img src="http://img.blog.csdn.net/20160611173455348" alt="这里写图片描述"></p>
<p>除了上述方法之外，还可以直接到官网下载最新版本，直接安装即可。</p>
<hr>
<h3 id="Mongo-DB"><a href="#Mongo-DB" class="headerlink" title="Mongo DB"></a>Mongo DB</h3><h4 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h4><p>使用Homebrew进行安装是比较简单的安装方式：<br>1.更新Homebrew:<strong>brew update</strong><br><img src="http://img.blog.csdn.net/20160610091546638" alt="这里写图片描述"><br>2.开始安装mongodb:<strong>brew install mongodb</strong><br><img src="http://img.blog.csdn.net/20160610091527985" alt="这里写图片描述"><br>3.根据安装完成最后的提示，启动mongodb:<br><strong>mongod —config /usr/local/etc/mongod.conf</strong></p>
<p>4.下载一个可视化管理工具Robomongo：下载的地址为：<br><a href="https://robomongo.org/download" target="_blank" rel="external">https://robomongo.org/download</a><br><img src="http://img.blog.csdn.net/20160610091457232" alt="这里写图片描述"></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Github Pages + Hexo创建个人博客]]></title>
      <url>http://yoursite.com/2016/09/02/Github-Pages+Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>之前使用过jekyll+github做过一版自己的博客网站，有兴趣的可以看一下我之前的文章：<a href="http://blog.csdn.net/linshuhe1/article/details/51143026" title="Github+Jekyll —— 创建个人免费博客（一）从零开始" target="_blank" rel="external">http://blog.csdn.net/linshuhe1/article/details/51143026</a>，其实也很简单，但是存在一些问题：目录、Rss、sitemap无法自动生成。</p>
</blockquote>
<hr>
<blockquote>
<p>最近看到了别人使用hexo+github实现的博客，有更多的灵活性和简约的风格，所以也试着改一下自己原本的设计。</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是hexo："><a href="#什么是hexo：" class="headerlink" title="什么是hexo："></a>什么是hexo：</h2><p><code>hexo</code>是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管到github或者Heroku上，类似于jekyll、Octopress、Wordpress等，使用markdown来写文章。hexo的作者是<a href="https://github.com/tommy351/hexo" title="@tommy351" target="_blank" rel="external">https://github.com/tommy351/hexo</a>。具有以下几点优点：</p>
<ul>
<li>易用性，部署很简单，常用指令有：<code>hexo new</code>、<code>hexo generate</code>、<code>hexo server</code>、<code>hexo deploy</code>；</li>
<li>轻量级，文件少而小，自定义方便</li>
</ul>
<h2 id="相关知识："><a href="#相关知识：" class="headerlink" title="相关知识："></a>相关知识：</h2><p>hexo配置过程中使用到了<code>Github</code>，<code>Git</code>，<code>Markdown</code>，<code>Node.js</code>等相关操作，所以需要很多插件、widget需要自己安装配置。</p>
<h2 id="安装准备："><a href="#安装准备：" class="headerlink" title="安装准备："></a>安装准备：</h2><ol>
<li>Node.js:<a href="https://nodejs.org/en/" title="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a> ；</li>
<li>Github桌面版（Windows）：<a href="https://desktop.github.com/" title="https://desktop.github.com/" target="_blank" rel="external">https://desktop.github.com/</a>；</li>
</ol>
<h2 id="安装Github桌面版和配置"><a href="#安装Github桌面版和配置" class="headerlink" title="安装Github桌面版和配置"></a>安装Github桌面版和配置</h2><ol>
<li>双击下载好的<code>GitHubSetup.exe</code>文件，按照默认设置完成安装；</li>
<li>登录自己的github账号；</li>
</ol>
<p><img src="http://i.imgur.com/97nOEVO.png" alt=""></p>
<ol>
<li>在github网页上创建一个以<code>username.github.io</code>命名的repositories,此时username为自己github的账号名称；</li>
</ol>
<p><img src="http://i.imgur.com/A9cQrk6.png" alt=""></p>
<ol>
<li>打开Git Shell，使用配置SSH Key使本地git项目与远程Github建立联系：<code>ssh -T git@github.com</code>；</li>
</ol>
<p><img src="http://i.imgur.com/t33BM1G.png" alt=""></p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>直接双击下载好的<code>node-v4.5.0-x64.msi</code>选择指定的安装路径，按照默认设置完成安装操作，安装完成后不需要对Node.js进行任何配置。为了检验是否完成安装，可以打开命令行，输入指令：<code>npm --version</code>进行版本号查询。<br><img src="http://i.imgur.com/H21hK8M.png" alt=""></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo:"></a>安装Hexo:</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装:"></a>1.安装:</h3><pre><code>mkdir hexo #创建一个项目文件
cd hexo    #进入项目文件目录
npm install -g hexo-cli
npm install hexo --save
</code></pre><p>npm是Node.js中的一个工具，所以在安装Hexo之前应该先安装Node.js</p>
<h3 id="2-部署Hexo："><a href="#2-部署Hexo：" class="headerlink" title="2.部署Hexo："></a>2.部署Hexo：</h3><p>在Git shell中输入：</p>
<pre><code>hexo init
</code></pre><p>记得输入之前需要确保当前命令行所处目录为所要创建工程的根目录下，因为此操作的结果就是将hexo的一些必要文件复制到当前目录下面。<br><img src="http://i.imgur.com/8bOaggs.png" alt=""><br>看到上图结果之后，可以通过以下指令运行博客：</p>
<pre><code>hexo server
</code></pre><p><img src="http://i.imgur.com/OyexMqN.png" alt=""><br>运行正常的话可以通过访问：<a href="http://localhost:4000/" title="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>查看运行结果：</p>
<p><img src="http://i.imgur.com/Xy731Ig.png" alt=""></p>
<p>假如出现了hexo服务启动成功，但是浏览器访问localhost:4000一直不响应，那就有可能是因为你的设备上装了其他软件占用了4000端口，一般有两种办法可以解决：</p>
<ul>
<li>在服务管理中将占用该端口的服务停止掉，通常安装了福昕阅读器的就会占用4000，把其对应的后台服务关掉即可；</li>
<li><p>切换hexo启动的默认端口，使用以下指令：</p>
<p>  hexo s -p 5000</p>
</li>
</ul>
<p>此时启动端口就变成了5000，访问地址变成了localhost:5000。</p>
<h3 id="3-安装Hexo插件："><a href="#3-安装Hexo插件：" class="headerlink" title="3.安装Hexo插件："></a>3.安装Hexo插件：</h3><p>主要目的是为了让其自动生成sitemap，Rss，部署到git等，这些是额外的插件，假如不需要使用到这些功能可以不添加：</p>
<pre><code>npm install hexo-generator-index --save
npm install hexo-generator-archive --save
npm install hexo-generator-category --save
npm install hexo-generator-tag --save
npm install hexo-server --save
npm install hexo-deployer-git --save
npm install hexo-deployer-heroku --save
npm install hexo-deployer-rsync --save
npm install hexo-deployer-openshift --save
npm install hexo-renderer-marked@0.2 --save
npm install hexo-renderer-stylus@0.2 --save
npm install hexo-generator-feed@1 --save
npm install hexo-generator-sitemap@1 --save
</code></pre><h2 id="将当前工程上传到github"><a href="#将当前工程上传到github" class="headerlink" title="将当前工程上传到github"></a>将当前工程上传到github</h2><h3 id="1-修改配置文件："><a href="#1-修改配置文件：" class="headerlink" title="1.修改配置文件："></a>1.修改配置文件：</h3><p>在当前项目的根目录下找到<code>_config.yml</code>配置文件，用编辑器打开，并找到Deployment标签处deploy节点，填写以下配置信息，<code>type</code>是指定拖过平台类型，<code>repository</code>指定了github上创建的repository仓库地址，<code>branch</code>指定了版本类型。（注：冒号后面需要加一个空格，否则会出现报错）</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: github
  repository: https://github.com/linshuhe1/linshuhe1.github.io.git
  branch: master
</code></pre><h3 id="2-将项目deploy到github仓库："><a href="#2-将项目deploy到github仓库：" class="headerlink" title="2.将项目deploy到github仓库："></a>2.将项目deploy到github仓库：</h3><p>打开Git shell进入当前项目的根目录，依次执行指令：</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre><p>一般执行最后一步的时候会出现错误如下：<br><img src="http://i.imgur.com/68SebBI.png" alt=""><br>解决错误的方法是：将deploy的type改成git，然后在Git shell中执行：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>执行结束后再次执行上述三个指令，正确结果应该如下：<br><img src="http://i.imgur.com/G0wPCXU.png" alt=""><br>如此我们便完成了将本地的hexo工程deploy到github上的操作，访问地址：<a href="https://username.github.io/可以看到页面效果,这里以我的github为例：[https://linshuhe1.github.io/](https://linshuhe1.github.io/" target="_blank" rel="external">https://username.github.io/可以看到页面效果,这里以我的github为例：[https://linshuhe1.github.io/](https://linshuhe1.github.io/</a> “<a href="https://linshuhe1.github.io/&quot;)。" target="_blank" rel="external">https://linshuhe1.github.io/&quot;)。</a></p>
<h2 id="Hexo常用指令使用："><a href="#Hexo常用指令使用：" class="headerlink" title="Hexo常用指令使用："></a>Hexo常用指令使用：</h2><h3 id="创建新博文："><a href="#创建新博文：" class="headerlink" title="创建新博文："></a>创建新博文：</h3><p>在Git shell中使用以下指令：</p>
<pre><code>hexo new &quot;postName&quot;
</code></pre><p>生成指定名称postName的文章到hexo\source_posts\postName.md，当然也可以直接到hexo\source_posts目录下，手动创建一个文件，命名时注意后缀名必须是“.md”即可。<br><img src="http://i.imgur.com/qjVQtnG.png" alt=""><br>可以打开查看新建出来的.md文件的内容：</p>
<pre><code>---
title: github pages + Hexo
date: 2016-09-02 17:17:52
tags:
---
</code></pre><p><code>title</code>是博文的标题，<code>date</code>是博文的日期，<code>tags</code>是分类标签。</p>
<p>更详细的内容可以参考：<a href="https://hexo.io/docs/writing.html" title="Writing" target="_blank" rel="external">https://hexo.io/docs/writing.html</a></p>
<h3 id="新建页面："><a href="#新建页面：" class="headerlink" title="新建页面："></a>新建页面：</h3><p>上面的步骤其实就是新建一篇博文的步骤，他们最后都是通过一个文章页面来显示的单个子页，但是我们的博客页面出来需要有博文显示页面之后，还需要有其他的页面，每个页面相当于一个分类对应顶栏菜单中的一个页签，如下图首页、下载等都是一个页面，所以可以理解为页面就相当于子页的父节点：<br><img src="http://i.imgur.com/V33kn9P.png" alt=""><br>创建一个页签的操作是在Git shell中输入指令：</p>
<pre><code>hexo new page &quot;页签名称&quot;
</code></pre><p>上述步骤操作结果是在hexo\source目录下多出一个文件夹，而且里面还有一个index.md，这就表明了我们新建了一个页签。</p>
<h3 id="运行博客："><a href="#运行博客：" class="headerlink" title="运行博客："></a>运行博客：</h3><p>使用Git shell在当前项目的根目录下执行以下指令：</p>
<pre><code>hexo server
</code></pre><p>更详细的内容可以参考：<a href="http://hexo.io/docs/server.html" title="Server" target="_blank" rel="external">http://hexo.io/docs/server.html</a></p>
<h3 id="生成静态站点文件："><a href="#生成静态站点文件：" class="headerlink" title="生成静态站点文件："></a>生成静态站点文件：</h3><pre><code>hexo generate
</code></pre><p>更详细的内容可以参考：<a href="http://hexo.io/docs/generating.html" title="Generating" target="_blank" rel="external">http://hexo.io/docs/generating.html</a></p>
<h2 id="发表一篇新博文"><a href="#发表一篇新博文" class="headerlink" title="发表一篇新博文"></a>发表一篇新博文</h2><h3 id="1-新建博文："><a href="#1-新建博文：" class="headerlink" title="1.新建博文："></a>1.新建博文：</h3><p>使用新建博文的指令：</p>
<pre><code>hexo new &quot;github pages + Hexo&quot;
</code></pre><h3 id="2-编辑博文内容："><a href="#2-编辑博文内容：" class="headerlink" title="2.编辑博文内容："></a>2.编辑博文内容：</h3><p>打开步骤1创建得到的.md文件，使用的语法是markdown，假设内容如下：</p>
<pre><code>---
title: github pages + Hexo
date: 2016-09-02 17:17:52
tags: 测试
---

&gt;测试博客
</code></pre><h3 id="3-发表博文："><a href="#3-发表博文：" class="headerlink" title="3.发表博文："></a>3.发表博文：</h3><p>之前的内容中已经提到了将本地内容更新到github需要三个步骤：</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre><p>其实还有快捷的指令输入方式，如下：</p>
<pre><code>hexo g == hexo generate
hexo d == hexo deploy
hexo s == hexo server
hexo n == hexo new
# 还能组合使用，如：
hexo d -g
</code></pre><p>完成上述三个步骤，一篇新的博文就发表到github上面了。</p>
<h2 id="使用Next主题美化界面："><a href="#使用Next主题美化界面：" class="headerlink" title="使用Next主题美化界面："></a>使用Next主题美化界面：</h2><p>安装好hexo之后，主题使用的是hexo默认自带的<code>landscape</code>主题，Next主题是iissnan设计的，使用指南其实可以直接参考Next官方网：<a href="http://theme-next.iissnan.com/" title="Next" target="_blank" rel="external">http://theme-next.iissnan.com/</a></p>
<h3 id="1-Next主题下载："><a href="#1-Next主题下载：" class="headerlink" title="1.Next主题下载："></a>1.Next主题下载：</h3><p>打开Git shell，在当前项目根目下使用git从github上checkout主题的代码，输入指令：</p>
<pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p><img src="http://i.imgur.com/bGoWtvn.png" alt=""><br>下载完成后，在hexo\theme目录下回多出一个next文件夹，里面就是next主题所需的文件,当然我们也可以看到在theme文件目录还有一个landscape文件夹，这也就是hexo默认的主题。<br><img src="http://i.imgur.com/rqq71ts.png" alt=""></p>
<h3 id="2-配置主题："><a href="#2-配置主题：" class="headerlink" title="2.配置主题："></a>2.配置主题：</h3><p>之前我们配置hexo的时候，有用到<code>_config.yml</code>文件，称其为<strong>站点配置文件</strong>，而我们打开next主题文件夹，发现里面也有一个<code>_config.yml</code>文件，我们称这个为<strong>主题配置文件</strong>。在hexo中启用next主题的方式：就是打开站点配置文件，找到<code>theme</code>字段，将其值改为“next”，如下：</p>
<pre><code># Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: next
</code></pre><p>配置完成后，在Git shell中使用<code>hexo server</code>指令启动本地博客，在浏览器中访问<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>可以看到如下结果：<br><img src="http://i.imgur.com/ZKzamkL.png" alt=""></p>
<h3 id="3-next的样式选择："><a href="#3-next的样式选择：" class="headerlink" title="3.next的样式选择："></a>3.next的样式选择：</h3><p>next的样式其实有三种：Muse、Mist和Pisces，步骤2中看到的其实是next默认的模式Muse，根据官方说明三个样式的特点如下：</p>
<ul>
<li><strong>Muse：</strong> 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li><strong>Mist：</strong> Muse 的紧凑版本，整洁有序的单栏外观</li>
<li><strong>Pisces：</strong> 双栏 Scheme，小家碧玉似的清新</li>
</ul>
<p>切换的控制其实很简单，使用next主题配置文件中的<code>scheme</code>字段来控制，假设我们选择Mist样式（个人认为最好看的样式），操作步骤是：打开next文件夹中的<code>_config.yml</code>文件，找到<code>scheme</code>字段，将其设置为“Mist”，如下所示：</p>
<pre><code># ------------------------------------------------------
# Scheme Settings
# ------------------------------------------------------

# Schemes
#scheme: Muse
scheme: Mist
#scheme: Pisces
</code></pre><p>重新启动博客，刷新浏览器可以看到：<br><img src="http://i.imgur.com/6YFzhyz.png" alt=""></p>
<h2 id="额外的优化："><a href="#额外的优化：" class="headerlink" title="额外的优化："></a>额外的优化：</h2><h3 id="1-设置favicon："><a href="#1-设置favicon：" class="headerlink" title="1.设置favicon："></a>1.设置favicon：</h3><p>favicon的全称Favorites Icon，即地址栏左侧的图标：</p>
<p><img src="http://i.imgur.com/ZNLKFAE.png" alt=""></p>
<p>有个在线工具可以上传自己的图片去生成指定规格的favicon.ico文件：<a href="http://www.atool.org/ico.php" target="_blank" rel="external">http://www.atool.org/ico.php</a>。打开主题配置文件<code>_config.yml</code>可以看到favicon的配置信息：</p>
<pre><code># Put your favicon.ico into `hexo-site/source/` directory.
favicon: /favicon.ico
</code></pre><p>根据说明，我们将图标取名为<code>favicon.ico</code>然后放到当前工程的hexo\source目录下，重启博客即可生效。</p>
<h3 id="2-菜单栏控制："><a href="#2-菜单栏控制：" class="headerlink" title="2.菜单栏控制："></a>2.菜单栏控制：</h3><p>我们看到页面顶部的菜单栏，其实是由主题配置文件中的<code>menu</code>字段控制的，例如原本的样子是这样：<br><img src="http://i.imgur.com/iyg45Yj.png" alt=""></p>
<p>我们修改一下主题配置文件，如下把about页面前面的注释去掉，即让此页签处于显示状态：</p>
<pre><code># ------------------------------------------------------
# Menu Settings
# ------------------------------------------------------

# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)
menu:
  home: /
  #categories: /categories
  about: /about
  archives: /archives
  tags: /tags
  #commonweal: /404.html
</code></pre><p>重启博客可以看到效果如下：<br><img src="http://i.imgur.com/O6Z9NvT.png" alt=""></p>
<p>然而，点击打开About却出现了“Cannot GET /about/”的页面错误，这是因为我们还没有about这个页面，需要使用<code>hexo new page &quot;页面名称&quot;</code>进行创建：</p>
<pre><code>hexo new page about
</code></pre><p>执行结果就是在hexo\source目录下面多出了一个about文件夹，里面有index.md，这就是点击About会展示的内容页面。同理，也可以创建tags页面。</p>
<h3 id="3-语言设置："><a href="#3-语言设置：" class="headerlink" title="3.语言设置："></a>3.语言设置：</h3><p>在站点配置文件中假如如下内容，明确指定使用的语言，例如中文：</p>
<pre><code>language: zh-Hans
</code></pre><p>设置完毕后，发现菜单栏也发生了变化：<br><img src="http://i.imgur.com/Ekxi8Tv.png" alt=""></p>
<h3 id="4-侧栏设置："><a href="#4-侧栏设置：" class="headerlink" title="4.侧栏设置："></a>4.侧栏设置：</h3><p>在主题配置文件的<code>sidebar</code>字段，此处我直接设置为侧栏一直显示，而且显示在右边：</p>
<pre><code>sidebar:
  # Sidebar Position, available value: left | right
  position: left
  #position: right

  # Sidebar Display, available value:
  #  - post    expand on posts automatically. Default.
  #  - always  expand for all pages automatically
  #  - hide    expand only when click on the sidebar toggle icon.
  #  - remove  Totally remove sidebar including sidebar toggler.
  #display: post
  display: always
  #display: hide
  #display: remove
</code></pre><h3 id="5-设置头像和作者名称："><a href="#5-设置头像和作者名称：" class="headerlink" title="5.设置头像和作者名称："></a>5.设置头像和作者名称：</h3><p>在站点配置文件中，新加一个字段<code>avatar</code>，值就是头像的连接地址，这里我使用站内地址，将avatar.png放到本地目录hexo\source\images中；作者名称直接设置站点配置文件中<code>author</code>字段的值：</p>
<pre><code># Site
title: Linsh-何乐不为~
subtitle:
description:
author: Linshuhe
avatar: /images/avatar.png
language: zh-Hans
timezone:
</code></pre><h2 id="第三方服务："><a href="#第三方服务：" class="headerlink" title="第三方服务："></a>第三方服务：</h2><h3 id="1-多说评论："><a href="#1-多说评论：" class="headerlink" title="1.多说评论："></a>1.多说评论：</h3><p>进入多说官网，登录后点击“我要登录”，填写相关信息，注意要记住<code>多说域名</code>这个字段填写的内容，<code>http://(duoshuo_shortname).duoshuo.com</code>，这个duoshuo_shortname将用于我们站点配置文件中的配置。步骤：在站点配置文件中新建一个<code>duoshuo_shortname</code>的字段，填写注册使用的duoshuo_shortname，例如：</p>
<pre><code>duoshuo_shortname: linshuhe1
</code></pre><h3 id="2-百度统计："><a href="#2-百度统计：" class="headerlink" title="2.百度统计："></a>2.百度统计：</h3><p>用于统计阅读的次数，步骤如下：</p>
<ul>
<li>登录百度统计官网：<a href="http://tongji.baidu.com/web/welcome/login" title="百度统计" target="_blank" rel="external">http://tongji.baidu.com/web/welcome/login</a>定位到站点的代码获取页面；</li>
<li>复制<code>hm.js?</code>后面的那串id；</li>
<li>在站点配置文件中，新增一个字段<code>baidu_analytics</code>，设置其值为上面复制的百度统计的id</li>
<li>阅读次数统计，使用LeanCloud来实现，详情查看：<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="external">https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud</a></li>
</ul>
<h3 id="3-Swiftype搜索"><a href="#3-Swiftype搜索" class="headerlink" title="3.Swiftype搜索"></a>3.Swiftype搜索</h3><p>使用 Swiftype 之前需要前往 Swiftype 配置一个搜索引擎。 而后编辑 站点配置文件， 新增 swiftype_key 字段，值为你的 swiftype 搜索引擎的 key。 详细的配置请参考： <a href="http://theme-next.iissnan.com/third-party-services.html#swfitype" title="Swiftype" target="_blank" rel="external">http://theme-next.iissnan.com/third-party-services.html#swfitype</a></p>
<p><strong>Local Search:</strong>添加百度/谷歌/本地 自定义站点内容搜索：</p>
<ul>
<li>安装hexo-generator-search:</li>
<li>  npm install hexo-generator-search –save</li>
<li>在站点配置文件中加入：</li>
<li>  search:<pre><code>path: search.xml
field: post
</code></pre></li>
</ul>
<blockquote>
<p>最终结果可以查看我的博客：<a href="https://linshuhe1.github.io/" target="_blank" rel="external">https://linshuhe1.github.io/</a></p>
</blockquote>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>可能有人跟我一样遇到了带你麻烦，那就是主页面的文章列表中，博客内容全部显示出来而不是只显示文章一部分和 <code>阅读全文》</code> 按钮，这样显得首页的列表很杂乱和冗长，其实要解决这个问题很简单，只需要在我们编写markdown内容的时候，在适当的位置假如如下标签：</p>
<pre><code>&lt;!--more--&gt;
</code></pre><p>那么在首页显示的部分就是此标签前面的文章内容，而非全文显示：<br><img src="http://i.imgur.com/PIN0F0K.png" alt=""></p>
]]></content>
    </entry>
    
  
  
</search>
