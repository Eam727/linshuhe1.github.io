{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":0,"renderable":0},{"_id":"source/GNAME","path":"GNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/next/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498270429418},{"_id":"source/GNAME","hash":"f57cc21e83171bf195669acd10ff809d56df1f56","modified":1498270429418},{"_id":"source/favicon.ico","hash":"f1d1de876524c6ec4a13c7055dcd47acf9e9a070","modified":1498270429512},{"_id":"source/_posts/BATCH批处理简记.md","hash":"e4ca77254102234dd9cc7f6f7fa3b499d907da60","modified":1498270429422},{"_id":"source/_posts/CG手绘初学笔记（1）.md","hash":"64f95ce0b47311d97efe01557c549c04e2248185","modified":1498270429425},{"_id":"source/_posts/CG手绘初学笔记（2）.md","hash":"15a20e08a6d03e9ef11139ece3ea92cc64cdfe1a","modified":1498270429428},{"_id":"source/_posts/CG手绘初学笔记（3）从线稿到上色.md","hash":"72ece1f36843326d147a1bbfaa15dff88004ca8c","modified":1498270429431},{"_id":"source/_posts/Github-Pages+Hexo创建个人博客.md","hash":"7aa5b393e0327ee2a5c4582735b3c359cb36309b","modified":1498270429435},{"_id":"source/_posts/Java中内嵌lua.md","hash":"97523f0aada2016a6e4898cb091513db39e4d675","modified":1498270429440},{"_id":"source/_posts/NGUI使用mask染色.md","hash":"fc2d0d033707a4dddd2222a572cd4c019bf2bcf0","modified":1498270429443},{"_id":"source/_posts/Next主题的fancybox展示图片.md","hash":"b682ac6dd2674051f20825ab08caf81ab9e18e2d","modified":1498270429446},{"_id":"source/_posts/Python-Web-1-——-python和MongoDB安装.md","hash":"693422e32b41de8cc0aaa4446e1e438fbc1288bc","modified":1498270429449},{"_id":"source/_posts/Redis简介.md","hash":"08b6cd764321464dc713342323aac628503841fd","modified":1498270429452},{"_id":"source/_posts/UE4源码编译安装.md","hash":"31dd9d7c7f7c621749fdd21df998bf64d519149b","modified":1498270429455},{"_id":"source/_posts/Unity-ShaderLab基础（一）.md","hash":"dc5cdf3134ea52d0aaf173303f6cb256af025624","modified":1498270429457},{"_id":"source/_posts/Unity-ShaderLab基础（三）.md","hash":"3bd26968b8d459c61199b5d31e3eac055ab3ac48","modified":1498270429461},{"_id":"source/_posts/Unity-ShaderLab基础（二）.md","hash":"75c2c6b3c83ecfc2a2fc76262e924a0126e88ed8","modified":1498270429464},{"_id":"source/_posts/Unity3D-Socket通信.md","hash":"b219325a1272ea9162120c9024589f479eca8345","modified":1498270429472},{"_id":"source/_posts/Unity3D-protobuf导excel表格数据.md","hash":"90e6b566ee485cf3984c8b81693153b73c17dc9a","modified":1498270429476},{"_id":"source/_posts/Unity3D-protobuf网络框架.md","hash":"51b15f4cb32cf97c57b49f18ddf3850005e8b28c","modified":1498270429481},{"_id":"source/_posts/Unity3D-——-小地图制作插件NJG-MiniMap.md","hash":"1068ba51f92da86021ae41295411e626acf6d37a","modified":1498270429485},{"_id":"source/_posts/《Unity-Shaders-and-Effects-Cookbook》读书笔记1.md","hash":"3e1f2d08f4bd718a40e8ff1a40e776f473cbaca8","modified":1498270429490},{"_id":"source/_posts/《从零开始搭建游戏服务器》redis操作指令和Jedis工具.md","hash":"24bb684426c68b0bb255dc41b43c4fd8627a008b","modified":1498270429493},{"_id":"source/_posts/《从零开始搭建游戏服务器》使用Protobuf定义网络协议.md","hash":"334250c1d4debc3f34993089f9950f695a0109a1","modified":1498270429498},{"_id":"source/_posts/《从零开始搭建游戏服务器》多个Protobuf协议的改造.md","hash":"0ba694c39bb24b9d224fbc29520b93d2f65e883f","modified":1498270429503},{"_id":"source/about/index.md","hash":"6d914c438ed637c2cc09b71824a9c5c2bc50f29e","modified":1498270429506},{"_id":"source/categories/index.md","hash":"4d561a3d051f04e765a74abe7fd3b7bbf10eaa7d","modified":1498270429509},{"_id":"source/home/index.md","hash":"607e7ee1b8534833c4a8b57a981d300ae036d3a4","modified":1498270429515},{"_id":"source/page/index.md","hash":"f793a91224f9af25eb0923acbc557b0afd84d45b","modified":1498270429517},{"_id":"source/tags/index.md","hash":"4ed090626938ffc3b5efb1410b5e219510d55807","modified":1498270429520},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"4312fb37fa2b8663006be3c4fe01125ec01171c1","modified":1472873308161},{"_id":"themes/next/languages/de.yml","hash":"4c3ffeb0d214c807a226dd98214958cb5483df1c","modified":1472873308165},{"_id":"themes/next/languages/default.yml","hash":"d2f6784b9c6567b64e58736e36025dbf96d863d4","modified":1472873308166},{"_id":"themes/next/languages/en.yml","hash":"df81ab6b1cf3c88ed053d3766381cd12eb659fe3","modified":1472873308166},{"_id":"themes/next/layout/_layout.swig","hash":"1138b849e1240249480849cc2b6c6d09b28207a5","modified":1472873308172},{"_id":"themes/next/layout/archive.swig","hash":"b867a08f6b43de8b5d700c84b943df55917407ae","modified":1472873308196},{"_id":"themes/next/layout/category.swig","hash":"58cf08388901f7549b1fca95548b2c79173aa840","modified":1472873308197},{"_id":"themes/next/layout/index.swig","hash":"e5b52e04296203262a400e8e36ae12426d31fd5b","modified":1472873308197},{"_id":"themes/next/layout/page.swig","hash":"a91e3fd7aef26e8a02e339e3372801c517f400cf","modified":1472873308198},{"_id":"themes/next/layout/post.swig","hash":"b8334c479840b7724638eec71971cbd8512ae58d","modified":1472873308198},{"_id":"themes/next/layout/tag.swig","hash":"6f764ea3ab11eeb7c530df45528d449b14f5dc62","modified":1472873308198},{"_id":"themes/next/scripts/merge-configs.js","hash":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1472873308200},{"_id":"themes/next/source/favicon.ico","hash":"f1d1de876524c6ec4a13c7055dcd47acf9e9a070","modified":1472879801154},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472873308255},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"b87a5122dbff1d5fccf8f3d09d1640bd4b01c4a0","modified":1472873308172},{"_id":"themes/next/layout/_macro/post.swig","hash":"f0862e443e1c7b9ef4a6b619b51ba6038a99a567","modified":1472873308173},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"8aa5212d803670179222dbc80e73eadd7328d8e5","modified":1472873308174},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"c5cc0070ca7c9a8dbd4b09e0398db536c3cdbe8a","modified":1472873308174},{"_id":"themes/next/layout/_partials/comments.swig","hash":"d04a53cb1bb8a5f462b05107e9c566c2dfbf4c7d","modified":1472873308175},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1472873308175},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1472873308173},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0db3ed8eed08d718fd2ebde3dc7c0c5bb4adfb8a","modified":1472897591127},{"_id":"themes/next/layout/_partials/head.swig","hash":"881abebed3a7fa71827365b0ba0e84ec525eeb7f","modified":1472873308176},{"_id":"themes/next/layout/_partials/header.swig","hash":"c0697644817f1570093de9f17ea096295da8c5f1","modified":1472873308177},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1472873308177},{"_id":"themes/next/layout/_partials/search.swig","hash":"95b55fe35f2d2c22f2cc055d4379b5435314c7ec","modified":1472873308178},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c5db707b46eac6a5df1d2a77f8556945a66fd181","modified":1472873308181},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1472873308182},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1472873308182},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"c9d45628330ce8bf5fbe71c9f131c7d75334c1c4","modified":1472873308196},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1472873308201},{"_id":"themes/next/scripts/tags/full-image.js","hash":"86194a05a8c6499de0b2aaa525d6de135778c0ae","modified":1472873308201},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1472873308202},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1472873308256},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1472873308255},{"_id":"themes/next/source/images/avatar.png","hash":"542aeead165dfc4f9f1a4af17b999c38a0cb96b8","modified":1472888747289},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1472873308256},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1472873308257},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1472873308257},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1472873308260},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1472873308261},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1472873308261},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1472873308262},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472873308262},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472873308263},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1472873308263},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1472873308264},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1472873308264},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472873308184},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472873308184},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472873308237},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472873308237},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472873308239},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472873308253},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472873308254},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1472873308177},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"efa7efcbb575381b508f9aa0e0c53140eef72a7b","modified":1472873308178},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1472873308178},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1472873308179},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"bf8e9223a40748b2e3ef77d753a8e1dbbce8095e","modified":1472873308179},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"3fdde03f45a80f7a85097a40b40358adde618fc7","modified":1472873308180},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1472873308180},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1472873308181},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1472873308183},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1472873308185},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"91c5353fcb94cc3b3f265b06ad2341734bc4c826","modified":1472873308186},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"8ba01f1ac07fbca62a4b00f5a0a3a506122c1530","modified":1472873308193},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"e495aed8fb36bf8015ddbd64366270a7debad2b0","modified":1472873308194},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"f6b46096208512b4d8680c024fcb68f03ceab008","modified":1472873308195},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"4a5c6df1579a4ca72ed17f7dbd6d16a509aa7dc8","modified":1472873308195},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1472873308196},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1472873308236},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1472873308238},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"531934ea21ef4dc9f0978512050f54834f0a6cff","modified":1472873308238},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1472873308253},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"b8e3663996b39590509d843f674360872b0242ac","modified":1472873308253},{"_id":"themes/next/source/css/_variables/base.styl","hash":"a7ae72e846393493385275d934eaa78534d9834c","modified":1472873308254},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"ae5b8597603d4e42ee66ed121544e7b1c644767e","modified":1472873308187},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"24105e62d7f26946907fa14cd02589f899bf8122","modified":1472873308188},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"a576c23d426ab236eb3dcd0bfe1b3f0b0c54ad1a","modified":1472873308191},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"a79e7e0d809fcf407593dd7ed9e023db21c3cbd6","modified":1472873308192},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1472873308192},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1472873308193},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"f8b6a3017ab79057ce99f1ccb512193d67f4a35f","modified":1472873308194},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"0a2f48971d86ea72e1a8fd1d8bbf2b7d423666b2","modified":1472873308194},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ad69cbf94eedacc27e756cdb9c7073416db697d0","modified":1472873308204},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1472873308205},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1472873308206},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"b7d5cc29586ac796a50d90974ad99d24a5982137","modified":1472873308206},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1472873308214},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1472873308227},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1472873308232},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5a35aa0381b0e1d465b952a997194441020446ea","modified":1472873308233},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"b6ee5fefa6046086a76ddbcfafc82482816fa3e0","modified":1472873308234},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1472873308235},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1472873308236},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1472873308235},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1472873308239},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1472873308240},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1472873308240},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1472873308242},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"55b44e03054cd20ed8129bf986b15fba5fd85aad","modified":1472873308242},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1472873308243},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1472873308243},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"124b540f059fd1ed13514362007cfc70355278c6","modified":1472873308245},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1472873308246},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"13af2fb21fabfc4df4b577ce5363e13d03daff71","modified":1472873308246},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1472873308246},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1472873308247},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"de31e923bf5102498f06b1ae6bdf2ea22409f3e0","modified":1472873308249},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c9875c010bebd77b4f59d459a10455fceb0a66a1","modified":1472873308249},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"2182a6da3434a6fd4d03ab1592c645d3d3c88500","modified":1472873308249},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"9887bd3894db5394c1e64e800afaae55f47e8dd0","modified":1472873308250},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1472873308250},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"983c0723e8cfd84b67c2e66da0c26425a8db06e0","modified":1472873308251},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"88a5e0e95f93e4adb196bff1aac17d6cfb03768a","modified":1472873308251},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1472873308209},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1472873308208},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1472873308209},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"852fd77500bda2c1a6651a14aa48d7d6222adc9d","modified":1472873308210},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1472873308211},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1472873308211},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"70ec8d38d2b3ee1906793d1dcb68032adfa65f03","modified":1472873308212},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"12e366f04497e3f44388fd40111a03e02f7c26af","modified":1472873308212},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1472873308212},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1472873308213},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"b8f9c95702e87fd0b170ab586c82c9718a245f8a","modified":1472873308213},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1472873308214},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a45f5fce643eec4e1b927165229d560364bcace1","modified":1472873308215},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1472873308215},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"4866fb9453d7d4c83a1c4e55d74e4afed336eb8b","modified":1472873308216},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1472873308217},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ca20affaeaf33c0904cb6356864fc6b78e95f447","modified":1472873308217},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"2bc3e33fdfbcf348c96ca60598f629dcd7ba3617","modified":1472873308218},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"929fac3a505bacbce6ba63009fd15851e2a8669d","modified":1472873308218},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1472873308220},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1472873308221},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1472873308221},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"681b7c8ce4dc47130a0ca67c1ec62be7c96e4c4f","modified":1472873308222},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1472873308221},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1472873308222},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1472873308223},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1472873308225},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"821991c0890966a512b43e8b1cf9537e738a09a0","modified":1472873308224},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1472873308225},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"394888efec32749b353292a59ec7f1b609d6325e","modified":1472873308225},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"06b9a99d63b4d57fdbf70b88ab7036fbc47e3f52","modified":1472873308226},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"702be9e57dd6ff5fa99642a1f6e3df26215b8805","modified":1472873308226},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1472873308227},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1472873308228},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1472873308229},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"dd941824210733588841897457e0cc9697ca5608","modified":1472873308228},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"a83f493e494f5c73fab8f6f5b686ef1670490095","modified":1472873308229},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"7f7e9df15148608a9c29326dd880d8e8e8efc0ec","modified":1472873308230},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"dcb4548d07cbb38b645b1753cf3ee7157e16921a","modified":1472873308231},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1472873308229},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"7bd182d918f3117335a5ee87a1b544e6d2b54d7d","modified":1472873308232},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1472873308244},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"cf900c5026ab36f31118317d0ae32a213e3ec2a9","modified":1472873308244},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1472873308231},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1472873308231},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"cf900c5026ab36f31118317d0ae32a213e3ec2a9","modified":1472873308248},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1472873308327},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1472873308329},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1472873308328},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1472873308265},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"4a0da1bed19e65bd7db42421b447061bc1618710","modified":1472873308266},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1472873308267},{"_id":"themes/next/source/js/src/post-details.js","hash":"458af3b1bd7783c1950808e66cedfa9fb68bf21f","modified":1472873308269},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1472873308268},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1472873308271},{"_id":"themes/next/source/js/src/utils.js","hash":"418d09eb4df5dcc5e8d13d7f6245b1888200b51c","modified":1472873308272},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1472873308274},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1472873308274},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1472873308288},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1472873308288},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1472873308289},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1472873308289},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"bb093f2ac1f1305069d873a7941324c8e0de3135","modified":1472873308292},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1472873308292},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1472873308293},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1472873308293},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1472873308293},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1472873308309},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1472873308312},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1472873308313},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1472873308313},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1472873308312},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1472873308319},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1472873308315},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1472873308324},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1472873308314},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1472873308320},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1472873308325},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1472873308326},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1472873308311},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"a9d064d600ee35acd66508167e1ac8c6cfdbdcd8","modified":1472873308270},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1472873308275},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1472873308275},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1472873308276},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1472873308276},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1472873308277},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1472873308277},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1472873308285},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1472873308291},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1472873308291},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"811432ad1e2d6c1f6da9a63fd919bf2a02b71dd9","modified":1472873308294},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1472873308295},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"4c2c5f5f6cc86d775a44b944661e038b7be98149","modified":1472873308297},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1472873308306},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1472873308318},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1472873308318},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1472873308286},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1472873308287},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1472873308298},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1472873308299},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1472873308306},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1472873308322},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1472873308280},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1472873308280},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1472873308282},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1472873308283},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1472873308283},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1472873308284},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1472873308305},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1472873308303},{"_id":"themes/next/.bowerrc","hash":"20038353db532b4c40625419d396da7359f89cbe","modified":1472873308160},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1472873308160},{"_id":"themes/next/.gitignore","hash":"80710b94ff2f6c013859ebffffe90f9295fc94ed","modified":1472873308162},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1472873308162},{"_id":"themes/next/.javascript_ignore","hash":"beb0b95736650284ceb712a162cc033847a83cd3","modified":1472873308162},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1472873308162},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1472873308164},{"_id":"themes/next/_config.yml","hash":"3c71783dc02fe6ba00f70b42c5f716b4879b9d02","modified":1472893169385},{"_id":"themes/next/README.en.md","hash":"fa31bbc6dd8778b8dee469740c92b3b5b59702af","modified":1472873308163},{"_id":"themes/next/bower.json","hash":"da39b00fcdf2e7a42af412de0a4d3617cc6d7084","modified":1472873308164},{"_id":"themes/next/gulpfile.coffee","hash":"4e8c1082fa82e383494ff5b5963b7936d9c7bb2e","modified":1472873308165},{"_id":"themes/next/package.json","hash":"95eaba1607544965e432d56406bae391dd11bcbb","modified":1472873308199},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"2692e36cc35b1594530981e7727771f601720a43","modified":1472873308161},{"_id":"themes/next/languages/fr-FR.yml","hash":"d8a40fe025fad6f42df0cf16d4be2d513769b062","modified":1472873308167},{"_id":"themes/next/languages/id.yml","hash":"19537c8bae42c4c2e7d06a64537e8dfd503b7e19","modified":1472873308167},{"_id":"themes/next/languages/ja.yml","hash":"e594aa42a33c489e4a65065659a01bb76c3c0cb5","modified":1472873308168},{"_id":"themes/next/languages/ko.yml","hash":"feed5fdb677f87fbb9ba2b6e4413e7011180708e","modified":1472873308168},{"_id":"themes/next/languages/pt-BR.yml","hash":"81498b783372f11b2149bd2b1731e78432760a0e","modified":1472873308169},{"_id":"themes/next/languages/pt.yml","hash":"4c64594f477905d5d2d9ca2422f03175b7b0c617","modified":1472873308169},{"_id":"themes/next/languages/ru.yml","hash":"c3aedb94decf05a301662afc3398ab563dd9995a","modified":1472873308169},{"_id":"themes/next/languages/zh-Hans.yml","hash":"48f4a7afe77a91ab154649dcfe6bd49a5a77c25f","modified":1473133842729},{"_id":"themes/next/languages/zh-hk.yml","hash":"88e603eb0f3fd25c35bb37bd30372fd77bba7c46","modified":1472873308171},{"_id":"themes/next/languages/zh-tw.yml","hash":"04479b419c72b71fd34046f3fc33ebda4fe8de84","modified":1472873308171}],"Category":[{"name":"业余爱好","_id":"cj4anjfiu00079gfjo9zfitk1"},{"name":"Hexo","_id":"cj4anjfk7000p9gfj5wdoach0"},{"name":"服务器开发","_id":"cj4anjfkl000w9gfjrkqsx0bo"},{"name":"游戏前端","_id":"cj4anjfkr00129gfjo370dqsc"},{"name":"Web","_id":"cj4anjfky00189gfj1ztrcxcq"},{"name":"python","_id":"cj4anjfl9001f9gfjnaxksr8z"},{"name":"数据库","_id":"cj4anjflg001l9gfjt5zsq0hi"},{"name":"Unity","_id":"cj4anjflr001u9gfj81jfcyx7"}],"Data":[],"Page":[{"title":"关于","date":"2016-09-03T06:26:10.000Z","type":"about","_content":"\n>有些路，总得自己一个人走~\n>\n>——摆渡者\n\n## 个人简介：\n\n---\n\n1. Android应用开发者\n2. Unity手游开发者\n\n---\n\n作为一名电子专业毕业的普通大学生，我本应与硬件电路或通信行业更加息息相关，却误打误撞进了程序圈，还鬼使神差地选择了手机游戏开发的职业。\n\n大四找实习的时候，凭借着不知道哪里捡来的臭不要脸的自信还有大学自学的撇脚的一点点Java和Android编程基础，在面试的时候一本正经地胡说八道，总算找到了第一份实习工作，也是后来我毕业后待的时间最长的一份工作。\n\n要说不是为了相较其他行业稍微高一点点的工资估计也没人信，但其实更主要的原因，应该是自己对于通过一行行一般人完全看不懂的代码实现出各种功能之后成就感的执念吧，这也正是我近几年内会继续走下去的路。\n\n总之，一句话：梦想还是要有的，没准狗屎运呢~\n\n---\n\n## 参与作品：\n\n APP：[趣国学](http://zhushou.360.cn/detail/index/soft_id/2997216) \n![](http://i.imgur.com/L0rTpJZ.png)\n\n 3D游戏：[全职猎人-格斗篇](http://zhushou.360.cn/detail/index/soft_id/3172704?recrefer=SE_D_%E5%85%A8%E8%81%8C%E7%8C%8E%E4%BA%BA) \n![](http://i.imgur.com/4MiAYWy.png)\n\n---\n\n## 联系方式：\n\n- QQ：695671725\n- 邮箱：linshuhe1@gmail.com | 695671725@qq.com\n- 微博：[__何乐不为__](http://weibo.com/2306456162)\n\n欢迎沟通交流，一起进步！","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2016-09-03 14:26:10\ntype: \"about\"\n---\n\n>有些路，总得自己一个人走~\n>\n>——摆渡者\n\n## 个人简介：\n\n---\n\n1. Android应用开发者\n2. Unity手游开发者\n\n---\n\n作为一名电子专业毕业的普通大学生，我本应与硬件电路或通信行业更加息息相关，却误打误撞进了程序圈，还鬼使神差地选择了手机游戏开发的职业。\n\n大四找实习的时候，凭借着不知道哪里捡来的臭不要脸的自信还有大学自学的撇脚的一点点Java和Android编程基础，在面试的时候一本正经地胡说八道，总算找到了第一份实习工作，也是后来我毕业后待的时间最长的一份工作。\n\n要说不是为了相较其他行业稍微高一点点的工资估计也没人信，但其实更主要的原因，应该是自己对于通过一行行一般人完全看不懂的代码实现出各种功能之后成就感的执念吧，这也正是我近几年内会继续走下去的路。\n\n总之，一句话：梦想还是要有的，没准狗屎运呢~\n\n---\n\n## 参与作品：\n\n APP：[趣国学](http://zhushou.360.cn/detail/index/soft_id/2997216) \n![](http://i.imgur.com/L0rTpJZ.png)\n\n 3D游戏：[全职猎人-格斗篇](http://zhushou.360.cn/detail/index/soft_id/3172704?recrefer=SE_D_%E5%85%A8%E8%81%8C%E7%8C%8E%E4%BA%BA) \n![](http://i.imgur.com/4MiAYWy.png)\n\n---\n\n## 联系方式：\n\n- QQ：695671725\n- 邮箱：linshuhe1@gmail.com | 695671725@qq.com\n- 微博：[__何乐不为__](http://weibo.com/2306456162)\n\n欢迎沟通交流，一起进步！","updated":"2017-06-24T02:13:49.506Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj4anjfh800019gfjq5tjaraf","content":"<blockquote>\n<p>有些路，总得自己一个人走~</p>\n<p>——摆渡者</p>\n</blockquote>\n<h2 id=\"个人简介：\"><a href=\"#个人简介：\" class=\"headerlink\" title=\"个人简介：\"></a>个人简介：</h2><hr>\n<ol>\n<li>Android应用开发者</li>\n<li>Unity手游开发者</li>\n</ol>\n<hr>\n<p>作为一名电子专业毕业的普通大学生，我本应与硬件电路或通信行业更加息息相关，却误打误撞进了程序圈，还鬼使神差地选择了手机游戏开发的职业。</p>\n<p>大四找实习的时候，凭借着不知道哪里捡来的臭不要脸的自信还有大学自学的撇脚的一点点Java和Android编程基础，在面试的时候一本正经地胡说八道，总算找到了第一份实习工作，也是后来我毕业后待的时间最长的一份工作。</p>\n<p>要说不是为了相较其他行业稍微高一点点的工资估计也没人信，但其实更主要的原因，应该是自己对于通过一行行一般人完全看不懂的代码实现出各种功能之后成就感的执念吧，这也正是我近几年内会继续走下去的路。</p>\n<p>总之，一句话：梦想还是要有的，没准狗屎运呢~</p>\n<hr>\n<h2 id=\"参与作品：\"><a href=\"#参与作品：\" class=\"headerlink\" title=\"参与作品：\"></a>参与作品：</h2><p> APP：<a href=\"http://zhushou.360.cn/detail/index/soft_id/2997216\" target=\"_blank\" rel=\"external\">趣国学</a><br><img src=\"http://i.imgur.com/L0rTpJZ.png\" alt=\"\"></p>\n<p> 3D游戏：<a href=\"http://zhushou.360.cn/detail/index/soft_id/3172704?recrefer=SE_D_%E5%85%A8%E8%81%8C%E7%8C%8E%E4%BA%BA\" target=\"_blank\" rel=\"external\">全职猎人-格斗篇</a><br><img src=\"http://i.imgur.com/4MiAYWy.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"联系方式：\"><a href=\"#联系方式：\" class=\"headerlink\" title=\"联系方式：\"></a>联系方式：</h2><ul>\n<li>QQ：695671725</li>\n<li>邮箱：linshuhe1@gmail.com | 695671725@qq.com</li>\n<li>微博：<a href=\"http://weibo.com/2306456162\" target=\"_blank\" rel=\"external\"><strong>何乐不为</strong></a></li>\n</ul>\n<p>欢迎沟通交流，一起进步！</p>\n","excerpt":"","more":"<blockquote>\n<p>有些路，总得自己一个人走~</p>\n<p>——摆渡者</p>\n</blockquote>\n<h2 id=\"个人简介：\"><a href=\"#个人简介：\" class=\"headerlink\" title=\"个人简介：\"></a>个人简介：</h2><hr>\n<ol>\n<li>Android应用开发者</li>\n<li>Unity手游开发者</li>\n</ol>\n<hr>\n<p>作为一名电子专业毕业的普通大学生，我本应与硬件电路或通信行业更加息息相关，却误打误撞进了程序圈，还鬼使神差地选择了手机游戏开发的职业。</p>\n<p>大四找实习的时候，凭借着不知道哪里捡来的臭不要脸的自信还有大学自学的撇脚的一点点Java和Android编程基础，在面试的时候一本正经地胡说八道，总算找到了第一份实习工作，也是后来我毕业后待的时间最长的一份工作。</p>\n<p>要说不是为了相较其他行业稍微高一点点的工资估计也没人信，但其实更主要的原因，应该是自己对于通过一行行一般人完全看不懂的代码实现出各种功能之后成就感的执念吧，这也正是我近几年内会继续走下去的路。</p>\n<p>总之，一句话：梦想还是要有的，没准狗屎运呢~</p>\n<hr>\n<h2 id=\"参与作品：\"><a href=\"#参与作品：\" class=\"headerlink\" title=\"参与作品：\"></a>参与作品：</h2><p> APP：<a href=\"http://zhushou.360.cn/detail/index/soft_id/2997216\">趣国学</a><br><img src=\"http://i.imgur.com/L0rTpJZ.png\" alt=\"\"></p>\n<p> 3D游戏：<a href=\"http://zhushou.360.cn/detail/index/soft_id/3172704?recrefer=SE_D_%E5%85%A8%E8%81%8C%E7%8C%8E%E4%BA%BA\">全职猎人-格斗篇</a><br><img src=\"http://i.imgur.com/4MiAYWy.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"联系方式：\"><a href=\"#联系方式：\" class=\"headerlink\" title=\"联系方式：\"></a>联系方式：</h2><ul>\n<li>QQ：695671725</li>\n<li>邮箱：linshuhe1@gmail.com | 695671725@qq.com</li>\n<li>微博：<a href=\"http://weibo.com/2306456162\"><strong>何乐不为</strong></a></li>\n</ul>\n<p>欢迎沟通交流，一起进步！</p>\n"},{"title":"分类","date":"2016-09-03T07:23:58.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-09-03 15:23:58\ntype: \"categories\"\n---\n","updated":"2017-06-24T02:13:49.509Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj4anjfhk00039gfjwpi7wimf","content":"","excerpt":"","more":""},{"title":"首页","date":"2016-09-03T07:14:47.000Z","type":"home","_content":"","source":"home/index.md","raw":"---\ntitle: 首页\ndate: 2016-09-03 15:14:47\ntype: \"home\"\n---\n","updated":"2017-06-24T02:13:49.515Z","path":"home/index.html","comments":1,"layout":"page","_id":"cj4anjfih00069gfj8pzcwb4d","content":"","excerpt":"","more":""},{"title":"page","date":"2016-09-03T09:42:59.000Z","type":"page","_content":"","source":"page/index.md","raw":"---\ntitle: page\ndate: 2016-09-03 17:42:59\ntype: \"page\"\n---\n","updated":"2017-06-24T02:13:49.517Z","path":"page/index.html","comments":1,"layout":"page","_id":"cj4anjfjb00099gfjmaamt0x2","content":"","excerpt":"","more":""},{"title":"标签","date":"2016-09-03T06:41:01.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2016-09-03 14:41:01\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-06-24T02:13:49.520Z","path":"tags/index.html","layout":"page","_id":"cj4anjfn100319gfj75e7x969","content":"","excerpt":"","more":""}],"Post":[{"title":"BATCH批处理简记","date":"2016-09-03T09:10:59.000Z","_content":"\n>本文转载自原文[批处理经典入门教程！(从不懂到高手)](http://www.jb51.net/article/7131_3.htm)，只是原文作者太罗嗦了，我做了稍微的简化。\n\n 1. 批处理定义\n 2. 基本语法和常用命令\n 3. 例子\n\n<!--more-->\n\n___\n### 一.批处理定义\n批处理的本质，其实是一堆DOS命令，他们按一定顺序排列而形成的集合就是批处理。批处理，也称为批处理脚本，英文译为BATCH，批处理文件后缀BAT就取的前三个字母。\n**注意：**批处理的每一行可视为一个命令，每个命令里可以含多条子命令，从第一行开始执行，直到最后一行结束，它运行的平台是DOS。\n\n___\n### 二.基本语法和常用命令\n1.注释方式：\n使用“::”双冒号的方式进行注释，注释符号之后的同一行中的内容在脚本执行时不显示，也不起任何作用，只是增加了脚本的可读性，在批处理脚本中和rem命令等效。例如：\n\n\t@echo off \n\t::close echo \n\tcls \n\t::clean screen \n\n2.@符号：\n让脚本执行窗口不显示此符号之后指令内容的命令本身，而只显示执行结果，就像上例中的“@echo off”，@可以使得doc中不显示echo off，而直接显示其执行的结果。\n\n3.echo:\n可以看做是回写或者是反馈，但实际上它是一个开关，而控制它的指令就是echo on和echo off了，而直接执行echo指令则会显示当前echo所处的状态（on或off）。执行echo off将关闭回显，它后面的所有命令都不显示命令本身，只显示执行后的结果，除非执行echo on命令。\necho命令的另一种用法一：可以用它来显示信息，如：```echo hello world````,会在doc中打印“hello world”;\necho命令的另一种用法二：可以直接编辑文本文件,如：在doc窗口直接输入````echo nbtstat -A 192.168.0.1 > a.bat ````，执行结果会在当前目录下创建一个a.bat文件。\n\n4.pause:\n直接可以看出它是“暂停”的意思，即让当前程序进程暂停一下，并显示一行信息：请按任意键继续. . .。\n\n5.\"goto\"和\":\":\n这两个指令是以一个组合形式出现的，goto是一个跳转指令，一般脚本执行到goto指令时，会跳转到：:标签定义的部分区执行。例如：\n\n\tgoto usage\n\t...\n\t:usage\n\t...\n\n不难看出，goto命令就是根据这个冒号和标签名称来寻找它该跳转的地方，它们是一一对应的关系，goto命令也经常和if命令结合使用。\ngoto命令的另一种用法一：提前结束程序。在程序中间使用goto命令跳转到某一标签，而这一标签的内容却定义为退出。 \n如： \n\n\t…… \n\tgoto end \n\t…… \n\t:end \n\n这里:end在脚本最后一行！\n\n6.%:\n单个%不算是命令，而相当于参数，例如：\n\n\tnet use \\\\%1\\ipc$ %3 /u:\"%2\" \n\tcopy 11.BAT \\\\%1\\admin$\\system32 /y \n\tcopy 13.BAT \\\\%1\\admin$\\system32 /y \n\tcopy ipc2.BAT \\\\%1\\admin$\\system32 /y \n\tcopy NWZI.EXE \\\\%1\\admin$\\system32 /y \n\tattrib \\\\%1\\admin$\\system32⏺.bat -r -h -s \n\n以上代码是Bat.Worm.Muma病毒中的一部分，%1代表的IP，2%代表的username，3%代表password。执行形式为：脚本文件名 参数一 参数二 ……。假设这个脚本被保存为a.bat，则执行形式如下：a IP username password。这里IP、username、password是三个参数，缺一不可（因为程序不能正确运行，并不是因为少了参数语法就不对）这样在脚本执行过程中，脚本就自动用用你的三个参数依次（记住，是依次！也是一一对应的关系。）代换1%、2%和3%，这样就达到了灵活运用的目的。 \n___\n\n### 三、例子\n将所需的命令都写在一个文件中，并且修改文件的后缀名为.bat，双击执行即会弹出doc窗口执行文件中的脚本命令。","source":"_posts/BATCH批处理简记.md","raw":"---\ntitle: BATCH批处理简记\ndate: 2016-09-03 17:10:59\ntags: 批处理\n---\n\n>本文转载自原文[批处理经典入门教程！(从不懂到高手)](http://www.jb51.net/article/7131_3.htm)，只是原文作者太罗嗦了，我做了稍微的简化。\n\n 1. 批处理定义\n 2. 基本语法和常用命令\n 3. 例子\n\n<!--more-->\n\n___\n### 一.批处理定义\n批处理的本质，其实是一堆DOS命令，他们按一定顺序排列而形成的集合就是批处理。批处理，也称为批处理脚本，英文译为BATCH，批处理文件后缀BAT就取的前三个字母。\n**注意：**批处理的每一行可视为一个命令，每个命令里可以含多条子命令，从第一行开始执行，直到最后一行结束，它运行的平台是DOS。\n\n___\n### 二.基本语法和常用命令\n1.注释方式：\n使用“::”双冒号的方式进行注释，注释符号之后的同一行中的内容在脚本执行时不显示，也不起任何作用，只是增加了脚本的可读性，在批处理脚本中和rem命令等效。例如：\n\n\t@echo off \n\t::close echo \n\tcls \n\t::clean screen \n\n2.@符号：\n让脚本执行窗口不显示此符号之后指令内容的命令本身，而只显示执行结果，就像上例中的“@echo off”，@可以使得doc中不显示echo off，而直接显示其执行的结果。\n\n3.echo:\n可以看做是回写或者是反馈，但实际上它是一个开关，而控制它的指令就是echo on和echo off了，而直接执行echo指令则会显示当前echo所处的状态（on或off）。执行echo off将关闭回显，它后面的所有命令都不显示命令本身，只显示执行后的结果，除非执行echo on命令。\necho命令的另一种用法一：可以用它来显示信息，如：```echo hello world````,会在doc中打印“hello world”;\necho命令的另一种用法二：可以直接编辑文本文件,如：在doc窗口直接输入````echo nbtstat -A 192.168.0.1 > a.bat ````，执行结果会在当前目录下创建一个a.bat文件。\n\n4.pause:\n直接可以看出它是“暂停”的意思，即让当前程序进程暂停一下，并显示一行信息：请按任意键继续. . .。\n\n5.\"goto\"和\":\":\n这两个指令是以一个组合形式出现的，goto是一个跳转指令，一般脚本执行到goto指令时，会跳转到：:标签定义的部分区执行。例如：\n\n\tgoto usage\n\t...\n\t:usage\n\t...\n\n不难看出，goto命令就是根据这个冒号和标签名称来寻找它该跳转的地方，它们是一一对应的关系，goto命令也经常和if命令结合使用。\ngoto命令的另一种用法一：提前结束程序。在程序中间使用goto命令跳转到某一标签，而这一标签的内容却定义为退出。 \n如： \n\n\t…… \n\tgoto end \n\t…… \n\t:end \n\n这里:end在脚本最后一行！\n\n6.%:\n单个%不算是命令，而相当于参数，例如：\n\n\tnet use \\\\%1\\ipc$ %3 /u:\"%2\" \n\tcopy 11.BAT \\\\%1\\admin$\\system32 /y \n\tcopy 13.BAT \\\\%1\\admin$\\system32 /y \n\tcopy ipc2.BAT \\\\%1\\admin$\\system32 /y \n\tcopy NWZI.EXE \\\\%1\\admin$\\system32 /y \n\tattrib \\\\%1\\admin$\\system32⏺.bat -r -h -s \n\n以上代码是Bat.Worm.Muma病毒中的一部分，%1代表的IP，2%代表的username，3%代表password。执行形式为：脚本文件名 参数一 参数二 ……。假设这个脚本被保存为a.bat，则执行形式如下：a IP username password。这里IP、username、password是三个参数，缺一不可（因为程序不能正确运行，并不是因为少了参数语法就不对）这样在脚本执行过程中，脚本就自动用用你的三个参数依次（记住，是依次！也是一一对应的关系。）代换1%、2%和3%，这样就达到了灵活运用的目的。 \n___\n\n### 三、例子\n将所需的命令都写在一个文件中，并且修改文件的后缀名为.bat，双击执行即会弹出doc窗口执行文件中的脚本命令。","slug":"BATCH批处理简记","published":1,"updated":"2017-06-24T02:13:49.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfgx00009gfjlsoem3i0","content":"<blockquote>\n<p>本文转载自原文<a href=\"http://www.jb51.net/article/7131_3.htm\" target=\"_blank\" rel=\"external\">批处理经典入门教程！(从不懂到高手)</a>，只是原文作者太罗嗦了，我做了稍微的简化。</p>\n</blockquote>\n<ol>\n<li>批处理定义</li>\n<li>基本语法和常用命令</li>\n<li>例子</li>\n</ol>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"一-批处理定义\"><a href=\"#一-批处理定义\" class=\"headerlink\" title=\"一.批处理定义\"></a>一.批处理定义</h3><p>批处理的本质，其实是一堆DOS命令，他们按一定顺序排列而形成的集合就是批处理。批处理，也称为批处理脚本，英文译为BATCH，批处理文件后缀BAT就取的前三个字母。<br><strong>注意：</strong>批处理的每一行可视为一个命令，每个命令里可以含多条子命令，从第一行开始执行，直到最后一行结束，它运行的平台是DOS。</p>\n<hr>\n<h3 id=\"二-基本语法和常用命令\"><a href=\"#二-基本语法和常用命令\" class=\"headerlink\" title=\"二.基本语法和常用命令\"></a>二.基本语法和常用命令</h3><p>1.注释方式：<br>使用“::”双冒号的方式进行注释，注释符号之后的同一行中的内容在脚本执行时不显示，也不起任何作用，只是增加了脚本的可读性，在批处理脚本中和rem命令等效。例如：</p>\n<pre><code>@echo off \n::close echo \ncls \n::clean screen \n</code></pre><p>2.@符号：<br>让脚本执行窗口不显示此符号之后指令内容的命令本身，而只显示执行结果，就像上例中的“@echo off”，@可以使得doc中不显示echo off，而直接显示其执行的结果。</p>\n<p>3.echo:<br>可以看做是回写或者是反馈，但实际上它是一个开关，而控制它的指令就是echo on和echo off了，而直接执行echo指令则会显示当前echo所处的状态（on或off）。执行echo off将关闭回显，它后面的所有命令都不显示命令本身，只显示执行后的结果，除非执行echo on命令。<br>echo命令的另一种用法一：可以用它来显示信息，如：```echo hello world<code>,会在doc中打印“hello world”;\necho命令的另一种用法二：可以直接编辑文本文件,如：在doc窗口直接输入</code>echo nbtstat -A 192.168.0.1 &gt; a.bat ````，执行结果会在当前目录下创建一个a.bat文件。</p>\n<p>4.pause:<br>直接可以看出它是“暂停”的意思，即让当前程序进程暂停一下，并显示一行信息：请按任意键继续. . .。</p>\n<p>5.”goto”和”:”:<br>这两个指令是以一个组合形式出现的，goto是一个跳转指令，一般脚本执行到goto指令时，会跳转到：:标签定义的部分区执行。例如：</p>\n<pre><code>goto usage\n...\n:usage\n...\n</code></pre><p>不难看出，goto命令就是根据这个冒号和标签名称来寻找它该跳转的地方，它们是一一对应的关系，goto命令也经常和if命令结合使用。<br>goto命令的另一种用法一：提前结束程序。在程序中间使用goto命令跳转到某一标签，而这一标签的内容却定义为退出。<br>如： </p>\n<pre><code>…… \ngoto end \n…… \n:end \n</code></pre><p>这里:end在脚本最后一行！</p>\n<p>6.%:<br>单个%不算是命令，而相当于参数，例如：</p>\n<pre><code>net use \\\\%1\\ipc$ %3 /u:&quot;%2&quot; \ncopy 11.BAT \\\\%1\\admin$\\system32 /y \ncopy 13.BAT \\\\%1\\admin$\\system32 /y \ncopy ipc2.BAT \\\\%1\\admin$\\system32 /y \ncopy NWZI.EXE \\\\%1\\admin$\\system32 /y \nattrib \\\\%1\\admin$\\system32⏺.bat -r -h -s \n</code></pre><p>以上代码是Bat.Worm.Muma病毒中的一部分，%1代表的IP，2%代表的username，3%代表password。执行形式为：脚本文件名 参数一 参数二 ……。假设这个脚本被保存为a.bat，则执行形式如下：a IP username password。这里IP、username、password是三个参数，缺一不可（因为程序不能正确运行，并不是因为少了参数语法就不对）这样在脚本执行过程中，脚本就自动用用你的三个参数依次（记住，是依次！也是一一对应的关系。）代换1%、2%和3%，这样就达到了灵活运用的目的。 </p>\n<hr>\n<h3 id=\"三、例子\"><a href=\"#三、例子\" class=\"headerlink\" title=\"三、例子\"></a>三、例子</h3><p>将所需的命令都写在一个文件中，并且修改文件的后缀名为.bat，双击执行即会弹出doc窗口执行文件中的脚本命令。</p>\n","excerpt":"<blockquote>\n<p>本文转载自原文<a href=\"http://www.jb51.net/article/7131_3.htm\">批处理经典入门教程！(从不懂到高手)</a>，只是原文作者太罗嗦了，我做了稍微的简化。</p>\n</blockquote>\n<ol>\n<li>批处理定义</li>\n<li>基本语法和常用命令</li>\n<li>例子</li>\n</ol>","more":"<hr>\n<h3 id=\"一-批处理定义\"><a href=\"#一-批处理定义\" class=\"headerlink\" title=\"一.批处理定义\"></a>一.批处理定义</h3><p>批处理的本质，其实是一堆DOS命令，他们按一定顺序排列而形成的集合就是批处理。批处理，也称为批处理脚本，英文译为BATCH，批处理文件后缀BAT就取的前三个字母。<br><strong>注意：</strong>批处理的每一行可视为一个命令，每个命令里可以含多条子命令，从第一行开始执行，直到最后一行结束，它运行的平台是DOS。</p>\n<hr>\n<h3 id=\"二-基本语法和常用命令\"><a href=\"#二-基本语法和常用命令\" class=\"headerlink\" title=\"二.基本语法和常用命令\"></a>二.基本语法和常用命令</h3><p>1.注释方式：<br>使用“::”双冒号的方式进行注释，注释符号之后的同一行中的内容在脚本执行时不显示，也不起任何作用，只是增加了脚本的可读性，在批处理脚本中和rem命令等效。例如：</p>\n<pre><code>@echo off \n::close echo \ncls \n::clean screen \n</code></pre><p>2.@符号：<br>让脚本执行窗口不显示此符号之后指令内容的命令本身，而只显示执行结果，就像上例中的“@echo off”，@可以使得doc中不显示echo off，而直接显示其执行的结果。</p>\n<p>3.echo:<br>可以看做是回写或者是反馈，但实际上它是一个开关，而控制它的指令就是echo on和echo off了，而直接执行echo指令则会显示当前echo所处的状态（on或off）。执行echo off将关闭回显，它后面的所有命令都不显示命令本身，只显示执行后的结果，除非执行echo on命令。<br>echo命令的另一种用法一：可以用它来显示信息，如：```echo hello world<code>,会在doc中打印“hello world”;\necho命令的另一种用法二：可以直接编辑文本文件,如：在doc窗口直接输入</code>echo nbtstat -A 192.168.0.1 &gt; a.bat ````，执行结果会在当前目录下创建一个a.bat文件。</p>\n<p>4.pause:<br>直接可以看出它是“暂停”的意思，即让当前程序进程暂停一下，并显示一行信息：请按任意键继续. . .。</p>\n<p>5.”goto”和”:”:<br>这两个指令是以一个组合形式出现的，goto是一个跳转指令，一般脚本执行到goto指令时，会跳转到：:标签定义的部分区执行。例如：</p>\n<pre><code>goto usage\n...\n:usage\n...\n</code></pre><p>不难看出，goto命令就是根据这个冒号和标签名称来寻找它该跳转的地方，它们是一一对应的关系，goto命令也经常和if命令结合使用。<br>goto命令的另一种用法一：提前结束程序。在程序中间使用goto命令跳转到某一标签，而这一标签的内容却定义为退出。<br>如： </p>\n<pre><code>…… \ngoto end \n…… \n:end \n</code></pre><p>这里:end在脚本最后一行！</p>\n<p>6.%:<br>单个%不算是命令，而相当于参数，例如：</p>\n<pre><code>net use \\\\%1\\ipc$ %3 /u:&quot;%2&quot; \ncopy 11.BAT \\\\%1\\admin$\\system32 /y \ncopy 13.BAT \\\\%1\\admin$\\system32 /y \ncopy ipc2.BAT \\\\%1\\admin$\\system32 /y \ncopy NWZI.EXE \\\\%1\\admin$\\system32 /y \nattrib \\\\%1\\admin$\\system32⏺.bat -r -h -s \n</code></pre><p>以上代码是Bat.Worm.Muma病毒中的一部分，%1代表的IP，2%代表的username，3%代表password。执行形式为：脚本文件名 参数一 参数二 ……。假设这个脚本被保存为a.bat，则执行形式如下：a IP username password。这里IP、username、password是三个参数，缺一不可（因为程序不能正确运行，并不是因为少了参数语法就不对）这样在脚本执行过程中，脚本就自动用用你的三个参数依次（记住，是依次！也是一一对应的关系。）代换1%、2%和3%，这样就达到了灵活运用的目的。 </p>\n<hr>\n<h3 id=\"三、例子\"><a href=\"#三、例子\" class=\"headerlink\" title=\"三、例子\"></a>三、例子</h3><p>将所需的命令都写在一个文件中，并且修改文件的后缀名为.bat，双击执行即会弹出doc窗口执行文件中的脚本命令。</p>"},{"title":"CG手绘初学笔记（1）","date":"2016-09-20T02:28:37.000Z","_content":"\n其实从小学开始就酷爱临摹各种卡通人物，虽然不能媲美专业级别，但是自我感觉还是可以的（也不知道哪来的自信）。感觉与其把工作之余的时间浪费掉，还不如用来学点自己感兴趣的东西更实在一些，就当做是业余爱好吧，不是有这么一句话吗？——“灵魂和身体，总得有一个在路上”\n\n### 准备工作：\n\n#### 1.手绘板：\n询问了专业美术意见之后，在[Wacom官网](http://estore.wacom.com.cn/)选择了适合初学者的手绘板，型号：\n\n- **学习板One By Wacom CTL-471/K0-F**  300元左右的价位\n- **学习板One By Wacom CTL-671/K0-F**  600元左右的价位\n![](http://i.imgur.com/YtcCeL6.png)\n\n<!--more-->\n\n#### 2.绘图软件：\n作为一个初学者，一切都要以省钱为目的，所以找到了这个软件：[优漫](http://www.udongman.cn/index.php?m=product&c=youman)，关键就是因为它是免费的！！！\n\n官方介绍：优漫是国内唯一一款专业漫画绘制软件，拥有多种功能非凡的笔、尺子等工具，而网点纸编辑、2DLT/3DLT等特色功能更可给予用户快速流畅的创作体验。\n![](http://i.imgur.com/30T8Fjb.png)\n\n#### 3.素材网站：\n- [P站](http://www.pixiv.net/)\n\n### 结束语：\n反正人生的意义就在于瞎折腾嘛，总比混吃等死要好一些，待续......","source":"_posts/CG手绘初学笔记（1）.md","raw":"---\ntitle: CG手绘初学笔记（1）\ndate: 2016-09-20 10:28:37\ntags: 手绘\ncategories: 业余爱好\n---\n\n其实从小学开始就酷爱临摹各种卡通人物，虽然不能媲美专业级别，但是自我感觉还是可以的（也不知道哪来的自信）。感觉与其把工作之余的时间浪费掉，还不如用来学点自己感兴趣的东西更实在一些，就当做是业余爱好吧，不是有这么一句话吗？——“灵魂和身体，总得有一个在路上”\n\n### 准备工作：\n\n#### 1.手绘板：\n询问了专业美术意见之后，在[Wacom官网](http://estore.wacom.com.cn/)选择了适合初学者的手绘板，型号：\n\n- **学习板One By Wacom CTL-471/K0-F**  300元左右的价位\n- **学习板One By Wacom CTL-671/K0-F**  600元左右的价位\n![](http://i.imgur.com/YtcCeL6.png)\n\n<!--more-->\n\n#### 2.绘图软件：\n作为一个初学者，一切都要以省钱为目的，所以找到了这个软件：[优漫](http://www.udongman.cn/index.php?m=product&c=youman)，关键就是因为它是免费的！！！\n\n官方介绍：优漫是国内唯一一款专业漫画绘制软件，拥有多种功能非凡的笔、尺子等工具，而网点纸编辑、2DLT/3DLT等特色功能更可给予用户快速流畅的创作体验。\n![](http://i.imgur.com/30T8Fjb.png)\n\n#### 3.素材网站：\n- [P站](http://www.pixiv.net/)\n\n### 结束语：\n反正人生的意义就在于瞎折腾嘛，总比混吃等死要好一些，待续......","slug":"CG手绘初学笔记（1）","published":1,"updated":"2017-06-24T02:13:49.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfhe00029gfjmw4o8rjp","content":"<p>其实从小学开始就酷爱临摹各种卡通人物，虽然不能媲美专业级别，但是自我感觉还是可以的（也不知道哪来的自信）。感觉与其把工作之余的时间浪费掉，还不如用来学点自己感兴趣的东西更实在一些，就当做是业余爱好吧，不是有这么一句话吗？——“灵魂和身体，总得有一个在路上”</p>\n<h3 id=\"准备工作：\"><a href=\"#准备工作：\" class=\"headerlink\" title=\"准备工作：\"></a>准备工作：</h3><h4 id=\"1-手绘板：\"><a href=\"#1-手绘板：\" class=\"headerlink\" title=\"1.手绘板：\"></a>1.手绘板：</h4><p>询问了专业美术意见之后，在<a href=\"http://estore.wacom.com.cn/\" target=\"_blank\" rel=\"external\">Wacom官网</a>选择了适合初学者的手绘板，型号：</p>\n<ul>\n<li><strong>学习板One By Wacom CTL-471/K0-F</strong>  300元左右的价位</li>\n<li><strong>学习板One By Wacom CTL-671/K0-F</strong>  600元左右的价位<br><img src=\"http://i.imgur.com/YtcCeL6.png\" alt=\"\"></li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"2-绘图软件：\"><a href=\"#2-绘图软件：\" class=\"headerlink\" title=\"2.绘图软件：\"></a>2.绘图软件：</h4><p>作为一个初学者，一切都要以省钱为目的，所以找到了这个软件：<a href=\"http://www.udongman.cn/index.php?m=product&amp;c=youman\" target=\"_blank\" rel=\"external\">优漫</a>，关键就是因为它是免费的！！！</p>\n<p>官方介绍：优漫是国内唯一一款专业漫画绘制软件，拥有多种功能非凡的笔、尺子等工具，而网点纸编辑、2DLT/3DLT等特色功能更可给予用户快速流畅的创作体验。<br><img src=\"http://i.imgur.com/30T8Fjb.png\" alt=\"\"></p>\n<h4 id=\"3-素材网站：\"><a href=\"#3-素材网站：\" class=\"headerlink\" title=\"3.素材网站：\"></a>3.素材网站：</h4><ul>\n<li><a href=\"http://www.pixiv.net/\" target=\"_blank\" rel=\"external\">P站</a></li>\n</ul>\n<h3 id=\"结束语：\"><a href=\"#结束语：\" class=\"headerlink\" title=\"结束语：\"></a>结束语：</h3><p>反正人生的意义就在于瞎折腾嘛，总比混吃等死要好一些，待续……</p>\n","excerpt":"<p>其实从小学开始就酷爱临摹各种卡通人物，虽然不能媲美专业级别，但是自我感觉还是可以的（也不知道哪来的自信）。感觉与其把工作之余的时间浪费掉，还不如用来学点自己感兴趣的东西更实在一些，就当做是业余爱好吧，不是有这么一句话吗？——“灵魂和身体，总得有一个在路上”</p>\n<h3 id=\"准备工作：\"><a href=\"#准备工作：\" class=\"headerlink\" title=\"准备工作：\"></a>准备工作：</h3><h4 id=\"1-手绘板：\"><a href=\"#1-手绘板：\" class=\"headerlink\" title=\"1.手绘板：\"></a>1.手绘板：</h4><p>询问了专业美术意见之后，在<a href=\"http://estore.wacom.com.cn/\">Wacom官网</a>选择了适合初学者的手绘板，型号：</p>\n<ul>\n<li><strong>学习板One By Wacom CTL-471/K0-F</strong>  300元左右的价位</li>\n<li><strong>学习板One By Wacom CTL-671/K0-F</strong>  600元左右的价位<br><img src=\"http://i.imgur.com/YtcCeL6.png\" alt=\"\"></li>\n</ul>","more":"<h4 id=\"2-绘图软件：\"><a href=\"#2-绘图软件：\" class=\"headerlink\" title=\"2.绘图软件：\"></a>2.绘图软件：</h4><p>作为一个初学者，一切都要以省钱为目的，所以找到了这个软件：<a href=\"http://www.udongman.cn/index.php?m=product&amp;c=youman\">优漫</a>，关键就是因为它是免费的！！！</p>\n<p>官方介绍：优漫是国内唯一一款专业漫画绘制软件，拥有多种功能非凡的笔、尺子等工具，而网点纸编辑、2DLT/3DLT等特色功能更可给予用户快速流畅的创作体验。<br><img src=\"http://i.imgur.com/30T8Fjb.png\" alt=\"\"></p>\n<h4 id=\"3-素材网站：\"><a href=\"#3-素材网站：\" class=\"headerlink\" title=\"3.素材网站：\"></a>3.素材网站：</h4><ul>\n<li><a href=\"http://www.pixiv.net/\">P站</a></li>\n</ul>\n<h3 id=\"结束语：\"><a href=\"#结束语：\" class=\"headerlink\" title=\"结束语：\"></a>结束语：</h3><p>反正人生的意义就在于瞎折腾嘛，总比混吃等死要好一些，待续……</p>"},{"title":"CG手绘初学笔记（2）预备知识","date":"2016-09-21T03:57:05.000Z","_content":"\n学习CG对于初学者来说，并非一朝一夕就能掌握的，也需要循序渐进的过程，通过大量的了解，学习过程大致如下：\n\n### 一、线条：\n- 手绘线条：即直接在纸上练习各种基本的手绘线条，当达到一定熟练程度之后，进入下一个阶段；\n- 板绘线条：在纸上绘制线条很熟练之后，还需要在手绘板上进行练习，刚开始当然也是线条的练习；\n- 临摹：包括线条的临摹和上色的临摹；\n\n<!--more-->\n\n我参考的是You Tube（需要翻墙，Mac系统可以借助免费软件\"``蓝灯``\"）上的一个国外视频系列：\n\n- [Sketch 2 Draw](https://www.youtube.com/user/JSolorzanoArts1/videos?shelf_id=4&sort=dd&view=0)\n- [LethalChris Drawing](https://www.youtube.com/channel/UCzM8cfTU666_-aFNulLEx2Q)\n- [Emmy Kalia](https://www.youtube.com/channel/UCXyk40gJRzA9WJ27UA1xlgQ)\n\n### 二、需要掌握的内容：\n- 素描：所有单色绘画都可以归属于素描范畴；\n- 色彩：油画和水粉画都能够帮助练习色彩，但是油画从工具到绘画都比较繁杂，所以一般通过水彩画练习比较合适；\n- 板绘：手绘技巧达到一定的熟练程度之后，可以开始使用数绘板来进行绘画\n- 人体：由于在原画设计过程中，对于一些人物和怪物的设计时，需要参考人体的肌肉骨骼等结构\n\n### 三、画画起稿方式：\n- 线稿：用线条描绘出设计稿的轮廓\n- 厚图：直接用笔刷色块绘制，通过修改笔刷尺寸和颜色进行细化","source":"_posts/CG手绘初学笔记（2）.md","raw":"---\ntitle: CG手绘初学笔记（2）预备知识\ndate: 2016-09-21 11:57:05\ntags: 手绘\ncategories: 业余爱好\n---\n\n学习CG对于初学者来说，并非一朝一夕就能掌握的，也需要循序渐进的过程，通过大量的了解，学习过程大致如下：\n\n### 一、线条：\n- 手绘线条：即直接在纸上练习各种基本的手绘线条，当达到一定熟练程度之后，进入下一个阶段；\n- 板绘线条：在纸上绘制线条很熟练之后，还需要在手绘板上进行练习，刚开始当然也是线条的练习；\n- 临摹：包括线条的临摹和上色的临摹；\n\n<!--more-->\n\n我参考的是You Tube（需要翻墙，Mac系统可以借助免费软件\"``蓝灯``\"）上的一个国外视频系列：\n\n- [Sketch 2 Draw](https://www.youtube.com/user/JSolorzanoArts1/videos?shelf_id=4&sort=dd&view=0)\n- [LethalChris Drawing](https://www.youtube.com/channel/UCzM8cfTU666_-aFNulLEx2Q)\n- [Emmy Kalia](https://www.youtube.com/channel/UCXyk40gJRzA9WJ27UA1xlgQ)\n\n### 二、需要掌握的内容：\n- 素描：所有单色绘画都可以归属于素描范畴；\n- 色彩：油画和水粉画都能够帮助练习色彩，但是油画从工具到绘画都比较繁杂，所以一般通过水彩画练习比较合适；\n- 板绘：手绘技巧达到一定的熟练程度之后，可以开始使用数绘板来进行绘画\n- 人体：由于在原画设计过程中，对于一些人物和怪物的设计时，需要参考人体的肌肉骨骼等结构\n\n### 三、画画起稿方式：\n- 线稿：用线条描绘出设计稿的轮廓\n- 厚图：直接用笔刷色块绘制，通过修改笔刷尺寸和颜色进行细化","slug":"CG手绘初学笔记（2）","published":1,"updated":"2017-06-24T02:13:49.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfi400059gfj0iwxh7o1","content":"<p>学习CG对于初学者来说，并非一朝一夕就能掌握的，也需要循序渐进的过程，通过大量的了解，学习过程大致如下：</p>\n<h3 id=\"一、线条：\"><a href=\"#一、线条：\" class=\"headerlink\" title=\"一、线条：\"></a>一、线条：</h3><ul>\n<li>手绘线条：即直接在纸上练习各种基本的手绘线条，当达到一定熟练程度之后，进入下一个阶段；</li>\n<li>板绘线条：在纸上绘制线条很熟练之后，还需要在手绘板上进行练习，刚开始当然也是线条的练习；</li>\n<li>临摹：包括线条的临摹和上色的临摹；</li>\n</ul>\n<a id=\"more\"></a>\n<p>我参考的是You Tube（需要翻墙，Mac系统可以借助免费软件”<code>蓝灯</code>“）上的一个国外视频系列：</p>\n<ul>\n<li><a href=\"https://www.youtube.com/user/JSolorzanoArts1/videos?shelf_id=4&amp;sort=dd&amp;view=0\" target=\"_blank\" rel=\"external\">Sketch 2 Draw</a></li>\n<li><a href=\"https://www.youtube.com/channel/UCzM8cfTU666_-aFNulLEx2Q\" target=\"_blank\" rel=\"external\">LethalChris Drawing</a></li>\n<li><a href=\"https://www.youtube.com/channel/UCXyk40gJRzA9WJ27UA1xlgQ\" target=\"_blank\" rel=\"external\">Emmy Kalia</a></li>\n</ul>\n<h3 id=\"二、需要掌握的内容：\"><a href=\"#二、需要掌握的内容：\" class=\"headerlink\" title=\"二、需要掌握的内容：\"></a>二、需要掌握的内容：</h3><ul>\n<li>素描：所有单色绘画都可以归属于素描范畴；</li>\n<li>色彩：油画和水粉画都能够帮助练习色彩，但是油画从工具到绘画都比较繁杂，所以一般通过水彩画练习比较合适；</li>\n<li>板绘：手绘技巧达到一定的熟练程度之后，可以开始使用数绘板来进行绘画</li>\n<li>人体：由于在原画设计过程中，对于一些人物和怪物的设计时，需要参考人体的肌肉骨骼等结构</li>\n</ul>\n<h3 id=\"三、画画起稿方式：\"><a href=\"#三、画画起稿方式：\" class=\"headerlink\" title=\"三、画画起稿方式：\"></a>三、画画起稿方式：</h3><ul>\n<li>线稿：用线条描绘出设计稿的轮廓</li>\n<li>厚图：直接用笔刷色块绘制，通过修改笔刷尺寸和颜色进行细化</li>\n</ul>\n","excerpt":"<p>学习CG对于初学者来说，并非一朝一夕就能掌握的，也需要循序渐进的过程，通过大量的了解，学习过程大致如下：</p>\n<h3 id=\"一、线条：\"><a href=\"#一、线条：\" class=\"headerlink\" title=\"一、线条：\"></a>一、线条：</h3><ul>\n<li>手绘线条：即直接在纸上练习各种基本的手绘线条，当达到一定熟练程度之后，进入下一个阶段；</li>\n<li>板绘线条：在纸上绘制线条很熟练之后，还需要在手绘板上进行练习，刚开始当然也是线条的练习；</li>\n<li>临摹：包括线条的临摹和上色的临摹；</li>\n</ul>","more":"<p>我参考的是You Tube（需要翻墙，Mac系统可以借助免费软件”<code>蓝灯</code>“）上的一个国外视频系列：</p>\n<ul>\n<li><a href=\"https://www.youtube.com/user/JSolorzanoArts1/videos?shelf_id=4&amp;sort=dd&amp;view=0\">Sketch 2 Draw</a></li>\n<li><a href=\"https://www.youtube.com/channel/UCzM8cfTU666_-aFNulLEx2Q\">LethalChris Drawing</a></li>\n<li><a href=\"https://www.youtube.com/channel/UCXyk40gJRzA9WJ27UA1xlgQ\">Emmy Kalia</a></li>\n</ul>\n<h3 id=\"二、需要掌握的内容：\"><a href=\"#二、需要掌握的内容：\" class=\"headerlink\" title=\"二、需要掌握的内容：\"></a>二、需要掌握的内容：</h3><ul>\n<li>素描：所有单色绘画都可以归属于素描范畴；</li>\n<li>色彩：油画和水粉画都能够帮助练习色彩，但是油画从工具到绘画都比较繁杂，所以一般通过水彩画练习比较合适；</li>\n<li>板绘：手绘技巧达到一定的熟练程度之后，可以开始使用数绘板来进行绘画</li>\n<li>人体：由于在原画设计过程中，对于一些人物和怪物的设计时，需要参考人体的肌肉骨骼等结构</li>\n</ul>\n<h3 id=\"三、画画起稿方式：\"><a href=\"#三、画画起稿方式：\" class=\"headerlink\" title=\"三、画画起稿方式：\"></a>三、画画起稿方式：</h3><ul>\n<li>线稿：用线条描绘出设计稿的轮廓</li>\n<li>厚图：直接用笔刷色块绘制，通过修改笔刷尺寸和颜色进行细化</li>\n</ul>"},{"title":"CG手绘初学笔记（3）从线稿到上色","date":"2016-11-15T06:38:29.000Z","_content":"\n虽然学习画画没有捷径，但我们也应该避免走弯路，使用比较科学的绘画思路往往能使得绘画这件事情更加直观。\n\n<!--more-->\n\n### 线稿\n通常有两种方式来获取线稿：\n\n- 在纸上用铅笔完成线稿，然后通过扫描输入到绘画软件中；\n- 直接使用绘画板（手绘板）在软件上进行线稿绘制。\n\n通过扫描铅笔线稿获取线稿时，需要对文件进行一些处理，从而提取出优质的线稿，以便于后面的上色工作，这里以Photoshop为例，提取线稿快捷键组合：\nCtrl+A -> Ctrl+C -> Ctrl+V -> Q -> Ctrl+Shift+I -> Ctrl+C -> Ctrl+V(此步骤重复2到3次)\n\n### 上色\n上色的技法关键在于光影和素描关系的把握，而非色彩多么的丰富\n\n#### 光影：\n光影的产生：当光线落在物体性状上，从而按照逻辑关系创造出来光和影，也就是物体的**``黑白灰``**。主要分析两点：**光与影的分布**和**光与影的形状**。\n\n色彩：\n反光的补色（灰蓝色）——明暗交界线的固有色（暖红灰色）——亮部的浅灰色（浅灰红）\n一般暗部的纯度都比亮部的纯度要高\n\n#### Photoshop底色法：\n在一个底色的基础上逐步绘制出人物的造型，底色起到规范色调的作用。","source":"_posts/CG手绘初学笔记（3）从线稿到上色.md","raw":"---\ntitle: CG手绘初学笔记（3）从线稿到上色\ndate: 2016-11-15 14:38:29\ntags: 手绘\ncategories: 业余爱好\n---\n\n虽然学习画画没有捷径，但我们也应该避免走弯路，使用比较科学的绘画思路往往能使得绘画这件事情更加直观。\n\n<!--more-->\n\n### 线稿\n通常有两种方式来获取线稿：\n\n- 在纸上用铅笔完成线稿，然后通过扫描输入到绘画软件中；\n- 直接使用绘画板（手绘板）在软件上进行线稿绘制。\n\n通过扫描铅笔线稿获取线稿时，需要对文件进行一些处理，从而提取出优质的线稿，以便于后面的上色工作，这里以Photoshop为例，提取线稿快捷键组合：\nCtrl+A -> Ctrl+C -> Ctrl+V -> Q -> Ctrl+Shift+I -> Ctrl+C -> Ctrl+V(此步骤重复2到3次)\n\n### 上色\n上色的技法关键在于光影和素描关系的把握，而非色彩多么的丰富\n\n#### 光影：\n光影的产生：当光线落在物体性状上，从而按照逻辑关系创造出来光和影，也就是物体的**``黑白灰``**。主要分析两点：**光与影的分布**和**光与影的形状**。\n\n色彩：\n反光的补色（灰蓝色）——明暗交界线的固有色（暖红灰色）——亮部的浅灰色（浅灰红）\n一般暗部的纯度都比亮部的纯度要高\n\n#### Photoshop底色法：\n在一个底色的基础上逐步绘制出人物的造型，底色起到规范色调的作用。","slug":"CG手绘初学笔记（3）从线稿到上色","published":1,"updated":"2017-06-24T02:13:49.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfiz00089gfj3msl2hql","content":"<p>虽然学习画画没有捷径，但我们也应该避免走弯路，使用比较科学的绘画思路往往能使得绘画这件事情更加直观。</p>\n<a id=\"more\"></a>\n<h3 id=\"线稿\"><a href=\"#线稿\" class=\"headerlink\" title=\"线稿\"></a>线稿</h3><p>通常有两种方式来获取线稿：</p>\n<ul>\n<li>在纸上用铅笔完成线稿，然后通过扫描输入到绘画软件中；</li>\n<li>直接使用绘画板（手绘板）在软件上进行线稿绘制。</li>\n</ul>\n<p>通过扫描铅笔线稿获取线稿时，需要对文件进行一些处理，从而提取出优质的线稿，以便于后面的上色工作，这里以Photoshop为例，提取线稿快捷键组合：<br>Ctrl+A -&gt; Ctrl+C -&gt; Ctrl+V -&gt; Q -&gt; Ctrl+Shift+I -&gt; Ctrl+C -&gt; Ctrl+V(此步骤重复2到3次)</p>\n<h3 id=\"上色\"><a href=\"#上色\" class=\"headerlink\" title=\"上色\"></a>上色</h3><p>上色的技法关键在于光影和素描关系的把握，而非色彩多么的丰富</p>\n<h4 id=\"光影：\"><a href=\"#光影：\" class=\"headerlink\" title=\"光影：\"></a>光影：</h4><p>光影的产生：当光线落在物体性状上，从而按照逻辑关系创造出来光和影，也就是物体的<strong><code>黑白灰</code></strong>。主要分析两点：<strong>光与影的分布</strong>和<strong>光与影的形状</strong>。</p>\n<p>色彩：<br>反光的补色（灰蓝色）——明暗交界线的固有色（暖红灰色）——亮部的浅灰色（浅灰红）<br>一般暗部的纯度都比亮部的纯度要高</p>\n<h4 id=\"Photoshop底色法：\"><a href=\"#Photoshop底色法：\" class=\"headerlink\" title=\"Photoshop底色法：\"></a>Photoshop底色法：</h4><p>在一个底色的基础上逐步绘制出人物的造型，底色起到规范色调的作用。</p>\n","excerpt":"<p>虽然学习画画没有捷径，但我们也应该避免走弯路，使用比较科学的绘画思路往往能使得绘画这件事情更加直观。</p>","more":"<h3 id=\"线稿\"><a href=\"#线稿\" class=\"headerlink\" title=\"线稿\"></a>线稿</h3><p>通常有两种方式来获取线稿：</p>\n<ul>\n<li>在纸上用铅笔完成线稿，然后通过扫描输入到绘画软件中；</li>\n<li>直接使用绘画板（手绘板）在软件上进行线稿绘制。</li>\n</ul>\n<p>通过扫描铅笔线稿获取线稿时，需要对文件进行一些处理，从而提取出优质的线稿，以便于后面的上色工作，这里以Photoshop为例，提取线稿快捷键组合：<br>Ctrl+A -&gt; Ctrl+C -&gt; Ctrl+V -&gt; Q -&gt; Ctrl+Shift+I -&gt; Ctrl+C -&gt; Ctrl+V(此步骤重复2到3次)</p>\n<h3 id=\"上色\"><a href=\"#上色\" class=\"headerlink\" title=\"上色\"></a>上色</h3><p>上色的技法关键在于光影和素描关系的把握，而非色彩多么的丰富</p>\n<h4 id=\"光影：\"><a href=\"#光影：\" class=\"headerlink\" title=\"光影：\"></a>光影：</h4><p>光影的产生：当光线落在物体性状上，从而按照逻辑关系创造出来光和影，也就是物体的<strong><code>黑白灰</code></strong>。主要分析两点：<strong>光与影的分布</strong>和<strong>光与影的形状</strong>。</p>\n<p>色彩：<br>反光的补色（灰蓝色）——明暗交界线的固有色（暖红灰色）——亮部的浅灰色（浅灰红）<br>一般暗部的纯度都比亮部的纯度要高</p>\n<h4 id=\"Photoshop底色法：\"><a href=\"#Photoshop底色法：\" class=\"headerlink\" title=\"Photoshop底色法：\"></a>Photoshop底色法：</h4><p>在一个底色的基础上逐步绘制出人物的造型，底色起到规范色调的作用。</p>"},{"title":"Github Pages + Hexo创建个人博客","date":"2016-09-02T09:17:52.000Z","_content":"\n> 之前使用过jekyll+github做过一版自己的博客网站，有兴趣的可以看一下我之前的文章：[http://blog.csdn.net/linshuhe1/article/details/51143026](http://blog.csdn.net/linshuhe1/article/details/51143026 \"Github+Jekyll —— 创建个人免费博客（一）从零开始\")，其实也很简单，但是存在一些问题：目录、Rss、sitemap无法自动生成。\n\n---\n\n> 最近看到了别人使用hexo+github实现的博客，有更多的灵活性和简约的风格，所以也试着改一下自己原本的设计。\n\n<!--more-->\n\n\n## 什么是hexo：\n```hexo```是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管到github或者Heroku上，类似于jekyll、Octopress、Wordpress等，使用markdown来写文章。hexo的作者是[https://github.com/tommy351/hexo](https://github.com/tommy351/hexo \"@tommy351\")。具有以下几点优点：\n\n- 易用性，部署很简单，常用指令有：```hexo new```、```hexo generate```、```hexo server```、```hexo deploy```；\n- 轻量级，文件少而小，自定义方便\n\n## 相关知识：\nhexo配置过程中使用到了```Github```，```Git```，```Markdown```，```Node.js```等相关操作，所以需要很多插件、widget需要自己安装配置。\n\n## 安装准备：\n\n1. Node.js:[https://nodejs.org/en/](https://nodejs.org/en/ \"https://nodejs.org/en/\") ；\n2. Github桌面版（Windows）：[https://desktop.github.com/](https://desktop.github.com/ \"https://desktop.github.com/\")；\n\n## 安装Github桌面版和配置\n1. 双击下载好的```GitHubSetup.exe```文件，按照默认设置完成安装；\n2. 登录自己的github账号；\n\n![](http://i.imgur.com/97nOEVO.png)\n3. 在github网页上创建一个以```username.github.io```命名的repositories,此时username为自己github的账号名称；\n\n![](http://i.imgur.com/A9cQrk6.png)\n4. 打开Git Shell，使用配置SSH Key使本地git项目与远程Github建立联系：```ssh -T git@github.com```；\n\n![](http://i.imgur.com/t33BM1G.png)\n\n## 安装Node.js\n直接双击下载好的```node-v4.5.0-x64.msi```选择指定的安装路径，按照默认设置完成安装操作，安装完成后不需要对Node.js进行任何配置。为了检验是否完成安装，可以打开命令行，输入指令：```npm --version```进行版本号查询。\n![](http://i.imgur.com/H21hK8M.png)\n\n## 安装Hexo:\n### 1.安装:\n\n    mkdir hexo #创建一个项目文件\n\tcd hexo    #进入项目文件目录\n\tnpm install -g hexo-cli\n\tnpm install hexo --save\nnpm是Node.js中的一个工具，所以在安装Hexo之前应该先安装Node.js\n\n### 2.部署Hexo：\n在Git shell中输入：\n\n\thexo init\n记得输入之前需要确保当前命令行所处目录为所要创建工程的根目录下，因为此操作的结果就是将hexo的一些必要文件复制到当前目录下面。\n![](http://i.imgur.com/8bOaggs.png)\n看到上图结果之后，可以通过以下指令运行博客：\n\n\thexo server\n![](http://i.imgur.com/OyexMqN.png)\n运行正常的话可以通过访问：[http://localhost:4000/](http://localhost:4000/ \"http://localhost:4000/\")查看运行结果：\n\n![](http://i.imgur.com/Xy731Ig.png)\n\n假如出现了hexo服务启动成功，但是浏览器访问localhost:4000一直不响应，那就有可能是因为你的设备上装了其他软件占用了4000端口，一般有两种办法可以解决：\n\n- 在服务管理中将占用该端口的服务停止掉，通常安装了福昕阅读器的就会占用4000，把其对应的后台服务关掉即可；\n- 切换hexo启动的默认端口，使用以下指令：\n\n\thexo s -p 5000\n\n此时启动端口就变成了5000，访问地址变成了localhost:5000。\n\n### 3.安装Hexo插件：\n主要目的是为了让其自动生成sitemap，Rss，部署到git等，这些是额外的插件，假如不需要使用到这些功能可以不添加：\n\n\tnpm install hexo-generator-index --save\n\tnpm install hexo-generator-archive --save\n\tnpm install hexo-generator-category --save\n\tnpm install hexo-generator-tag --save\n\tnpm install hexo-server --save\n\tnpm install hexo-deployer-git --save\n\tnpm install hexo-deployer-heroku --save\n\tnpm install hexo-deployer-rsync --save\n\tnpm install hexo-deployer-openshift --save\n\tnpm install hexo-renderer-marked@0.2 --save\n\tnpm install hexo-renderer-stylus@0.2 --save\n\tnpm install hexo-generator-feed@1 --save\n\tnpm install hexo-generator-sitemap@1 --save\n\n## 将当前工程上传到github\n### 1.修改配置文件：\n在当前项目的根目录下找到```_config.yml```配置文件，用编辑器打开，并找到Deployment标签处deploy节点，填写以下配置信息，```type```是指定拖过平台类型，```repository```指定了github上创建的repository仓库地址，```branch```指定了版本类型。（注：冒号后面需要加一个空格，否则会出现报错）\n\n\t# Deployment\n\t## Docs: https://hexo.io/docs/deployment.html\n\tdeploy:\n\t  type: github\n\t  repository: https://github.com/linshuhe1/linshuhe1.github.io.git\n\t  branch: master\n### 2.将项目deploy到github仓库：\n打开Git shell进入当前项目的根目录，依次执行指令：\n\t\n\thexo clean\n\thexo generate\n\thexo deploy\n一般执行最后一步的时候会出现错误如下：\n![](http://i.imgur.com/68SebBI.png)\n解决错误的方法是：将deploy的type改成git，然后在Git shell中执行：\n\n\tnpm install hexo-deployer-git --save\n执行结束后再次执行上述三个指令，正确结果应该如下：\n![](http://i.imgur.com/G0wPCXU.png)\n如此我们便完成了将本地的hexo工程deploy到github上的操作，访问地址：https://username.github.io/可以看到页面效果,这里以我的github为例：[https://linshuhe1.github.io/](https://linshuhe1.github.io/ \"https://linshuhe1.github.io/\")。\n\n\n## Hexo常用指令使用：\n### 创建新博文：\n在Git shell中使用以下指令：\n\n\thexo new \"postName\"\n生成指定名称postName的文章到hexo\\source_posts\\postName.md，当然也可以直接到hexo\\source_posts目录下，手动创建一个文件，命名时注意后缀名必须是“.md”即可。\n![](http://i.imgur.com/qjVQtnG.png)\n可以打开查看新建出来的.md文件的内容：\n\n\t---\n\ttitle: github pages + Hexo\n\tdate: 2016-09-02 17:17:52\n\ttags:\n\t---\n```title```是博文的标题，```date```是博文的日期，```tags```是分类标签。\n\n更详细的内容可以参考：[https://hexo.io/docs/writing.html](https://hexo.io/docs/writing.html \"Writing\")\n\n### 新建页面：\n上面的步骤其实就是新建一篇博文的步骤，他们最后都是通过一个文章页面来显示的单个子页，但是我们的博客页面出来需要有博文显示页面之后，还需要有其他的页面，每个页面相当于一个分类对应顶栏菜单中的一个页签，如下图首页、下载等都是一个页面，所以可以理解为页面就相当于子页的父节点：\n![](http://i.imgur.com/V33kn9P.png)\n创建一个页签的操作是在Git shell中输入指令：\n\n\thexo new page \"页签名称\"\n上述步骤操作结果是在hexo\\source目录下多出一个文件夹，而且里面还有一个index.md，这就表明了我们新建了一个页签。\n\n### 运行博客：\n使用Git shell在当前项目的根目录下执行以下指令：\n\t\n\thexo server\n更详细的内容可以参考：[http://hexo.io/docs/server.html](http://hexo.io/docs/server.html \"Server\")\n\n### 生成静态站点文件：\n\n\thexo generate\n更详细的内容可以参考：[http://hexo.io/docs/generating.html](http://hexo.io/docs/generating.html \"Generating\")\n\n## 发表一篇新博文\n### 1.新建博文：\n使用新建博文的指令：\n\n\thexo new \"github pages + Hexo\"\n\n### 2.编辑博文内容：\n打开步骤1创建得到的.md文件，使用的语法是markdown，假设内容如下：\n\n\t---\n\ttitle: github pages + Hexo\n\tdate: 2016-09-02 17:17:52\n\ttags: 测试\n\t---\n\t\n\t>测试博客\n\n### 3.发表博文：\n之前的内容中已经提到了将本地内容更新到github需要三个步骤：\n\t\n\thexo clean\n\thexo generate\n\thexo deploy\n其实还有快捷的指令输入方式，如下：\n\n\thexo g == hexo generate\n\thexo d == hexo deploy\n\thexo s == hexo server\n\thexo n == hexo new\n\t# 还能组合使用，如：\n\thexo d -g\n完成上述三个步骤，一篇新的博文就发表到github上面了。\n\n## 使用Next主题美化界面：\n安装好hexo之后，主题使用的是hexo默认自带的```landscape```主题，Next主题是iissnan设计的，使用指南其实可以直接参考Next官方网：[http://theme-next.iissnan.com/](http://theme-next.iissnan.com/ \"Next\")\n\n### 1.Next主题下载：\n打开Git shell，在当前项目根目下使用git从github上checkout主题的代码，输入指令：\n\n\tgit clone https://github.com/iissnan/hexo-theme-next themes/next\n![](http://i.imgur.com/bGoWtvn.png)\t\n下载完成后，在hexo\\theme目录下回多出一个next文件夹，里面就是next主题所需的文件,当然我们也可以看到在theme文件目录还有一个landscape文件夹，这也就是hexo默认的主题。\n![](http://i.imgur.com/rqq71ts.png)\n\n### 2.配置主题：\n之前我们配置hexo的时候，有用到```_config.yml```文件，称其为**站点配置文件**，而我们打开next主题文件夹，发现里面也有一个```_config.yml```文件，我们称这个为**主题配置文件**。在hexo中启用next主题的方式：就是打开站点配置文件，找到```theme```字段，将其值改为“next”，如下：\n\n\t# Extensions\n\t## Plugins: https://hexo.io/plugins/\n\t## Themes: https://hexo.io/themes/\n\ttheme: next\n配置完成后，在Git shell中使用```hexo server```指令启动本地博客，在浏览器中访问[http://localhost:4000](http://localhost:4000)可以看到如下结果：\n![](http://i.imgur.com/ZKzamkL.png)\n\n### 3.next的样式选择：\nnext的样式其实有三种：Muse、Mist和Pisces，步骤2中看到的其实是next默认的模式Muse，根据官方说明三个样式的特点如下：\n\n- **Muse：** 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白\n- **Mist：** Muse 的紧凑版本，整洁有序的单栏外观\n- **Pisces：** 双栏 Scheme，小家碧玉似的清新\n\n\n切换的控制其实很简单，使用next主题配置文件中的```scheme```字段来控制，假设我们选择Mist样式（个人认为最好看的样式），操作步骤是：打开next文件夹中的```_config.yml```文件，找到```scheme```字段，将其设置为“Mist”，如下所示：\n\n\t# ------------------------------------------------------\n\t# Scheme Settings\n\t# ------------------------------------------------------\n\t\n\t# Schemes\n\t#scheme: Muse\n\tscheme: Mist\n\t#scheme: Pisces\n重新启动博客，刷新浏览器可以看到：\n![](http://i.imgur.com/6YFzhyz.png)\n\n## 额外的优化：\n### 1.设置favicon：\nfavicon的全称Favorites Icon，即地址栏左侧的图标：\n\n![](http://i.imgur.com/ZNLKFAE.png)\n\n有个在线工具可以上传自己的图片去生成指定规格的favicon.ico文件：[http://www.atool.org/ico.php](http://www.atool.org/ico.php)。打开主题配置文件```_config.yml```可以看到favicon的配置信息：\n\n\t# Put your favicon.ico into `hexo-site/source/` directory.\n\tfavicon: /favicon.ico\n根据说明，我们将图标取名为```favicon.ico```然后放到当前工程的hexo\\source目录下，重启博客即可生效。\n\n### 2.菜单栏控制：\n我们看到页面顶部的菜单栏，其实是由主题配置文件中的```menu```字段控制的，例如原本的样子是这样：\n![](http://i.imgur.com/iyg45Yj.png)\n\n我们修改一下主题配置文件，如下把about页面前面的注释去掉，即让此页签处于显示状态：\n\n\t# ------------------------------------------------------\n\t# Menu Settings\n\t# ------------------------------------------------------\n\t\n\t# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -> archives)\n\tmenu:\n\t  home: /\n\t  #categories: /categories\n\t  about: /about\n\t  archives: /archives\n\t  tags: /tags\n\t  #commonweal: /404.html\n重启博客可以看到效果如下：\n![](http://i.imgur.com/O6Z9NvT.png)\n\n然而，点击打开About却出现了“Cannot GET /about/”的页面错误，这是因为我们还没有about这个页面，需要使用```hexo new page \"页面名称\"```进行创建：\n\n\thexo new page about\n执行结果就是在hexo\\source目录下面多出了一个about文件夹，里面有index.md，这就是点击About会展示的内容页面。同理，也可以创建tags页面。\n\n### 3.语言设置：\n在站点配置文件中假如如下内容，明确指定使用的语言，例如中文：\n\n\tlanguage: zh-Hans\n设置完毕后，发现菜单栏也发生了变化：\n![](http://i.imgur.com/Ekxi8Tv.png)\n\n### 4.侧栏设置：\n在主题配置文件的```sidebar```字段，此处我直接设置为侧栏一直显示，而且显示在右边：\n\n\tsidebar:\n\t  # Sidebar Position, available value: left | right\n\t  position: left\n\t  #position: right\n\t\n\t  # Sidebar Display, available value:\n\t  #  - post    expand on posts automatically. Default.\n\t  #  - always  expand for all pages automatically\n\t  #  - hide    expand only when click on the sidebar toggle icon.\n\t  #  - remove  Totally remove sidebar including sidebar toggler.\n\t  #display: post\n\t  display: always\n\t  #display: hide\n\t  #display: remove\n\n### 5.设置头像和作者名称：\n在站点配置文件中，新加一个字段```avatar```，值就是头像的连接地址，这里我使用站内地址，将avatar.png放到本地目录hexo\\source\\images中；作者名称直接设置站点配置文件中```author```字段的值：\n\n\t# Site\n\ttitle: Linsh-何乐不为~\n\tsubtitle:\n\tdescription:\n\tauthor: Linshuhe\n\tavatar: /images/avatar.png\n\tlanguage: zh-Hans\n\ttimezone:\n\n## 第三方服务：\n\n### 1.多说评论：\n进入多说官网，登录后点击“我要登录”，填写相关信息，注意要记住```多说域名```这个字段填写的内容，```http://(duoshuo_shortname).duoshuo.com```，这个duoshuo_shortname将用于我们站点配置文件中的配置。步骤：在站点配置文件中新建一个```duoshuo_shortname```的字段，填写注册使用的duoshuo_shortname，例如：\n\n\tduoshuo_shortname: linshuhe1\n\n### 2.百度统计：\n用于统计阅读的次数，步骤如下：\n\n- 登录百度统计官网：[http://tongji.baidu.com/web/welcome/login](http://tongji.baidu.com/web/welcome/login \"百度统计\")定位到站点的代码获取页面；\n- 复制```hm.js?```后面的那串id；\n- 在站点配置文件中，新增一个字段```baidu_analytics```，设置其值为上面复制的百度统计的id\n- 阅读次数统计，使用LeanCloud来实现，详情查看：[https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud](https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud)\n\n### 3.Swiftype搜索\n使用 Swiftype 之前需要前往 Swiftype 配置一个搜索引擎。 而后编辑 站点配置文件， 新增 swiftype_key 字段，值为你的 swiftype 搜索引擎的 key。 详细的配置请参考： [http://theme-next.iissnan.com/third-party-services.html#swfitype](http://theme-next.iissnan.com/third-party-services.html#swfitype \"Swiftype\")\n\n**Local Search:**添加百度/谷歌/本地 自定义站点内容搜索：\n\n- 安装hexo-generator-search:\n- \n\tnpm install hexo-generator-search --save\n- 在站点配置文件中加入：\n- \n\tsearch:\n\t\tpath: search.xml\n\t\tfield: post\n\n>最终结果可以查看我的博客：[https://linshuhe1.github.io/](https://linshuhe1.github.io/)\n\n\n### 补充：\n可能有人跟我一样遇到了带你麻烦，那就是主页面的文章列表中，博客内容全部显示出来而不是只显示文章一部分和 ```阅读全文》``` 按钮，这样显得首页的列表很杂乱和冗长，其实要解决这个问题很简单，只需要在我们编写markdown内容的时候，在适当的位置假如如下标签：\n\n\t<!--more-->\n那么在首页显示的部分就是此标签前面的文章内容，而非全文显示：\n![](http://i.imgur.com/PIN0F0K.png)\n","source":"_posts/Github-Pages+Hexo创建个人博客.md","raw":"---\ntitle: Github Pages + Hexo创建个人博客\ndate: 2016-09-02 17:17:52\ntags: Hexo\ncategories: Hexo\n---\n\n> 之前使用过jekyll+github做过一版自己的博客网站，有兴趣的可以看一下我之前的文章：[http://blog.csdn.net/linshuhe1/article/details/51143026](http://blog.csdn.net/linshuhe1/article/details/51143026 \"Github+Jekyll —— 创建个人免费博客（一）从零开始\")，其实也很简单，但是存在一些问题：目录、Rss、sitemap无法自动生成。\n\n---\n\n> 最近看到了别人使用hexo+github实现的博客，有更多的灵活性和简约的风格，所以也试着改一下自己原本的设计。\n\n<!--more-->\n\n\n## 什么是hexo：\n```hexo```是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管到github或者Heroku上，类似于jekyll、Octopress、Wordpress等，使用markdown来写文章。hexo的作者是[https://github.com/tommy351/hexo](https://github.com/tommy351/hexo \"@tommy351\")。具有以下几点优点：\n\n- 易用性，部署很简单，常用指令有：```hexo new```、```hexo generate```、```hexo server```、```hexo deploy```；\n- 轻量级，文件少而小，自定义方便\n\n## 相关知识：\nhexo配置过程中使用到了```Github```，```Git```，```Markdown```，```Node.js```等相关操作，所以需要很多插件、widget需要自己安装配置。\n\n## 安装准备：\n\n1. Node.js:[https://nodejs.org/en/](https://nodejs.org/en/ \"https://nodejs.org/en/\") ；\n2. Github桌面版（Windows）：[https://desktop.github.com/](https://desktop.github.com/ \"https://desktop.github.com/\")；\n\n## 安装Github桌面版和配置\n1. 双击下载好的```GitHubSetup.exe```文件，按照默认设置完成安装；\n2. 登录自己的github账号；\n\n![](http://i.imgur.com/97nOEVO.png)\n3. 在github网页上创建一个以```username.github.io```命名的repositories,此时username为自己github的账号名称；\n\n![](http://i.imgur.com/A9cQrk6.png)\n4. 打开Git Shell，使用配置SSH Key使本地git项目与远程Github建立联系：```ssh -T git@github.com```；\n\n![](http://i.imgur.com/t33BM1G.png)\n\n## 安装Node.js\n直接双击下载好的```node-v4.5.0-x64.msi```选择指定的安装路径，按照默认设置完成安装操作，安装完成后不需要对Node.js进行任何配置。为了检验是否完成安装，可以打开命令行，输入指令：```npm --version```进行版本号查询。\n![](http://i.imgur.com/H21hK8M.png)\n\n## 安装Hexo:\n### 1.安装:\n\n    mkdir hexo #创建一个项目文件\n\tcd hexo    #进入项目文件目录\n\tnpm install -g hexo-cli\n\tnpm install hexo --save\nnpm是Node.js中的一个工具，所以在安装Hexo之前应该先安装Node.js\n\n### 2.部署Hexo：\n在Git shell中输入：\n\n\thexo init\n记得输入之前需要确保当前命令行所处目录为所要创建工程的根目录下，因为此操作的结果就是将hexo的一些必要文件复制到当前目录下面。\n![](http://i.imgur.com/8bOaggs.png)\n看到上图结果之后，可以通过以下指令运行博客：\n\n\thexo server\n![](http://i.imgur.com/OyexMqN.png)\n运行正常的话可以通过访问：[http://localhost:4000/](http://localhost:4000/ \"http://localhost:4000/\")查看运行结果：\n\n![](http://i.imgur.com/Xy731Ig.png)\n\n假如出现了hexo服务启动成功，但是浏览器访问localhost:4000一直不响应，那就有可能是因为你的设备上装了其他软件占用了4000端口，一般有两种办法可以解决：\n\n- 在服务管理中将占用该端口的服务停止掉，通常安装了福昕阅读器的就会占用4000，把其对应的后台服务关掉即可；\n- 切换hexo启动的默认端口，使用以下指令：\n\n\thexo s -p 5000\n\n此时启动端口就变成了5000，访问地址变成了localhost:5000。\n\n### 3.安装Hexo插件：\n主要目的是为了让其自动生成sitemap，Rss，部署到git等，这些是额外的插件，假如不需要使用到这些功能可以不添加：\n\n\tnpm install hexo-generator-index --save\n\tnpm install hexo-generator-archive --save\n\tnpm install hexo-generator-category --save\n\tnpm install hexo-generator-tag --save\n\tnpm install hexo-server --save\n\tnpm install hexo-deployer-git --save\n\tnpm install hexo-deployer-heroku --save\n\tnpm install hexo-deployer-rsync --save\n\tnpm install hexo-deployer-openshift --save\n\tnpm install hexo-renderer-marked@0.2 --save\n\tnpm install hexo-renderer-stylus@0.2 --save\n\tnpm install hexo-generator-feed@1 --save\n\tnpm install hexo-generator-sitemap@1 --save\n\n## 将当前工程上传到github\n### 1.修改配置文件：\n在当前项目的根目录下找到```_config.yml```配置文件，用编辑器打开，并找到Deployment标签处deploy节点，填写以下配置信息，```type```是指定拖过平台类型，```repository```指定了github上创建的repository仓库地址，```branch```指定了版本类型。（注：冒号后面需要加一个空格，否则会出现报错）\n\n\t# Deployment\n\t## Docs: https://hexo.io/docs/deployment.html\n\tdeploy:\n\t  type: github\n\t  repository: https://github.com/linshuhe1/linshuhe1.github.io.git\n\t  branch: master\n### 2.将项目deploy到github仓库：\n打开Git shell进入当前项目的根目录，依次执行指令：\n\t\n\thexo clean\n\thexo generate\n\thexo deploy\n一般执行最后一步的时候会出现错误如下：\n![](http://i.imgur.com/68SebBI.png)\n解决错误的方法是：将deploy的type改成git，然后在Git shell中执行：\n\n\tnpm install hexo-deployer-git --save\n执行结束后再次执行上述三个指令，正确结果应该如下：\n![](http://i.imgur.com/G0wPCXU.png)\n如此我们便完成了将本地的hexo工程deploy到github上的操作，访问地址：https://username.github.io/可以看到页面效果,这里以我的github为例：[https://linshuhe1.github.io/](https://linshuhe1.github.io/ \"https://linshuhe1.github.io/\")。\n\n\n## Hexo常用指令使用：\n### 创建新博文：\n在Git shell中使用以下指令：\n\n\thexo new \"postName\"\n生成指定名称postName的文章到hexo\\source_posts\\postName.md，当然也可以直接到hexo\\source_posts目录下，手动创建一个文件，命名时注意后缀名必须是“.md”即可。\n![](http://i.imgur.com/qjVQtnG.png)\n可以打开查看新建出来的.md文件的内容：\n\n\t---\n\ttitle: github pages + Hexo\n\tdate: 2016-09-02 17:17:52\n\ttags:\n\t---\n```title```是博文的标题，```date```是博文的日期，```tags```是分类标签。\n\n更详细的内容可以参考：[https://hexo.io/docs/writing.html](https://hexo.io/docs/writing.html \"Writing\")\n\n### 新建页面：\n上面的步骤其实就是新建一篇博文的步骤，他们最后都是通过一个文章页面来显示的单个子页，但是我们的博客页面出来需要有博文显示页面之后，还需要有其他的页面，每个页面相当于一个分类对应顶栏菜单中的一个页签，如下图首页、下载等都是一个页面，所以可以理解为页面就相当于子页的父节点：\n![](http://i.imgur.com/V33kn9P.png)\n创建一个页签的操作是在Git shell中输入指令：\n\n\thexo new page \"页签名称\"\n上述步骤操作结果是在hexo\\source目录下多出一个文件夹，而且里面还有一个index.md，这就表明了我们新建了一个页签。\n\n### 运行博客：\n使用Git shell在当前项目的根目录下执行以下指令：\n\t\n\thexo server\n更详细的内容可以参考：[http://hexo.io/docs/server.html](http://hexo.io/docs/server.html \"Server\")\n\n### 生成静态站点文件：\n\n\thexo generate\n更详细的内容可以参考：[http://hexo.io/docs/generating.html](http://hexo.io/docs/generating.html \"Generating\")\n\n## 发表一篇新博文\n### 1.新建博文：\n使用新建博文的指令：\n\n\thexo new \"github pages + Hexo\"\n\n### 2.编辑博文内容：\n打开步骤1创建得到的.md文件，使用的语法是markdown，假设内容如下：\n\n\t---\n\ttitle: github pages + Hexo\n\tdate: 2016-09-02 17:17:52\n\ttags: 测试\n\t---\n\t\n\t>测试博客\n\n### 3.发表博文：\n之前的内容中已经提到了将本地内容更新到github需要三个步骤：\n\t\n\thexo clean\n\thexo generate\n\thexo deploy\n其实还有快捷的指令输入方式，如下：\n\n\thexo g == hexo generate\n\thexo d == hexo deploy\n\thexo s == hexo server\n\thexo n == hexo new\n\t# 还能组合使用，如：\n\thexo d -g\n完成上述三个步骤，一篇新的博文就发表到github上面了。\n\n## 使用Next主题美化界面：\n安装好hexo之后，主题使用的是hexo默认自带的```landscape```主题，Next主题是iissnan设计的，使用指南其实可以直接参考Next官方网：[http://theme-next.iissnan.com/](http://theme-next.iissnan.com/ \"Next\")\n\n### 1.Next主题下载：\n打开Git shell，在当前项目根目下使用git从github上checkout主题的代码，输入指令：\n\n\tgit clone https://github.com/iissnan/hexo-theme-next themes/next\n![](http://i.imgur.com/bGoWtvn.png)\t\n下载完成后，在hexo\\theme目录下回多出一个next文件夹，里面就是next主题所需的文件,当然我们也可以看到在theme文件目录还有一个landscape文件夹，这也就是hexo默认的主题。\n![](http://i.imgur.com/rqq71ts.png)\n\n### 2.配置主题：\n之前我们配置hexo的时候，有用到```_config.yml```文件，称其为**站点配置文件**，而我们打开next主题文件夹，发现里面也有一个```_config.yml```文件，我们称这个为**主题配置文件**。在hexo中启用next主题的方式：就是打开站点配置文件，找到```theme```字段，将其值改为“next”，如下：\n\n\t# Extensions\n\t## Plugins: https://hexo.io/plugins/\n\t## Themes: https://hexo.io/themes/\n\ttheme: next\n配置完成后，在Git shell中使用```hexo server```指令启动本地博客，在浏览器中访问[http://localhost:4000](http://localhost:4000)可以看到如下结果：\n![](http://i.imgur.com/ZKzamkL.png)\n\n### 3.next的样式选择：\nnext的样式其实有三种：Muse、Mist和Pisces，步骤2中看到的其实是next默认的模式Muse，根据官方说明三个样式的特点如下：\n\n- **Muse：** 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白\n- **Mist：** Muse 的紧凑版本，整洁有序的单栏外观\n- **Pisces：** 双栏 Scheme，小家碧玉似的清新\n\n\n切换的控制其实很简单，使用next主题配置文件中的```scheme```字段来控制，假设我们选择Mist样式（个人认为最好看的样式），操作步骤是：打开next文件夹中的```_config.yml```文件，找到```scheme```字段，将其设置为“Mist”，如下所示：\n\n\t# ------------------------------------------------------\n\t# Scheme Settings\n\t# ------------------------------------------------------\n\t\n\t# Schemes\n\t#scheme: Muse\n\tscheme: Mist\n\t#scheme: Pisces\n重新启动博客，刷新浏览器可以看到：\n![](http://i.imgur.com/6YFzhyz.png)\n\n## 额外的优化：\n### 1.设置favicon：\nfavicon的全称Favorites Icon，即地址栏左侧的图标：\n\n![](http://i.imgur.com/ZNLKFAE.png)\n\n有个在线工具可以上传自己的图片去生成指定规格的favicon.ico文件：[http://www.atool.org/ico.php](http://www.atool.org/ico.php)。打开主题配置文件```_config.yml```可以看到favicon的配置信息：\n\n\t# Put your favicon.ico into `hexo-site/source/` directory.\n\tfavicon: /favicon.ico\n根据说明，我们将图标取名为```favicon.ico```然后放到当前工程的hexo\\source目录下，重启博客即可生效。\n\n### 2.菜单栏控制：\n我们看到页面顶部的菜单栏，其实是由主题配置文件中的```menu```字段控制的，例如原本的样子是这样：\n![](http://i.imgur.com/iyg45Yj.png)\n\n我们修改一下主题配置文件，如下把about页面前面的注释去掉，即让此页签处于显示状态：\n\n\t# ------------------------------------------------------\n\t# Menu Settings\n\t# ------------------------------------------------------\n\t\n\t# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -> archives)\n\tmenu:\n\t  home: /\n\t  #categories: /categories\n\t  about: /about\n\t  archives: /archives\n\t  tags: /tags\n\t  #commonweal: /404.html\n重启博客可以看到效果如下：\n![](http://i.imgur.com/O6Z9NvT.png)\n\n然而，点击打开About却出现了“Cannot GET /about/”的页面错误，这是因为我们还没有about这个页面，需要使用```hexo new page \"页面名称\"```进行创建：\n\n\thexo new page about\n执行结果就是在hexo\\source目录下面多出了一个about文件夹，里面有index.md，这就是点击About会展示的内容页面。同理，也可以创建tags页面。\n\n### 3.语言设置：\n在站点配置文件中假如如下内容，明确指定使用的语言，例如中文：\n\n\tlanguage: zh-Hans\n设置完毕后，发现菜单栏也发生了变化：\n![](http://i.imgur.com/Ekxi8Tv.png)\n\n### 4.侧栏设置：\n在主题配置文件的```sidebar```字段，此处我直接设置为侧栏一直显示，而且显示在右边：\n\n\tsidebar:\n\t  # Sidebar Position, available value: left | right\n\t  position: left\n\t  #position: right\n\t\n\t  # Sidebar Display, available value:\n\t  #  - post    expand on posts automatically. Default.\n\t  #  - always  expand for all pages automatically\n\t  #  - hide    expand only when click on the sidebar toggle icon.\n\t  #  - remove  Totally remove sidebar including sidebar toggler.\n\t  #display: post\n\t  display: always\n\t  #display: hide\n\t  #display: remove\n\n### 5.设置头像和作者名称：\n在站点配置文件中，新加一个字段```avatar```，值就是头像的连接地址，这里我使用站内地址，将avatar.png放到本地目录hexo\\source\\images中；作者名称直接设置站点配置文件中```author```字段的值：\n\n\t# Site\n\ttitle: Linsh-何乐不为~\n\tsubtitle:\n\tdescription:\n\tauthor: Linshuhe\n\tavatar: /images/avatar.png\n\tlanguage: zh-Hans\n\ttimezone:\n\n## 第三方服务：\n\n### 1.多说评论：\n进入多说官网，登录后点击“我要登录”，填写相关信息，注意要记住```多说域名```这个字段填写的内容，```http://(duoshuo_shortname).duoshuo.com```，这个duoshuo_shortname将用于我们站点配置文件中的配置。步骤：在站点配置文件中新建一个```duoshuo_shortname```的字段，填写注册使用的duoshuo_shortname，例如：\n\n\tduoshuo_shortname: linshuhe1\n\n### 2.百度统计：\n用于统计阅读的次数，步骤如下：\n\n- 登录百度统计官网：[http://tongji.baidu.com/web/welcome/login](http://tongji.baidu.com/web/welcome/login \"百度统计\")定位到站点的代码获取页面；\n- 复制```hm.js?```后面的那串id；\n- 在站点配置文件中，新增一个字段```baidu_analytics```，设置其值为上面复制的百度统计的id\n- 阅读次数统计，使用LeanCloud来实现，详情查看：[https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud](https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud)\n\n### 3.Swiftype搜索\n使用 Swiftype 之前需要前往 Swiftype 配置一个搜索引擎。 而后编辑 站点配置文件， 新增 swiftype_key 字段，值为你的 swiftype 搜索引擎的 key。 详细的配置请参考： [http://theme-next.iissnan.com/third-party-services.html#swfitype](http://theme-next.iissnan.com/third-party-services.html#swfitype \"Swiftype\")\n\n**Local Search:**添加百度/谷歌/本地 自定义站点内容搜索：\n\n- 安装hexo-generator-search:\n- \n\tnpm install hexo-generator-search --save\n- 在站点配置文件中加入：\n- \n\tsearch:\n\t\tpath: search.xml\n\t\tfield: post\n\n>最终结果可以查看我的博客：[https://linshuhe1.github.io/](https://linshuhe1.github.io/)\n\n\n### 补充：\n可能有人跟我一样遇到了带你麻烦，那就是主页面的文章列表中，博客内容全部显示出来而不是只显示文章一部分和 ```阅读全文》``` 按钮，这样显得首页的列表很杂乱和冗长，其实要解决这个问题很简单，只需要在我们编写markdown内容的时候，在适当的位置假如如下标签：\n\n\t<!--more-->\n那么在首页显示的部分就是此标签前面的文章内容，而非全文显示：\n![](http://i.imgur.com/PIN0F0K.png)\n","slug":"Github-Pages+Hexo创建个人博客","published":1,"updated":"2017-06-24T02:13:49.435Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfjd000a9gfj4zejvdgt","content":"<blockquote>\n<p>之前使用过jekyll+github做过一版自己的博客网站，有兴趣的可以看一下我之前的文章：<a href=\"http://blog.csdn.net/linshuhe1/article/details/51143026\" title=\"Github+Jekyll —— 创建个人免费博客（一）从零开始\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/linshuhe1/article/details/51143026</a>，其实也很简单，但是存在一些问题：目录、Rss、sitemap无法自动生成。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>最近看到了别人使用hexo+github实现的博客，有更多的灵活性和简约的风格，所以也试着改一下自己原本的设计。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"什么是hexo：\"><a href=\"#什么是hexo：\" class=\"headerlink\" title=\"什么是hexo：\"></a>什么是hexo：</h2><p><code>hexo</code>是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管到github或者Heroku上，类似于jekyll、Octopress、Wordpress等，使用markdown来写文章。hexo的作者是<a href=\"https://github.com/tommy351/hexo\" title=\"@tommy351\" target=\"_blank\" rel=\"external\">https://github.com/tommy351/hexo</a>。具有以下几点优点：</p>\n<ul>\n<li>易用性，部署很简单，常用指令有：<code>hexo new</code>、<code>hexo generate</code>、<code>hexo server</code>、<code>hexo deploy</code>；</li>\n<li>轻量级，文件少而小，自定义方便</li>\n</ul>\n<h2 id=\"相关知识：\"><a href=\"#相关知识：\" class=\"headerlink\" title=\"相关知识：\"></a>相关知识：</h2><p>hexo配置过程中使用到了<code>Github</code>，<code>Git</code>，<code>Markdown</code>，<code>Node.js</code>等相关操作，所以需要很多插件、widget需要自己安装配置。</p>\n<h2 id=\"安装准备：\"><a href=\"#安装准备：\" class=\"headerlink\" title=\"安装准备：\"></a>安装准备：</h2><ol>\n<li>Node.js:<a href=\"https://nodejs.org/en/\" title=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/</a> ；</li>\n<li>Github桌面版（Windows）：<a href=\"https://desktop.github.com/\" title=\"https://desktop.github.com/\" target=\"_blank\" rel=\"external\">https://desktop.github.com/</a>；</li>\n</ol>\n<h2 id=\"安装Github桌面版和配置\"><a href=\"#安装Github桌面版和配置\" class=\"headerlink\" title=\"安装Github桌面版和配置\"></a>安装Github桌面版和配置</h2><ol>\n<li>双击下载好的<code>GitHubSetup.exe</code>文件，按照默认设置完成安装；</li>\n<li>登录自己的github账号；</li>\n</ol>\n<p><img src=\"http://i.imgur.com/97nOEVO.png\" alt=\"\"></p>\n<ol>\n<li>在github网页上创建一个以<code>username.github.io</code>命名的repositories,此时username为自己github的账号名称；</li>\n</ol>\n<p><img src=\"http://i.imgur.com/A9cQrk6.png\" alt=\"\"></p>\n<ol>\n<li>打开Git Shell，使用配置SSH Key使本地git项目与远程Github建立联系：<code>ssh -T git@github.com</code>；</li>\n</ol>\n<p><img src=\"http://i.imgur.com/t33BM1G.png\" alt=\"\"></p>\n<h2 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h2><p>直接双击下载好的<code>node-v4.5.0-x64.msi</code>选择指定的安装路径，按照默认设置完成安装操作，安装完成后不需要对Node.js进行任何配置。为了检验是否完成安装，可以打开命令行，输入指令：<code>npm --version</code>进行版本号查询。<br><img src=\"http://i.imgur.com/H21hK8M.png\" alt=\"\"></p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo:\"></a>安装Hexo:</h2><h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装:\"></a>1.安装:</h3><pre><code>mkdir hexo #创建一个项目文件\ncd hexo    #进入项目文件目录\nnpm install -g hexo-cli\nnpm install hexo --save\n</code></pre><p>npm是Node.js中的一个工具，所以在安装Hexo之前应该先安装Node.js</p>\n<h3 id=\"2-部署Hexo：\"><a href=\"#2-部署Hexo：\" class=\"headerlink\" title=\"2.部署Hexo：\"></a>2.部署Hexo：</h3><p>在Git shell中输入：</p>\n<pre><code>hexo init\n</code></pre><p>记得输入之前需要确保当前命令行所处目录为所要创建工程的根目录下，因为此操作的结果就是将hexo的一些必要文件复制到当前目录下面。<br><img src=\"http://i.imgur.com/8bOaggs.png\" alt=\"\"><br>看到上图结果之后，可以通过以下指令运行博客：</p>\n<pre><code>hexo server\n</code></pre><p><img src=\"http://i.imgur.com/OyexMqN.png\" alt=\"\"><br>运行正常的话可以通过访问：<a href=\"http://localhost:4000/\" title=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a>查看运行结果：</p>\n<p><img src=\"http://i.imgur.com/Xy731Ig.png\" alt=\"\"></p>\n<p>假如出现了hexo服务启动成功，但是浏览器访问localhost:4000一直不响应，那就有可能是因为你的设备上装了其他软件占用了4000端口，一般有两种办法可以解决：</p>\n<ul>\n<li>在服务管理中将占用该端口的服务停止掉，通常安装了福昕阅读器的就会占用4000，把其对应的后台服务关掉即可；</li>\n<li><p>切换hexo启动的默认端口，使用以下指令：</p>\n<p>  hexo s -p 5000</p>\n</li>\n</ul>\n<p>此时启动端口就变成了5000，访问地址变成了localhost:5000。</p>\n<h3 id=\"3-安装Hexo插件：\"><a href=\"#3-安装Hexo插件：\" class=\"headerlink\" title=\"3.安装Hexo插件：\"></a>3.安装Hexo插件：</h3><p>主要目的是为了让其自动生成sitemap，Rss，部署到git等，这些是额外的插件，假如不需要使用到这些功能可以不添加：</p>\n<pre><code>npm install hexo-generator-index --save\nnpm install hexo-generator-archive --save\nnpm install hexo-generator-category --save\nnpm install hexo-generator-tag --save\nnpm install hexo-server --save\nnpm install hexo-deployer-git --save\nnpm install hexo-deployer-heroku --save\nnpm install hexo-deployer-rsync --save\nnpm install hexo-deployer-openshift --save\nnpm install hexo-renderer-marked@0.2 --save\nnpm install hexo-renderer-stylus@0.2 --save\nnpm install hexo-generator-feed@1 --save\nnpm install hexo-generator-sitemap@1 --save\n</code></pre><h2 id=\"将当前工程上传到github\"><a href=\"#将当前工程上传到github\" class=\"headerlink\" title=\"将当前工程上传到github\"></a>将当前工程上传到github</h2><h3 id=\"1-修改配置文件：\"><a href=\"#1-修改配置文件：\" class=\"headerlink\" title=\"1.修改配置文件：\"></a>1.修改配置文件：</h3><p>在当前项目的根目录下找到<code>_config.yml</code>配置文件，用编辑器打开，并找到Deployment标签处deploy节点，填写以下配置信息，<code>type</code>是指定拖过平台类型，<code>repository</code>指定了github上创建的repository仓库地址，<code>branch</code>指定了版本类型。（注：冒号后面需要加一个空格，否则会出现报错）</p>\n<pre><code># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: github\n  repository: https://github.com/linshuhe1/linshuhe1.github.io.git\n  branch: master\n</code></pre><h3 id=\"2-将项目deploy到github仓库：\"><a href=\"#2-将项目deploy到github仓库：\" class=\"headerlink\" title=\"2.将项目deploy到github仓库：\"></a>2.将项目deploy到github仓库：</h3><p>打开Git shell进入当前项目的根目录，依次执行指令：</p>\n<pre><code>hexo clean\nhexo generate\nhexo deploy\n</code></pre><p>一般执行最后一步的时候会出现错误如下：<br><img src=\"http://i.imgur.com/68SebBI.png\" alt=\"\"><br>解决错误的方法是：将deploy的type改成git，然后在Git shell中执行：</p>\n<pre><code>npm install hexo-deployer-git --save\n</code></pre><p>执行结束后再次执行上述三个指令，正确结果应该如下：<br><img src=\"http://i.imgur.com/G0wPCXU.png\" alt=\"\"><br>如此我们便完成了将本地的hexo工程deploy到github上的操作，访问地址：<a href=\"https://username.github.io/可以看到页面效果,这里以我的github为例：[https://linshuhe1.github.io/](https://linshuhe1.github.io/\" target=\"_blank\" rel=\"external\">https://username.github.io/可以看到页面效果,这里以我的github为例：[https://linshuhe1.github.io/](https://linshuhe1.github.io/</a> “<a href=\"https://linshuhe1.github.io/&quot;)。\" target=\"_blank\" rel=\"external\">https://linshuhe1.github.io/&quot;)。</a></p>\n<h2 id=\"Hexo常用指令使用：\"><a href=\"#Hexo常用指令使用：\" class=\"headerlink\" title=\"Hexo常用指令使用：\"></a>Hexo常用指令使用：</h2><h3 id=\"创建新博文：\"><a href=\"#创建新博文：\" class=\"headerlink\" title=\"创建新博文：\"></a>创建新博文：</h3><p>在Git shell中使用以下指令：</p>\n<pre><code>hexo new &quot;postName&quot;\n</code></pre><p>生成指定名称postName的文章到hexo\\source_posts\\postName.md，当然也可以直接到hexo\\source_posts目录下，手动创建一个文件，命名时注意后缀名必须是“.md”即可。<br><img src=\"http://i.imgur.com/qjVQtnG.png\" alt=\"\"><br>可以打开查看新建出来的.md文件的内容：</p>\n<pre><code>---\ntitle: github pages + Hexo\ndate: 2016-09-02 17:17:52\ntags:\n---\n</code></pre><p><code>title</code>是博文的标题，<code>date</code>是博文的日期，<code>tags</code>是分类标签。</p>\n<p>更详细的内容可以参考：<a href=\"https://hexo.io/docs/writing.html\" title=\"Writing\" target=\"_blank\" rel=\"external\">https://hexo.io/docs/writing.html</a></p>\n<h3 id=\"新建页面：\"><a href=\"#新建页面：\" class=\"headerlink\" title=\"新建页面：\"></a>新建页面：</h3><p>上面的步骤其实就是新建一篇博文的步骤，他们最后都是通过一个文章页面来显示的单个子页，但是我们的博客页面出来需要有博文显示页面之后，还需要有其他的页面，每个页面相当于一个分类对应顶栏菜单中的一个页签，如下图首页、下载等都是一个页面，所以可以理解为页面就相当于子页的父节点：<br><img src=\"http://i.imgur.com/V33kn9P.png\" alt=\"\"><br>创建一个页签的操作是在Git shell中输入指令：</p>\n<pre><code>hexo new page &quot;页签名称&quot;\n</code></pre><p>上述步骤操作结果是在hexo\\source目录下多出一个文件夹，而且里面还有一个index.md，这就表明了我们新建了一个页签。</p>\n<h3 id=\"运行博客：\"><a href=\"#运行博客：\" class=\"headerlink\" title=\"运行博客：\"></a>运行博客：</h3><p>使用Git shell在当前项目的根目录下执行以下指令：</p>\n<pre><code>hexo server\n</code></pre><p>更详细的内容可以参考：<a href=\"http://hexo.io/docs/server.html\" title=\"Server\" target=\"_blank\" rel=\"external\">http://hexo.io/docs/server.html</a></p>\n<h3 id=\"生成静态站点文件：\"><a href=\"#生成静态站点文件：\" class=\"headerlink\" title=\"生成静态站点文件：\"></a>生成静态站点文件：</h3><pre><code>hexo generate\n</code></pre><p>更详细的内容可以参考：<a href=\"http://hexo.io/docs/generating.html\" title=\"Generating\" target=\"_blank\" rel=\"external\">http://hexo.io/docs/generating.html</a></p>\n<h2 id=\"发表一篇新博文\"><a href=\"#发表一篇新博文\" class=\"headerlink\" title=\"发表一篇新博文\"></a>发表一篇新博文</h2><h3 id=\"1-新建博文：\"><a href=\"#1-新建博文：\" class=\"headerlink\" title=\"1.新建博文：\"></a>1.新建博文：</h3><p>使用新建博文的指令：</p>\n<pre><code>hexo new &quot;github pages + Hexo&quot;\n</code></pre><h3 id=\"2-编辑博文内容：\"><a href=\"#2-编辑博文内容：\" class=\"headerlink\" title=\"2.编辑博文内容：\"></a>2.编辑博文内容：</h3><p>打开步骤1创建得到的.md文件，使用的语法是markdown，假设内容如下：</p>\n<pre><code>---\ntitle: github pages + Hexo\ndate: 2016-09-02 17:17:52\ntags: 测试\n---\n\n&gt;测试博客\n</code></pre><h3 id=\"3-发表博文：\"><a href=\"#3-发表博文：\" class=\"headerlink\" title=\"3.发表博文：\"></a>3.发表博文：</h3><p>之前的内容中已经提到了将本地内容更新到github需要三个步骤：</p>\n<pre><code>hexo clean\nhexo generate\nhexo deploy\n</code></pre><p>其实还有快捷的指令输入方式，如下：</p>\n<pre><code>hexo g == hexo generate\nhexo d == hexo deploy\nhexo s == hexo server\nhexo n == hexo new\n# 还能组合使用，如：\nhexo d -g\n</code></pre><p>完成上述三个步骤，一篇新的博文就发表到github上面了。</p>\n<h2 id=\"使用Next主题美化界面：\"><a href=\"#使用Next主题美化界面：\" class=\"headerlink\" title=\"使用Next主题美化界面：\"></a>使用Next主题美化界面：</h2><p>安装好hexo之后，主题使用的是hexo默认自带的<code>landscape</code>主题，Next主题是iissnan设计的，使用指南其实可以直接参考Next官方网：<a href=\"http://theme-next.iissnan.com/\" title=\"Next\" target=\"_blank\" rel=\"external\">http://theme-next.iissnan.com/</a></p>\n<h3 id=\"1-Next主题下载：\"><a href=\"#1-Next主题下载：\" class=\"headerlink\" title=\"1.Next主题下载：\"></a>1.Next主题下载：</h3><p>打开Git shell，在当前项目根目下使用git从github上checkout主题的代码，输入指令：</p>\n<pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next\n</code></pre><p><img src=\"http://i.imgur.com/bGoWtvn.png\" alt=\"\"><br>下载完成后，在hexo\\theme目录下回多出一个next文件夹，里面就是next主题所需的文件,当然我们也可以看到在theme文件目录还有一个landscape文件夹，这也就是hexo默认的主题。<br><img src=\"http://i.imgur.com/rqq71ts.png\" alt=\"\"></p>\n<h3 id=\"2-配置主题：\"><a href=\"#2-配置主题：\" class=\"headerlink\" title=\"2.配置主题：\"></a>2.配置主题：</h3><p>之前我们配置hexo的时候，有用到<code>_config.yml</code>文件，称其为<strong>站点配置文件</strong>，而我们打开next主题文件夹，发现里面也有一个<code>_config.yml</code>文件，我们称这个为<strong>主题配置文件</strong>。在hexo中启用next主题的方式：就是打开站点配置文件，找到<code>theme</code>字段，将其值改为“next”，如下：</p>\n<pre><code># Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n</code></pre><p>配置完成后，在Git shell中使用<code>hexo server</code>指令启动本地博客，在浏览器中访问<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a>可以看到如下结果：<br><img src=\"http://i.imgur.com/ZKzamkL.png\" alt=\"\"></p>\n<h3 id=\"3-next的样式选择：\"><a href=\"#3-next的样式选择：\" class=\"headerlink\" title=\"3.next的样式选择：\"></a>3.next的样式选择：</h3><p>next的样式其实有三种：Muse、Mist和Pisces，步骤2中看到的其实是next默认的模式Muse，根据官方说明三个样式的特点如下：</p>\n<ul>\n<li><strong>Muse：</strong> 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>\n<li><strong>Mist：</strong> Muse 的紧凑版本，整洁有序的单栏外观</li>\n<li><strong>Pisces：</strong> 双栏 Scheme，小家碧玉似的清新</li>\n</ul>\n<p>切换的控制其实很简单，使用next主题配置文件中的<code>scheme</code>字段来控制，假设我们选择Mist样式（个人认为最好看的样式），操作步骤是：打开next文件夹中的<code>_config.yml</code>文件，找到<code>scheme</code>字段，将其设置为“Mist”，如下所示：</p>\n<pre><code># ------------------------------------------------------\n# Scheme Settings\n# ------------------------------------------------------\n\n# Schemes\n#scheme: Muse\nscheme: Mist\n#scheme: Pisces\n</code></pre><p>重新启动博客，刷新浏览器可以看到：<br><img src=\"http://i.imgur.com/6YFzhyz.png\" alt=\"\"></p>\n<h2 id=\"额外的优化：\"><a href=\"#额外的优化：\" class=\"headerlink\" title=\"额外的优化：\"></a>额外的优化：</h2><h3 id=\"1-设置favicon：\"><a href=\"#1-设置favicon：\" class=\"headerlink\" title=\"1.设置favicon：\"></a>1.设置favicon：</h3><p>favicon的全称Favorites Icon，即地址栏左侧的图标：</p>\n<p><img src=\"http://i.imgur.com/ZNLKFAE.png\" alt=\"\"></p>\n<p>有个在线工具可以上传自己的图片去生成指定规格的favicon.ico文件：<a href=\"http://www.atool.org/ico.php\" target=\"_blank\" rel=\"external\">http://www.atool.org/ico.php</a>。打开主题配置文件<code>_config.yml</code>可以看到favicon的配置信息：</p>\n<pre><code># Put your favicon.ico into `hexo-site/source/` directory.\nfavicon: /favicon.ico\n</code></pre><p>根据说明，我们将图标取名为<code>favicon.ico</code>然后放到当前工程的hexo\\source目录下，重启博客即可生效。</p>\n<h3 id=\"2-菜单栏控制：\"><a href=\"#2-菜单栏控制：\" class=\"headerlink\" title=\"2.菜单栏控制：\"></a>2.菜单栏控制：</h3><p>我们看到页面顶部的菜单栏，其实是由主题配置文件中的<code>menu</code>字段控制的，例如原本的样子是这样：<br><img src=\"http://i.imgur.com/iyg45Yj.png\" alt=\"\"></p>\n<p>我们修改一下主题配置文件，如下把about页面前面的注释去掉，即让此页签处于显示状态：</p>\n<pre><code># ------------------------------------------------------\n# Menu Settings\n# ------------------------------------------------------\n\n# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)\nmenu:\n  home: /\n  #categories: /categories\n  about: /about\n  archives: /archives\n  tags: /tags\n  #commonweal: /404.html\n</code></pre><p>重启博客可以看到效果如下：<br><img src=\"http://i.imgur.com/O6Z9NvT.png\" alt=\"\"></p>\n<p>然而，点击打开About却出现了“Cannot GET /about/”的页面错误，这是因为我们还没有about这个页面，需要使用<code>hexo new page &quot;页面名称&quot;</code>进行创建：</p>\n<pre><code>hexo new page about\n</code></pre><p>执行结果就是在hexo\\source目录下面多出了一个about文件夹，里面有index.md，这就是点击About会展示的内容页面。同理，也可以创建tags页面。</p>\n<h3 id=\"3-语言设置：\"><a href=\"#3-语言设置：\" class=\"headerlink\" title=\"3.语言设置：\"></a>3.语言设置：</h3><p>在站点配置文件中假如如下内容，明确指定使用的语言，例如中文：</p>\n<pre><code>language: zh-Hans\n</code></pre><p>设置完毕后，发现菜单栏也发生了变化：<br><img src=\"http://i.imgur.com/Ekxi8Tv.png\" alt=\"\"></p>\n<h3 id=\"4-侧栏设置：\"><a href=\"#4-侧栏设置：\" class=\"headerlink\" title=\"4.侧栏设置：\"></a>4.侧栏设置：</h3><p>在主题配置文件的<code>sidebar</code>字段，此处我直接设置为侧栏一直显示，而且显示在右边：</p>\n<pre><code>sidebar:\n  # Sidebar Position, available value: left | right\n  position: left\n  #position: right\n\n  # Sidebar Display, available value:\n  #  - post    expand on posts automatically. Default.\n  #  - always  expand for all pages automatically\n  #  - hide    expand only when click on the sidebar toggle icon.\n  #  - remove  Totally remove sidebar including sidebar toggler.\n  #display: post\n  display: always\n  #display: hide\n  #display: remove\n</code></pre><h3 id=\"5-设置头像和作者名称：\"><a href=\"#5-设置头像和作者名称：\" class=\"headerlink\" title=\"5.设置头像和作者名称：\"></a>5.设置头像和作者名称：</h3><p>在站点配置文件中，新加一个字段<code>avatar</code>，值就是头像的连接地址，这里我使用站内地址，将avatar.png放到本地目录hexo\\source\\images中；作者名称直接设置站点配置文件中<code>author</code>字段的值：</p>\n<pre><code># Site\ntitle: Linsh-何乐不为~\nsubtitle:\ndescription:\nauthor: Linshuhe\navatar: /images/avatar.png\nlanguage: zh-Hans\ntimezone:\n</code></pre><h2 id=\"第三方服务：\"><a href=\"#第三方服务：\" class=\"headerlink\" title=\"第三方服务：\"></a>第三方服务：</h2><h3 id=\"1-多说评论：\"><a href=\"#1-多说评论：\" class=\"headerlink\" title=\"1.多说评论：\"></a>1.多说评论：</h3><p>进入多说官网，登录后点击“我要登录”，填写相关信息，注意要记住<code>多说域名</code>这个字段填写的内容，<code>http://(duoshuo_shortname).duoshuo.com</code>，这个duoshuo_shortname将用于我们站点配置文件中的配置。步骤：在站点配置文件中新建一个<code>duoshuo_shortname</code>的字段，填写注册使用的duoshuo_shortname，例如：</p>\n<pre><code>duoshuo_shortname: linshuhe1\n</code></pre><h3 id=\"2-百度统计：\"><a href=\"#2-百度统计：\" class=\"headerlink\" title=\"2.百度统计：\"></a>2.百度统计：</h3><p>用于统计阅读的次数，步骤如下：</p>\n<ul>\n<li>登录百度统计官网：<a href=\"http://tongji.baidu.com/web/welcome/login\" title=\"百度统计\" target=\"_blank\" rel=\"external\">http://tongji.baidu.com/web/welcome/login</a>定位到站点的代码获取页面；</li>\n<li>复制<code>hm.js?</code>后面的那串id；</li>\n<li>在站点配置文件中，新增一个字段<code>baidu_analytics</code>，设置其值为上面复制的百度统计的id</li>\n<li>阅读次数统计，使用LeanCloud来实现，详情查看：<a href=\"https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud\" target=\"_blank\" rel=\"external\">https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud</a></li>\n</ul>\n<h3 id=\"3-Swiftype搜索\"><a href=\"#3-Swiftype搜索\" class=\"headerlink\" title=\"3.Swiftype搜索\"></a>3.Swiftype搜索</h3><p>使用 Swiftype 之前需要前往 Swiftype 配置一个搜索引擎。 而后编辑 站点配置文件， 新增 swiftype_key 字段，值为你的 swiftype 搜索引擎的 key。 详细的配置请参考： <a href=\"http://theme-next.iissnan.com/third-party-services.html#swfitype\" title=\"Swiftype\" target=\"_blank\" rel=\"external\">http://theme-next.iissnan.com/third-party-services.html#swfitype</a></p>\n<p><strong>Local Search:</strong>添加百度/谷歌/本地 自定义站点内容搜索：</p>\n<ul>\n<li>安装hexo-generator-search:</li>\n<li>  npm install hexo-generator-search –save</li>\n<li>在站点配置文件中加入：</li>\n<li>  search:<pre><code>path: search.xml\nfield: post\n</code></pre></li>\n</ul>\n<blockquote>\n<p>最终结果可以查看我的博客：<a href=\"https://linshuhe1.github.io/\" target=\"_blank\" rel=\"external\">https://linshuhe1.github.io/</a></p>\n</blockquote>\n<h3 id=\"补充：\"><a href=\"#补充：\" class=\"headerlink\" title=\"补充：\"></a>补充：</h3><p>可能有人跟我一样遇到了带你麻烦，那就是主页面的文章列表中，博客内容全部显示出来而不是只显示文章一部分和 <code>阅读全文》</code> 按钮，这样显得首页的列表很杂乱和冗长，其实要解决这个问题很简单，只需要在我们编写markdown内容的时候，在适当的位置假如如下标签：</p>\n<pre><code>&lt;!--more--&gt;\n</code></pre><p>那么在首页显示的部分就是此标签前面的文章内容，而非全文显示：<br><img src=\"http://i.imgur.com/PIN0F0K.png\" alt=\"\"></p>\n","excerpt":"<blockquote>\n<p>之前使用过jekyll+github做过一版自己的博客网站，有兴趣的可以看一下我之前的文章：<a href=\"http://blog.csdn.net/linshuhe1/article/details/51143026\" title=\"Github+Jekyll —— 创建个人免费博客（一）从零开始\">http://blog.csdn.net/linshuhe1/article/details/51143026</a>，其实也很简单，但是存在一些问题：目录、Rss、sitemap无法自动生成。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>最近看到了别人使用hexo+github实现的博客，有更多的灵活性和简约的风格，所以也试着改一下自己原本的设计。</p>\n</blockquote>","more":"<h2 id=\"什么是hexo：\"><a href=\"#什么是hexo：\" class=\"headerlink\" title=\"什么是hexo：\"></a>什么是hexo：</h2><p><code>hexo</code>是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管到github或者Heroku上，类似于jekyll、Octopress、Wordpress等，使用markdown来写文章。hexo的作者是<a href=\"https://github.com/tommy351/hexo\" title=\"@tommy351\">https://github.com/tommy351/hexo</a>。具有以下几点优点：</p>\n<ul>\n<li>易用性，部署很简单，常用指令有：<code>hexo new</code>、<code>hexo generate</code>、<code>hexo server</code>、<code>hexo deploy</code>；</li>\n<li>轻量级，文件少而小，自定义方便</li>\n</ul>\n<h2 id=\"相关知识：\"><a href=\"#相关知识：\" class=\"headerlink\" title=\"相关知识：\"></a>相关知识：</h2><p>hexo配置过程中使用到了<code>Github</code>，<code>Git</code>，<code>Markdown</code>，<code>Node.js</code>等相关操作，所以需要很多插件、widget需要自己安装配置。</p>\n<h2 id=\"安装准备：\"><a href=\"#安装准备：\" class=\"headerlink\" title=\"安装准备：\"></a>安装准备：</h2><ol>\n<li>Node.js:<a href=\"https://nodejs.org/en/\" title=\"https://nodejs.org/en/\">https://nodejs.org/en/</a> ；</li>\n<li>Github桌面版（Windows）：<a href=\"https://desktop.github.com/\" title=\"https://desktop.github.com/\">https://desktop.github.com/</a>；</li>\n</ol>\n<h2 id=\"安装Github桌面版和配置\"><a href=\"#安装Github桌面版和配置\" class=\"headerlink\" title=\"安装Github桌面版和配置\"></a>安装Github桌面版和配置</h2><ol>\n<li>双击下载好的<code>GitHubSetup.exe</code>文件，按照默认设置完成安装；</li>\n<li>登录自己的github账号；</li>\n</ol>\n<p><img src=\"http://i.imgur.com/97nOEVO.png\" alt=\"\"></p>\n<ol>\n<li>在github网页上创建一个以<code>username.github.io</code>命名的repositories,此时username为自己github的账号名称；</li>\n</ol>\n<p><img src=\"http://i.imgur.com/A9cQrk6.png\" alt=\"\"></p>\n<ol>\n<li>打开Git Shell，使用配置SSH Key使本地git项目与远程Github建立联系：<code>ssh -T git@github.com</code>；</li>\n</ol>\n<p><img src=\"http://i.imgur.com/t33BM1G.png\" alt=\"\"></p>\n<h2 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h2><p>直接双击下载好的<code>node-v4.5.0-x64.msi</code>选择指定的安装路径，按照默认设置完成安装操作，安装完成后不需要对Node.js进行任何配置。为了检验是否完成安装，可以打开命令行，输入指令：<code>npm --version</code>进行版本号查询。<br><img src=\"http://i.imgur.com/H21hK8M.png\" alt=\"\"></p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo:\"></a>安装Hexo:</h2><h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装:\"></a>1.安装:</h3><pre><code>mkdir hexo #创建一个项目文件\ncd hexo    #进入项目文件目录\nnpm install -g hexo-cli\nnpm install hexo --save\n</code></pre><p>npm是Node.js中的一个工具，所以在安装Hexo之前应该先安装Node.js</p>\n<h3 id=\"2-部署Hexo：\"><a href=\"#2-部署Hexo：\" class=\"headerlink\" title=\"2.部署Hexo：\"></a>2.部署Hexo：</h3><p>在Git shell中输入：</p>\n<pre><code>hexo init\n</code></pre><p>记得输入之前需要确保当前命令行所处目录为所要创建工程的根目录下，因为此操作的结果就是将hexo的一些必要文件复制到当前目录下面。<br><img src=\"http://i.imgur.com/8bOaggs.png\" alt=\"\"><br>看到上图结果之后，可以通过以下指令运行博客：</p>\n<pre><code>hexo server\n</code></pre><p><img src=\"http://i.imgur.com/OyexMqN.png\" alt=\"\"><br>运行正常的话可以通过访问：<a href=\"http://localhost:4000/\" title=\"http://localhost:4000/\">http://localhost:4000/</a>查看运行结果：</p>\n<p><img src=\"http://i.imgur.com/Xy731Ig.png\" alt=\"\"></p>\n<p>假如出现了hexo服务启动成功，但是浏览器访问localhost:4000一直不响应，那就有可能是因为你的设备上装了其他软件占用了4000端口，一般有两种办法可以解决：</p>\n<ul>\n<li>在服务管理中将占用该端口的服务停止掉，通常安装了福昕阅读器的就会占用4000，把其对应的后台服务关掉即可；</li>\n<li><p>切换hexo启动的默认端口，使用以下指令：</p>\n<p>  hexo s -p 5000</p>\n</li>\n</ul>\n<p>此时启动端口就变成了5000，访问地址变成了localhost:5000。</p>\n<h3 id=\"3-安装Hexo插件：\"><a href=\"#3-安装Hexo插件：\" class=\"headerlink\" title=\"3.安装Hexo插件：\"></a>3.安装Hexo插件：</h3><p>主要目的是为了让其自动生成sitemap，Rss，部署到git等，这些是额外的插件，假如不需要使用到这些功能可以不添加：</p>\n<pre><code>npm install hexo-generator-index --save\nnpm install hexo-generator-archive --save\nnpm install hexo-generator-category --save\nnpm install hexo-generator-tag --save\nnpm install hexo-server --save\nnpm install hexo-deployer-git --save\nnpm install hexo-deployer-heroku --save\nnpm install hexo-deployer-rsync --save\nnpm install hexo-deployer-openshift --save\nnpm install hexo-renderer-marked@0.2 --save\nnpm install hexo-renderer-stylus@0.2 --save\nnpm install hexo-generator-feed@1 --save\nnpm install hexo-generator-sitemap@1 --save\n</code></pre><h2 id=\"将当前工程上传到github\"><a href=\"#将当前工程上传到github\" class=\"headerlink\" title=\"将当前工程上传到github\"></a>将当前工程上传到github</h2><h3 id=\"1-修改配置文件：\"><a href=\"#1-修改配置文件：\" class=\"headerlink\" title=\"1.修改配置文件：\"></a>1.修改配置文件：</h3><p>在当前项目的根目录下找到<code>_config.yml</code>配置文件，用编辑器打开，并找到Deployment标签处deploy节点，填写以下配置信息，<code>type</code>是指定拖过平台类型，<code>repository</code>指定了github上创建的repository仓库地址，<code>branch</code>指定了版本类型。（注：冒号后面需要加一个空格，否则会出现报错）</p>\n<pre><code># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: github\n  repository: https://github.com/linshuhe1/linshuhe1.github.io.git\n  branch: master\n</code></pre><h3 id=\"2-将项目deploy到github仓库：\"><a href=\"#2-将项目deploy到github仓库：\" class=\"headerlink\" title=\"2.将项目deploy到github仓库：\"></a>2.将项目deploy到github仓库：</h3><p>打开Git shell进入当前项目的根目录，依次执行指令：</p>\n<pre><code>hexo clean\nhexo generate\nhexo deploy\n</code></pre><p>一般执行最后一步的时候会出现错误如下：<br><img src=\"http://i.imgur.com/68SebBI.png\" alt=\"\"><br>解决错误的方法是：将deploy的type改成git，然后在Git shell中执行：</p>\n<pre><code>npm install hexo-deployer-git --save\n</code></pre><p>执行结束后再次执行上述三个指令，正确结果应该如下：<br><img src=\"http://i.imgur.com/G0wPCXU.png\" alt=\"\"><br>如此我们便完成了将本地的hexo工程deploy到github上的操作，访问地址：<a href=\"https://username.github.io/可以看到页面效果,这里以我的github为例：[https://linshuhe1.github.io/](https://linshuhe1.github.io/\">https://username.github.io/可以看到页面效果,这里以我的github为例：[https://linshuhe1.github.io/](https://linshuhe1.github.io/</a> “<a href=\"https://linshuhe1.github.io/&quot;)。\">https://linshuhe1.github.io/&quot;)。</a></p>\n<h2 id=\"Hexo常用指令使用：\"><a href=\"#Hexo常用指令使用：\" class=\"headerlink\" title=\"Hexo常用指令使用：\"></a>Hexo常用指令使用：</h2><h3 id=\"创建新博文：\"><a href=\"#创建新博文：\" class=\"headerlink\" title=\"创建新博文：\"></a>创建新博文：</h3><p>在Git shell中使用以下指令：</p>\n<pre><code>hexo new &quot;postName&quot;\n</code></pre><p>生成指定名称postName的文章到hexo\\source_posts\\postName.md，当然也可以直接到hexo\\source_posts目录下，手动创建一个文件，命名时注意后缀名必须是“.md”即可。<br><img src=\"http://i.imgur.com/qjVQtnG.png\" alt=\"\"><br>可以打开查看新建出来的.md文件的内容：</p>\n<pre><code>---\ntitle: github pages + Hexo\ndate: 2016-09-02 17:17:52\ntags:\n---\n</code></pre><p><code>title</code>是博文的标题，<code>date</code>是博文的日期，<code>tags</code>是分类标签。</p>\n<p>更详细的内容可以参考：<a href=\"https://hexo.io/docs/writing.html\" title=\"Writing\">https://hexo.io/docs/writing.html</a></p>\n<h3 id=\"新建页面：\"><a href=\"#新建页面：\" class=\"headerlink\" title=\"新建页面：\"></a>新建页面：</h3><p>上面的步骤其实就是新建一篇博文的步骤，他们最后都是通过一个文章页面来显示的单个子页，但是我们的博客页面出来需要有博文显示页面之后，还需要有其他的页面，每个页面相当于一个分类对应顶栏菜单中的一个页签，如下图首页、下载等都是一个页面，所以可以理解为页面就相当于子页的父节点：<br><img src=\"http://i.imgur.com/V33kn9P.png\" alt=\"\"><br>创建一个页签的操作是在Git shell中输入指令：</p>\n<pre><code>hexo new page &quot;页签名称&quot;\n</code></pre><p>上述步骤操作结果是在hexo\\source目录下多出一个文件夹，而且里面还有一个index.md，这就表明了我们新建了一个页签。</p>\n<h3 id=\"运行博客：\"><a href=\"#运行博客：\" class=\"headerlink\" title=\"运行博客：\"></a>运行博客：</h3><p>使用Git shell在当前项目的根目录下执行以下指令：</p>\n<pre><code>hexo server\n</code></pre><p>更详细的内容可以参考：<a href=\"http://hexo.io/docs/server.html\" title=\"Server\">http://hexo.io/docs/server.html</a></p>\n<h3 id=\"生成静态站点文件：\"><a href=\"#生成静态站点文件：\" class=\"headerlink\" title=\"生成静态站点文件：\"></a>生成静态站点文件：</h3><pre><code>hexo generate\n</code></pre><p>更详细的内容可以参考：<a href=\"http://hexo.io/docs/generating.html\" title=\"Generating\">http://hexo.io/docs/generating.html</a></p>\n<h2 id=\"发表一篇新博文\"><a href=\"#发表一篇新博文\" class=\"headerlink\" title=\"发表一篇新博文\"></a>发表一篇新博文</h2><h3 id=\"1-新建博文：\"><a href=\"#1-新建博文：\" class=\"headerlink\" title=\"1.新建博文：\"></a>1.新建博文：</h3><p>使用新建博文的指令：</p>\n<pre><code>hexo new &quot;github pages + Hexo&quot;\n</code></pre><h3 id=\"2-编辑博文内容：\"><a href=\"#2-编辑博文内容：\" class=\"headerlink\" title=\"2.编辑博文内容：\"></a>2.编辑博文内容：</h3><p>打开步骤1创建得到的.md文件，使用的语法是markdown，假设内容如下：</p>\n<pre><code>---\ntitle: github pages + Hexo\ndate: 2016-09-02 17:17:52\ntags: 测试\n---\n\n&gt;测试博客\n</code></pre><h3 id=\"3-发表博文：\"><a href=\"#3-发表博文：\" class=\"headerlink\" title=\"3.发表博文：\"></a>3.发表博文：</h3><p>之前的内容中已经提到了将本地内容更新到github需要三个步骤：</p>\n<pre><code>hexo clean\nhexo generate\nhexo deploy\n</code></pre><p>其实还有快捷的指令输入方式，如下：</p>\n<pre><code>hexo g == hexo generate\nhexo d == hexo deploy\nhexo s == hexo server\nhexo n == hexo new\n# 还能组合使用，如：\nhexo d -g\n</code></pre><p>完成上述三个步骤，一篇新的博文就发表到github上面了。</p>\n<h2 id=\"使用Next主题美化界面：\"><a href=\"#使用Next主题美化界面：\" class=\"headerlink\" title=\"使用Next主题美化界面：\"></a>使用Next主题美化界面：</h2><p>安装好hexo之后，主题使用的是hexo默认自带的<code>landscape</code>主题，Next主题是iissnan设计的，使用指南其实可以直接参考Next官方网：<a href=\"http://theme-next.iissnan.com/\" title=\"Next\">http://theme-next.iissnan.com/</a></p>\n<h3 id=\"1-Next主题下载：\"><a href=\"#1-Next主题下载：\" class=\"headerlink\" title=\"1.Next主题下载：\"></a>1.Next主题下载：</h3><p>打开Git shell，在当前项目根目下使用git从github上checkout主题的代码，输入指令：</p>\n<pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next\n</code></pre><p><img src=\"http://i.imgur.com/bGoWtvn.png\" alt=\"\"><br>下载完成后，在hexo\\theme目录下回多出一个next文件夹，里面就是next主题所需的文件,当然我们也可以看到在theme文件目录还有一个landscape文件夹，这也就是hexo默认的主题。<br><img src=\"http://i.imgur.com/rqq71ts.png\" alt=\"\"></p>\n<h3 id=\"2-配置主题：\"><a href=\"#2-配置主题：\" class=\"headerlink\" title=\"2.配置主题：\"></a>2.配置主题：</h3><p>之前我们配置hexo的时候，有用到<code>_config.yml</code>文件，称其为<strong>站点配置文件</strong>，而我们打开next主题文件夹，发现里面也有一个<code>_config.yml</code>文件，我们称这个为<strong>主题配置文件</strong>。在hexo中启用next主题的方式：就是打开站点配置文件，找到<code>theme</code>字段，将其值改为“next”，如下：</p>\n<pre><code># Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n</code></pre><p>配置完成后，在Git shell中使用<code>hexo server</code>指令启动本地博客，在浏览器中访问<a href=\"http://localhost:4000\">http://localhost:4000</a>可以看到如下结果：<br><img src=\"http://i.imgur.com/ZKzamkL.png\" alt=\"\"></p>\n<h3 id=\"3-next的样式选择：\"><a href=\"#3-next的样式选择：\" class=\"headerlink\" title=\"3.next的样式选择：\"></a>3.next的样式选择：</h3><p>next的样式其实有三种：Muse、Mist和Pisces，步骤2中看到的其实是next默认的模式Muse，根据官方说明三个样式的特点如下：</p>\n<ul>\n<li><strong>Muse：</strong> 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>\n<li><strong>Mist：</strong> Muse 的紧凑版本，整洁有序的单栏外观</li>\n<li><strong>Pisces：</strong> 双栏 Scheme，小家碧玉似的清新</li>\n</ul>\n<p>切换的控制其实很简单，使用next主题配置文件中的<code>scheme</code>字段来控制，假设我们选择Mist样式（个人认为最好看的样式），操作步骤是：打开next文件夹中的<code>_config.yml</code>文件，找到<code>scheme</code>字段，将其设置为“Mist”，如下所示：</p>\n<pre><code># ------------------------------------------------------\n# Scheme Settings\n# ------------------------------------------------------\n\n# Schemes\n#scheme: Muse\nscheme: Mist\n#scheme: Pisces\n</code></pre><p>重新启动博客，刷新浏览器可以看到：<br><img src=\"http://i.imgur.com/6YFzhyz.png\" alt=\"\"></p>\n<h2 id=\"额外的优化：\"><a href=\"#额外的优化：\" class=\"headerlink\" title=\"额外的优化：\"></a>额外的优化：</h2><h3 id=\"1-设置favicon：\"><a href=\"#1-设置favicon：\" class=\"headerlink\" title=\"1.设置favicon：\"></a>1.设置favicon：</h3><p>favicon的全称Favorites Icon，即地址栏左侧的图标：</p>\n<p><img src=\"http://i.imgur.com/ZNLKFAE.png\" alt=\"\"></p>\n<p>有个在线工具可以上传自己的图片去生成指定规格的favicon.ico文件：<a href=\"http://www.atool.org/ico.php\">http://www.atool.org/ico.php</a>。打开主题配置文件<code>_config.yml</code>可以看到favicon的配置信息：</p>\n<pre><code># Put your favicon.ico into `hexo-site/source/` directory.\nfavicon: /favicon.ico\n</code></pre><p>根据说明，我们将图标取名为<code>favicon.ico</code>然后放到当前工程的hexo\\source目录下，重启博客即可生效。</p>\n<h3 id=\"2-菜单栏控制：\"><a href=\"#2-菜单栏控制：\" class=\"headerlink\" title=\"2.菜单栏控制：\"></a>2.菜单栏控制：</h3><p>我们看到页面顶部的菜单栏，其实是由主题配置文件中的<code>menu</code>字段控制的，例如原本的样子是这样：<br><img src=\"http://i.imgur.com/iyg45Yj.png\" alt=\"\"></p>\n<p>我们修改一下主题配置文件，如下把about页面前面的注释去掉，即让此页签处于显示状态：</p>\n<pre><code># ------------------------------------------------------\n# Menu Settings\n# ------------------------------------------------------\n\n# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)\nmenu:\n  home: /\n  #categories: /categories\n  about: /about\n  archives: /archives\n  tags: /tags\n  #commonweal: /404.html\n</code></pre><p>重启博客可以看到效果如下：<br><img src=\"http://i.imgur.com/O6Z9NvT.png\" alt=\"\"></p>\n<p>然而，点击打开About却出现了“Cannot GET /about/”的页面错误，这是因为我们还没有about这个页面，需要使用<code>hexo new page &quot;页面名称&quot;</code>进行创建：</p>\n<pre><code>hexo new page about\n</code></pre><p>执行结果就是在hexo\\source目录下面多出了一个about文件夹，里面有index.md，这就是点击About会展示的内容页面。同理，也可以创建tags页面。</p>\n<h3 id=\"3-语言设置：\"><a href=\"#3-语言设置：\" class=\"headerlink\" title=\"3.语言设置：\"></a>3.语言设置：</h3><p>在站点配置文件中假如如下内容，明确指定使用的语言，例如中文：</p>\n<pre><code>language: zh-Hans\n</code></pre><p>设置完毕后，发现菜单栏也发生了变化：<br><img src=\"http://i.imgur.com/Ekxi8Tv.png\" alt=\"\"></p>\n<h3 id=\"4-侧栏设置：\"><a href=\"#4-侧栏设置：\" class=\"headerlink\" title=\"4.侧栏设置：\"></a>4.侧栏设置：</h3><p>在主题配置文件的<code>sidebar</code>字段，此处我直接设置为侧栏一直显示，而且显示在右边：</p>\n<pre><code>sidebar:\n  # Sidebar Position, available value: left | right\n  position: left\n  #position: right\n\n  # Sidebar Display, available value:\n  #  - post    expand on posts automatically. Default.\n  #  - always  expand for all pages automatically\n  #  - hide    expand only when click on the sidebar toggle icon.\n  #  - remove  Totally remove sidebar including sidebar toggler.\n  #display: post\n  display: always\n  #display: hide\n  #display: remove\n</code></pre><h3 id=\"5-设置头像和作者名称：\"><a href=\"#5-设置头像和作者名称：\" class=\"headerlink\" title=\"5.设置头像和作者名称：\"></a>5.设置头像和作者名称：</h3><p>在站点配置文件中，新加一个字段<code>avatar</code>，值就是头像的连接地址，这里我使用站内地址，将avatar.png放到本地目录hexo\\source\\images中；作者名称直接设置站点配置文件中<code>author</code>字段的值：</p>\n<pre><code># Site\ntitle: Linsh-何乐不为~\nsubtitle:\ndescription:\nauthor: Linshuhe\navatar: /images/avatar.png\nlanguage: zh-Hans\ntimezone:\n</code></pre><h2 id=\"第三方服务：\"><a href=\"#第三方服务：\" class=\"headerlink\" title=\"第三方服务：\"></a>第三方服务：</h2><h3 id=\"1-多说评论：\"><a href=\"#1-多说评论：\" class=\"headerlink\" title=\"1.多说评论：\"></a>1.多说评论：</h3><p>进入多说官网，登录后点击“我要登录”，填写相关信息，注意要记住<code>多说域名</code>这个字段填写的内容，<code>http://(duoshuo_shortname).duoshuo.com</code>，这个duoshuo_shortname将用于我们站点配置文件中的配置。步骤：在站点配置文件中新建一个<code>duoshuo_shortname</code>的字段，填写注册使用的duoshuo_shortname，例如：</p>\n<pre><code>duoshuo_shortname: linshuhe1\n</code></pre><h3 id=\"2-百度统计：\"><a href=\"#2-百度统计：\" class=\"headerlink\" title=\"2.百度统计：\"></a>2.百度统计：</h3><p>用于统计阅读的次数，步骤如下：</p>\n<ul>\n<li>登录百度统计官网：<a href=\"http://tongji.baidu.com/web/welcome/login\" title=\"百度统计\">http://tongji.baidu.com/web/welcome/login</a>定位到站点的代码获取页面；</li>\n<li>复制<code>hm.js?</code>后面的那串id；</li>\n<li>在站点配置文件中，新增一个字段<code>baidu_analytics</code>，设置其值为上面复制的百度统计的id</li>\n<li>阅读次数统计，使用LeanCloud来实现，详情查看：<a href=\"https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud\">https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud</a></li>\n</ul>\n<h3 id=\"3-Swiftype搜索\"><a href=\"#3-Swiftype搜索\" class=\"headerlink\" title=\"3.Swiftype搜索\"></a>3.Swiftype搜索</h3><p>使用 Swiftype 之前需要前往 Swiftype 配置一个搜索引擎。 而后编辑 站点配置文件， 新增 swiftype_key 字段，值为你的 swiftype 搜索引擎的 key。 详细的配置请参考： <a href=\"http://theme-next.iissnan.com/third-party-services.html#swfitype\" title=\"Swiftype\">http://theme-next.iissnan.com/third-party-services.html#swfitype</a></p>\n<p><strong>Local Search:</strong>添加百度/谷歌/本地 自定义站点内容搜索：</p>\n<ul>\n<li>安装hexo-generator-search:</li>\n<li>  npm install hexo-generator-search –save</li>\n<li>在站点配置文件中加入：</li>\n<li>  search:<pre><code>path: search.xml\nfield: post\n</code></pre></li>\n</ul>\n<blockquote>\n<p>最终结果可以查看我的博客：<a href=\"https://linshuhe1.github.io/\">https://linshuhe1.github.io/</a></p>\n</blockquote>\n<h3 id=\"补充：\"><a href=\"#补充：\" class=\"headerlink\" title=\"补充：\"></a>补充：</h3><p>可能有人跟我一样遇到了带你麻烦，那就是主页面的文章列表中，博客内容全部显示出来而不是只显示文章一部分和 <code>阅读全文》</code> 按钮，这样显得首页的列表很杂乱和冗长，其实要解决这个问题很简单，只需要在我们编写markdown内容的时候，在适当的位置假如如下标签：</p>\n<pre><code>&lt;!--more--&gt;\n</code></pre><p>那么在首页显示的部分就是此标签前面的文章内容，而非全文显示：<br><img src=\"http://i.imgur.com/PIN0F0K.png\" alt=\"\"></p>"},{"title":"Java中内嵌Lua脚本","date":"2017-04-30T13:10:37.000Z","_content":"\n``Lua``是一种小巧的脚本语言，如今常用于游戏开发，特别是客户端开发，基本上都是基于Lua来实现热更新，在Unity开发中更有``uLua``（最新版改名为``toLua``）这样成熟的热更框架。这里我设想用``Lua``+``Java``来实现服务器的热更，不成熟的想法，这里想尝试一下``Lua``和``Java``如何互相调用。\n\n<!--more-->\n\n### **插件选择：**\n假如引入第三方库，可以找到比较常用的两个选择：``LuaJava``和``LuaJ``，简单做一下对比：\n\n|第三方库|实现|特性|\n|:-----:|:-----:|:---:|\n|LuaJava|非纯Java实现，需要通过native方法调用C库，依赖于Lua 5.1|会导致JVM崩溃，不再更新，没人维护|\n|LuaJ（LuaJavaBridge）|纯Java实现的Lua解析器，无需使用native|不会因错误导致JVM crash，支持JSR-223|\n\n#### **LuaJava简介：**\nLua是支持内嵌在C程序中的，但是官方不支持Java，所以我们只能寻找第三方插件了，找到了一个``LuaJava``，这是一个开源项目，实现方式：LuaJava实际上就是按照Lua官方文档，把Lua的C接口通过``JNI``包装成Java的库。下载资源，里面是一个``.dll``和 一个``.jar``。把``.dll``放到``java.library.path``下，再把``.lib``放到``classpath``中。\n\n#### **LuaJ简介：**\n**主要特征：**\n\n- 可以从 ``Lua`` 调用 ``Java Class Static Method``（Java的静态方法）；\n- 调用 ``Java`` 方法时，支持 ``int/float/boolean/String/Lua function`` 五种参数类型；\n- 可以将 ``Lua function`` 作为参数传递给 ``Java``，并让 ``Java`` 保存 ``Lua function`` 的引用；\n- 可以从 ``Java`` 调用 ``Lua`` 的全局函数，或者调用引用指向的 ``Lua function``。\n\n#### **LuaJ核心原理：**\n``LuaJ``的核心其实就是：从``Lua``调用``Java``和从``Java``调用``Lua``。\n\n经过上述对比，最终我还是选择纯Java实现，且仍然有人维护更新的``LuaJ``解析器，而且它也支持``LuaJava API``。\n\n---\n\n### **LuaJ的下载使用：**\n#### **下载：**\n- 方式一：直接到[LuaJ官网](http://www.luaj.org/luaj/3.0/README.html)下载，选择相对较新的版本[LuaJ 3.0.1](https://nchc.dl.sourceforge.net/project/luaj/luaj-3.0/3.0.1/luaj-3.0.1.zip)，将解压后的``lib``目录下的``luaj-jse-3.0.1.jar``导入项目中使用。\n- 方式二：当然加入是使用Maven来管理项目的就不用这么麻烦了，直接在``pom.xml``中添加库依赖内容：\n\n ``` xml\n <!-- https://mvnrepository.com/artifact/org.luaj/luaj-jse -->\n <dependency>\n     <groupId>org.luaj</groupId>\n     <artifactId>luaj-jse</artifactId>\n     <version>3.0.1</version>\n </dependency>\n ```\n- 方式三：直接下载[LuaJ源码](https://sourceforge.net/projects/luaj/)，添加到项目中，这种方法可以进行Debug，将源码中``src``目录下的``core``和``jse``目录中的代码复制到项目中。\n\n---\n### **实战：**\n#### **在Java中调用Lua：**\n- 直接把lua代码当做String字符串内嵌到Java代码中：\n\n  ``` java\nString luaStr = \"print 'hello,world!'\";\nGlobals globals = JsePlatform.standardGlobals();\nLuaValue chunk = globals.load(luaStr);\nchunk.call();\n  ```\n 此处luaStr中只能放一个lua的方法，或者是一句lua语句，不可以出现多个function放在同一个String中使用此方法来调用。\n- 将Lua代码都写在``.lua``脚本文件中，在Java中调用Lua脚本文件，指定要执行的``lua function``，可以直接如下：\n - 创建一个``login.lua``脚本，内容如下：\n\n     ``` lua\n    --无参函数\n    function hello()\n       print 'hello'\n    end\n\t--带参函数\n    function test(str)\n       print('data from java is:'..str)\n       return 'haha'\n    end\n     ```\n - Java先载入``login.lua``脚本并编译，然后再获取指定名称的函数，无参的直接使用``call()``方法调用，带参的需要通过``invoke(LuaValue[])``传入参数表：\n    ``` java\n    String luaPath = \"res/lua/login.lua\";\t//lua脚本文件所在路径\n    Globals globals = JsePlatform.standardGlobals();\n\t//加载脚本文件login.lua，并编译\n\tglobals.loadfile(luaPath).call();\n\t//获取无参函数hello\n\tLuaValue func = globals.get(LuaValue.valueOf(\"hello\"));\n\t//执行hello方法\n\tfunc.call();\n\t//获取带参函数test\n\tLuaValue func1 = globals.get(LuaValue.valueOf(\"test\"));\n\t//执行test方法,传入String类型的参数参数\n\tString data = func1.call(LuaValue.valueOf(\"I'am from Java!\")).toString();\n    //打印lua函数回传的数据\n    Logger.info(\"data return from lua is:\"+data);\n    ```\n - 运行结果如下：\n ``` shell\n hello\n data from java is:I'am from Java!\n 四月 07, 2017 5:31:25 下午 com.tw.login.tools.Logger info\n 信息: lua return data：haha\n ```\n\n- 这里需要理解``LuaValue``和``Globals``的含义：\n``Globals``继承``LuaValue``对象，``LuaValue``对象用来表示在Lua语言的基本数据类型，比如:``Nil``,``Number``,``String``,``Table``,``userdata``,``Function``等。**尤其要注意``LuaValue``也表示了Lua语言中的函数**。所以,对于Lua语言中的函数操作都是通过``LuaValue``来实现的。\n\n#### **在Lua中调用Java:**\n\n- **创建Java类：**\n假设在Java中有这样的一个日志类``Logger.java``：\n    ``` java\n    package com.tw.login.tools;\n\n    import org.apache.commons.logging.Log;\n    import org.apache.commons.logging.LogFactory;\n\n    public class Logger {\n        public static String TAG = \"Logger\";\n        private static Log logger = LogFactory.getLog(Logger.class);;\n        public Logger(){\n            if(logger == null){\n                logger = LogFactory.getLog(Logger.class);\n            }\n        }\n\n        public void TestLogger(String str) {\n            logger.info(str);\n        }\n\n        public static void info(String content){\n            logger.info(content);\n        }\n    }\n    ```\n- **创建一个lua脚本：**\n命名为``test.lua``，存放在当前项目根目录下的``res/lua``目录下，详细代码如下：\n - 在Lua中直接创建Java类的实例的方法：\n ``` lua\n--使用luajava创建java类的实例（对象）\nlocal logger = luajava.newInstance(\"com.tw.login.tools.Logger\")\n--调用对象方法\nlogger:TestLogger(\"Test call java in lua0\")\n ```\n - 在Lua中绑定Java类：\n ``` lua\n--使用luajava绑定一个java类\nlocal logger_method = luajava.bindClass(\"com.tw.login.tools.Logger\");\n--调用类的静态方法/变量\nlogger_method:info(\"test call static java function in lua\")\nprint(logger_method.TAG)\n-- 使用绑定类创建类的实例（对象）\nlocal logger_instance = luajava.new(logger_method)\n-- 调用对象方法\nlogger_instance:TestLogger(\"Test call java in lua1\")\n ```\n\n 当前我们只是实现了Lua中调用Java的逻辑，但是作为一种脚本语言，Lua没办法脱离高级语言而独立运行起来，所以要测试Lua是否能正常实现对Java的调用，还是需要在Java中运行此Lua脚本，参考之前在Java调用``.lua``脚本文件的方法，在Java中的main入口函数中添加一下内容：\n\t``` java\n\tGlobals globals = JsePlatform.standardGlobals();\n\tglobals.loadfile(\"res/lua/test.lua\").call();\n\t```\n\n- **结果输出日志：**\n\t``` shell\n\t四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger TestLogger\n\t信息: Test call java in lua0\n\t四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger info\n\t信息: test call static java function in lua\n\tLogger\n\t四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger TestLogger\n\t信息: Test call java in lua1\n\t```\n\n---\n### **其他：**\n- ``LuaJ``直到代码运行结束前都会阻塞线程，这时候开启一个新的线程专门运行即可，但是``LuaJ``运行以后无法中断（即使你中断了它所在的线程），比如你的.lua中有一个``while true do end``循环，那么你将永远无法中断它，除非退出你的整个Java应用。\n- 在``LuaJava``上，发现调用了``L.close()``方法也是不能中断执行。\n\n---\n\n### **参考：**\n- [在Java中使用Lua脚本语言](http://yangzb.iteye.com/blog/560299)\n- [关于在java上使用lua脚本](http://www.360doc.com/content/15/0117/17/9200790_441588770.shtml)\n- [luaj——java程序中运行lua](http://blog.csdn.net/mislead/article/details/51657477)\n- [LuaJ 调用java方法性能研究](http://www.cnblogs.com/mingwuyun/p/5924911.html)\n- [lua调用java java调用lua](http://www.cnblogs.com/mokey/p/4443561.html)\n- [luaj-lua中实例化JavaClass](http://blog.csdn.net/mislead/article/details/51657493)\n\n---\n- [在JAVA中使用LUA脚本记,javaj调用lua脚本的函数](http://hovertree.com/h/bjaf/wcxci250.htm)\n- [luaj:初探](http://blog.csdn.net/sunning9001/article/details/50471740)","source":"_posts/Java中内嵌lua.md","raw":"---\ntitle: Java中内嵌Lua脚本\ndate: 2017-04-30 21:10:37\ntags: Java,Lua\ncategories: 服务器开发\n---\n\n``Lua``是一种小巧的脚本语言，如今常用于游戏开发，特别是客户端开发，基本上都是基于Lua来实现热更新，在Unity开发中更有``uLua``（最新版改名为``toLua``）这样成熟的热更框架。这里我设想用``Lua``+``Java``来实现服务器的热更，不成熟的想法，这里想尝试一下``Lua``和``Java``如何互相调用。\n\n<!--more-->\n\n### **插件选择：**\n假如引入第三方库，可以找到比较常用的两个选择：``LuaJava``和``LuaJ``，简单做一下对比：\n\n|第三方库|实现|特性|\n|:-----:|:-----:|:---:|\n|LuaJava|非纯Java实现，需要通过native方法调用C库，依赖于Lua 5.1|会导致JVM崩溃，不再更新，没人维护|\n|LuaJ（LuaJavaBridge）|纯Java实现的Lua解析器，无需使用native|不会因错误导致JVM crash，支持JSR-223|\n\n#### **LuaJava简介：**\nLua是支持内嵌在C程序中的，但是官方不支持Java，所以我们只能寻找第三方插件了，找到了一个``LuaJava``，这是一个开源项目，实现方式：LuaJava实际上就是按照Lua官方文档，把Lua的C接口通过``JNI``包装成Java的库。下载资源，里面是一个``.dll``和 一个``.jar``。把``.dll``放到``java.library.path``下，再把``.lib``放到``classpath``中。\n\n#### **LuaJ简介：**\n**主要特征：**\n\n- 可以从 ``Lua`` 调用 ``Java Class Static Method``（Java的静态方法）；\n- 调用 ``Java`` 方法时，支持 ``int/float/boolean/String/Lua function`` 五种参数类型；\n- 可以将 ``Lua function`` 作为参数传递给 ``Java``，并让 ``Java`` 保存 ``Lua function`` 的引用；\n- 可以从 ``Java`` 调用 ``Lua`` 的全局函数，或者调用引用指向的 ``Lua function``。\n\n#### **LuaJ核心原理：**\n``LuaJ``的核心其实就是：从``Lua``调用``Java``和从``Java``调用``Lua``。\n\n经过上述对比，最终我还是选择纯Java实现，且仍然有人维护更新的``LuaJ``解析器，而且它也支持``LuaJava API``。\n\n---\n\n### **LuaJ的下载使用：**\n#### **下载：**\n- 方式一：直接到[LuaJ官网](http://www.luaj.org/luaj/3.0/README.html)下载，选择相对较新的版本[LuaJ 3.0.1](https://nchc.dl.sourceforge.net/project/luaj/luaj-3.0/3.0.1/luaj-3.0.1.zip)，将解压后的``lib``目录下的``luaj-jse-3.0.1.jar``导入项目中使用。\n- 方式二：当然加入是使用Maven来管理项目的就不用这么麻烦了，直接在``pom.xml``中添加库依赖内容：\n\n ``` xml\n <!-- https://mvnrepository.com/artifact/org.luaj/luaj-jse -->\n <dependency>\n     <groupId>org.luaj</groupId>\n     <artifactId>luaj-jse</artifactId>\n     <version>3.0.1</version>\n </dependency>\n ```\n- 方式三：直接下载[LuaJ源码](https://sourceforge.net/projects/luaj/)，添加到项目中，这种方法可以进行Debug，将源码中``src``目录下的``core``和``jse``目录中的代码复制到项目中。\n\n---\n### **实战：**\n#### **在Java中调用Lua：**\n- 直接把lua代码当做String字符串内嵌到Java代码中：\n\n  ``` java\nString luaStr = \"print 'hello,world!'\";\nGlobals globals = JsePlatform.standardGlobals();\nLuaValue chunk = globals.load(luaStr);\nchunk.call();\n  ```\n 此处luaStr中只能放一个lua的方法，或者是一句lua语句，不可以出现多个function放在同一个String中使用此方法来调用。\n- 将Lua代码都写在``.lua``脚本文件中，在Java中调用Lua脚本文件，指定要执行的``lua function``，可以直接如下：\n - 创建一个``login.lua``脚本，内容如下：\n\n     ``` lua\n    --无参函数\n    function hello()\n       print 'hello'\n    end\n\t--带参函数\n    function test(str)\n       print('data from java is:'..str)\n       return 'haha'\n    end\n     ```\n - Java先载入``login.lua``脚本并编译，然后再获取指定名称的函数，无参的直接使用``call()``方法调用，带参的需要通过``invoke(LuaValue[])``传入参数表：\n    ``` java\n    String luaPath = \"res/lua/login.lua\";\t//lua脚本文件所在路径\n    Globals globals = JsePlatform.standardGlobals();\n\t//加载脚本文件login.lua，并编译\n\tglobals.loadfile(luaPath).call();\n\t//获取无参函数hello\n\tLuaValue func = globals.get(LuaValue.valueOf(\"hello\"));\n\t//执行hello方法\n\tfunc.call();\n\t//获取带参函数test\n\tLuaValue func1 = globals.get(LuaValue.valueOf(\"test\"));\n\t//执行test方法,传入String类型的参数参数\n\tString data = func1.call(LuaValue.valueOf(\"I'am from Java!\")).toString();\n    //打印lua函数回传的数据\n    Logger.info(\"data return from lua is:\"+data);\n    ```\n - 运行结果如下：\n ``` shell\n hello\n data from java is:I'am from Java!\n 四月 07, 2017 5:31:25 下午 com.tw.login.tools.Logger info\n 信息: lua return data：haha\n ```\n\n- 这里需要理解``LuaValue``和``Globals``的含义：\n``Globals``继承``LuaValue``对象，``LuaValue``对象用来表示在Lua语言的基本数据类型，比如:``Nil``,``Number``,``String``,``Table``,``userdata``,``Function``等。**尤其要注意``LuaValue``也表示了Lua语言中的函数**。所以,对于Lua语言中的函数操作都是通过``LuaValue``来实现的。\n\n#### **在Lua中调用Java:**\n\n- **创建Java类：**\n假设在Java中有这样的一个日志类``Logger.java``：\n    ``` java\n    package com.tw.login.tools;\n\n    import org.apache.commons.logging.Log;\n    import org.apache.commons.logging.LogFactory;\n\n    public class Logger {\n        public static String TAG = \"Logger\";\n        private static Log logger = LogFactory.getLog(Logger.class);;\n        public Logger(){\n            if(logger == null){\n                logger = LogFactory.getLog(Logger.class);\n            }\n        }\n\n        public void TestLogger(String str) {\n            logger.info(str);\n        }\n\n        public static void info(String content){\n            logger.info(content);\n        }\n    }\n    ```\n- **创建一个lua脚本：**\n命名为``test.lua``，存放在当前项目根目录下的``res/lua``目录下，详细代码如下：\n - 在Lua中直接创建Java类的实例的方法：\n ``` lua\n--使用luajava创建java类的实例（对象）\nlocal logger = luajava.newInstance(\"com.tw.login.tools.Logger\")\n--调用对象方法\nlogger:TestLogger(\"Test call java in lua0\")\n ```\n - 在Lua中绑定Java类：\n ``` lua\n--使用luajava绑定一个java类\nlocal logger_method = luajava.bindClass(\"com.tw.login.tools.Logger\");\n--调用类的静态方法/变量\nlogger_method:info(\"test call static java function in lua\")\nprint(logger_method.TAG)\n-- 使用绑定类创建类的实例（对象）\nlocal logger_instance = luajava.new(logger_method)\n-- 调用对象方法\nlogger_instance:TestLogger(\"Test call java in lua1\")\n ```\n\n 当前我们只是实现了Lua中调用Java的逻辑，但是作为一种脚本语言，Lua没办法脱离高级语言而独立运行起来，所以要测试Lua是否能正常实现对Java的调用，还是需要在Java中运行此Lua脚本，参考之前在Java调用``.lua``脚本文件的方法，在Java中的main入口函数中添加一下内容：\n\t``` java\n\tGlobals globals = JsePlatform.standardGlobals();\n\tglobals.loadfile(\"res/lua/test.lua\").call();\n\t```\n\n- **结果输出日志：**\n\t``` shell\n\t四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger TestLogger\n\t信息: Test call java in lua0\n\t四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger info\n\t信息: test call static java function in lua\n\tLogger\n\t四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger TestLogger\n\t信息: Test call java in lua1\n\t```\n\n---\n### **其他：**\n- ``LuaJ``直到代码运行结束前都会阻塞线程，这时候开启一个新的线程专门运行即可，但是``LuaJ``运行以后无法中断（即使你中断了它所在的线程），比如你的.lua中有一个``while true do end``循环，那么你将永远无法中断它，除非退出你的整个Java应用。\n- 在``LuaJava``上，发现调用了``L.close()``方法也是不能中断执行。\n\n---\n\n### **参考：**\n- [在Java中使用Lua脚本语言](http://yangzb.iteye.com/blog/560299)\n- [关于在java上使用lua脚本](http://www.360doc.com/content/15/0117/17/9200790_441588770.shtml)\n- [luaj——java程序中运行lua](http://blog.csdn.net/mislead/article/details/51657477)\n- [LuaJ 调用java方法性能研究](http://www.cnblogs.com/mingwuyun/p/5924911.html)\n- [lua调用java java调用lua](http://www.cnblogs.com/mokey/p/4443561.html)\n- [luaj-lua中实例化JavaClass](http://blog.csdn.net/mislead/article/details/51657493)\n\n---\n- [在JAVA中使用LUA脚本记,javaj调用lua脚本的函数](http://hovertree.com/h/bjaf/wcxci250.htm)\n- [luaj:初探](http://blog.csdn.net/sunning9001/article/details/50471740)","slug":"Java中内嵌lua","published":1,"updated":"2017-06-24T02:13:49.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfji000d9gfjd7nh6b2g","content":"<p><code>Lua</code>是一种小巧的脚本语言，如今常用于游戏开发，特别是客户端开发，基本上都是基于Lua来实现热更新，在Unity开发中更有<code>uLua</code>（最新版改名为<code>toLua</code>）这样成熟的热更框架。这里我设想用<code>Lua</code>+<code>Java</code>来实现服务器的热更，不成熟的想法，这里想尝试一下<code>Lua</code>和<code>Java</code>如何互相调用。</p>\n<a id=\"more\"></a>\n<h3 id=\"插件选择：\"><a href=\"#插件选择：\" class=\"headerlink\" title=\"插件选择：\"></a><strong>插件选择：</strong></h3><p>假如引入第三方库，可以找到比较常用的两个选择：<code>LuaJava</code>和<code>LuaJ</code>，简单做一下对比：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">第三方库</th>\n<th style=\"text-align:center\">实现</th>\n<th style=\"text-align:center\">特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">LuaJava</td>\n<td style=\"text-align:center\">非纯Java实现，需要通过native方法调用C库，依赖于Lua 5.1</td>\n<td style=\"text-align:center\">会导致JVM崩溃，不再更新，没人维护</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LuaJ（LuaJavaBridge）</td>\n<td style=\"text-align:center\">纯Java实现的Lua解析器，无需使用native</td>\n<td style=\"text-align:center\">不会因错误导致JVM crash，支持JSR-223</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"LuaJava简介：\"><a href=\"#LuaJava简介：\" class=\"headerlink\" title=\"LuaJava简介：\"></a><strong>LuaJava简介：</strong></h4><p>Lua是支持内嵌在C程序中的，但是官方不支持Java，所以我们只能寻找第三方插件了，找到了一个<code>LuaJava</code>，这是一个开源项目，实现方式：LuaJava实际上就是按照Lua官方文档，把Lua的C接口通过<code>JNI</code>包装成Java的库。下载资源，里面是一个<code>.dll</code>和 一个<code>.jar</code>。把<code>.dll</code>放到<code>java.library.path</code>下，再把<code>.lib</code>放到<code>classpath</code>中。</p>\n<h4 id=\"LuaJ简介：\"><a href=\"#LuaJ简介：\" class=\"headerlink\" title=\"LuaJ简介：\"></a><strong>LuaJ简介：</strong></h4><p><strong>主要特征：</strong></p>\n<ul>\n<li>可以从 <code>Lua</code> 调用 <code>Java Class Static Method</code>（Java的静态方法）；</li>\n<li>调用 <code>Java</code> 方法时，支持 <code>int/float/boolean/String/Lua function</code> 五种参数类型；</li>\n<li>可以将 <code>Lua function</code> 作为参数传递给 <code>Java</code>，并让 <code>Java</code> 保存 <code>Lua function</code> 的引用；</li>\n<li>可以从 <code>Java</code> 调用 <code>Lua</code> 的全局函数，或者调用引用指向的 <code>Lua function</code>。</li>\n</ul>\n<h4 id=\"LuaJ核心原理：\"><a href=\"#LuaJ核心原理：\" class=\"headerlink\" title=\"LuaJ核心原理：\"></a><strong>LuaJ核心原理：</strong></h4><p><code>LuaJ</code>的核心其实就是：从<code>Lua</code>调用<code>Java</code>和从<code>Java</code>调用<code>Lua</code>。</p>\n<p>经过上述对比，最终我还是选择纯Java实现，且仍然有人维护更新的<code>LuaJ</code>解析器，而且它也支持<code>LuaJava API</code>。</p>\n<hr>\n<h3 id=\"LuaJ的下载使用：\"><a href=\"#LuaJ的下载使用：\" class=\"headerlink\" title=\"LuaJ的下载使用：\"></a><strong>LuaJ的下载使用：</strong></h3><h4 id=\"下载：\"><a href=\"#下载：\" class=\"headerlink\" title=\"下载：\"></a><strong>下载：</strong></h4><ul>\n<li>方式一：直接到<a href=\"http://www.luaj.org/luaj/3.0/README.html\" target=\"_blank\" rel=\"external\">LuaJ官网</a>下载，选择相对较新的版本<a href=\"https://nchc.dl.sourceforge.net/project/luaj/luaj-3.0/3.0.1/luaj-3.0.1.zip\" target=\"_blank\" rel=\"external\">LuaJ 3.0.1</a>，将解压后的<code>lib</code>目录下的<code>luaj-jse-3.0.1.jar</code>导入项目中使用。</li>\n<li><p>方式二：当然加入是使用Maven来管理项目的就不用这么麻烦了，直接在<code>pom.xml</code>中添加库依赖内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.luaj/luaj-jse --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.luaj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>luaj-jse<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>方式三：直接下载<a href=\"https://sourceforge.net/projects/luaj/\" target=\"_blank\" rel=\"external\">LuaJ源码</a>，添加到项目中，这种方法可以进行Debug，将源码中<code>src</code>目录下的<code>core</code>和<code>jse</code>目录中的代码复制到项目中。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"实战：\"><a href=\"#实战：\" class=\"headerlink\" title=\"实战：\"></a><strong>实战：</strong></h3><h4 id=\"在Java中调用Lua：\"><a href=\"#在Java中调用Lua：\" class=\"headerlink\" title=\"在Java中调用Lua：\"></a><strong>在Java中调用Lua：</strong></h4><ul>\n<li><p>直接把lua代码当做String字符串内嵌到Java代码中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String luaStr = <span class=\"string\">\"print 'hello,world!'\"</span>;</div><div class=\"line\">Globals globals = JsePlatform.standardGlobals();</div><div class=\"line\">LuaValue chunk = globals.load(luaStr);</div><div class=\"line\">chunk.call();</div></pre></td></tr></table></figure>\n<p>此处luaStr中只能放一个lua的方法，或者是一句lua语句，不可以出现多个function放在同一个String中使用此方法来调用。</p>\n</li>\n<li><p>将Lua代码都写在<code>.lua</code>脚本文件中，在Java中调用Lua脚本文件，指定要执行的<code>lua function</code>，可以直接如下：</p>\n<ul>\n<li><p>创建一个<code>login.lua</code>脚本，内容如下：</p>\n <figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"comment\">--无参函数</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span></div><div class=\"line\">      <span class=\"built_in\">print</span> <span class=\"string\">'hello'</span></div><div class=\"line\">   <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"comment\">--带参函数</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span><span class=\"params\">(str)</span></span></div><div class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'data from java is:'</span>..str)</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'haha'</span></div><div class=\"line\">   <span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>Java先载入<code>login.lua</code>脚本并编译，然后再获取指定名称的函数，无参的直接使用<code>call()</code>方法调用，带参的需要通过<code>invoke(LuaValue[])</code>传入参数表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">   String luaPath = <span class=\"string\">\"res/lua/login.lua\"</span>;\t<span class=\"comment\">//lua脚本文件所在路径</span></div><div class=\"line\">   Globals globals = JsePlatform.standardGlobals();</div><div class=\"line\"><span class=\"comment\">//加载脚本文件login.lua，并编译</span></div><div class=\"line\">globals.loadfile(luaPath).call();</div><div class=\"line\"><span class=\"comment\">//获取无参函数hello</span></div><div class=\"line\">LuaValue func = globals.get(LuaValue.valueOf(<span class=\"string\">\"hello\"</span>));</div><div class=\"line\"><span class=\"comment\">//执行hello方法</span></div><div class=\"line\">func.call();</div><div class=\"line\"><span class=\"comment\">//获取带参函数test</span></div><div class=\"line\">LuaValue func1 = globals.get(LuaValue.valueOf(<span class=\"string\">\"test\"</span>));</div><div class=\"line\"><span class=\"comment\">//执行test方法,传入String类型的参数参数</span></div><div class=\"line\">String data = func1.call(LuaValue.valueOf(<span class=\"string\">\"I'am from Java!\"</span>)).toString();</div><div class=\"line\">   <span class=\"comment\">//打印lua函数回传的数据</span></div><div class=\"line\">   Logger.info(<span class=\"string\">\"data return from lua is:\"</span>+data);</div></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hello</div><div class=\"line\">data from java is:I&apos;am from Java!</div><div class=\"line\">四月 07, 2017 5:31:25 下午 com.tw.login.tools.Logger info</div><div class=\"line\">信息: lua return data：haha</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>这里需要理解<code>LuaValue</code>和<code>Globals</code>的含义：<br><code>Globals</code>继承<code>LuaValue</code>对象，<code>LuaValue</code>对象用来表示在Lua语言的基本数据类型，比如:<code>Nil</code>,<code>Number</code>,<code>String</code>,<code>Table</code>,<code>userdata</code>,<code>Function</code>等。<strong>尤其要注意<code>LuaValue</code>也表示了Lua语言中的函数</strong>。所以,对于Lua语言中的函数操作都是通过<code>LuaValue</code>来实现的。</p>\n</li>\n</ul>\n<h4 id=\"在Lua中调用Java\"><a href=\"#在Lua中调用Java\" class=\"headerlink\" title=\"在Lua中调用Java:\"></a><strong>在Lua中调用Java:</strong></h4><ul>\n<li><p><strong>创建Java类：</strong><br>假设在Java中有这样的一个日志类<code>Logger.java</code>：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.tw.login.tools;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.Log;</div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.LogFactory;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String TAG = <span class=\"string\">\"Logger\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Log logger = LogFactory.getLog(Logger.class);;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Logger</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(logger == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            logger = LogFactory.getLog(Logger.class);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">TestLogger</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">        logger.info(str);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">info</span><span class=\"params\">(String content)</span></span>&#123;</div><div class=\"line\">        logger.info(content);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>创建一个lua脚本：</strong><br>命名为<code>test.lua</code>，存放在当前项目根目录下的<code>res/lua</code>目录下，详细代码如下：</p>\n<ul>\n<li><p>在Lua中直接创建Java类的实例的方法：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">--使用luajava创建java类的实例（对象）</span></div><div class=\"line\"><span class=\"keyword\">local</span> logger = luajava.newInstance(<span class=\"string\">\"com.tw.login.tools.Logger\"</span>)</div><div class=\"line\"><span class=\"comment\">--调用对象方法</span></div><div class=\"line\">logger:TestLogger(<span class=\"string\">\"Test call java in lua0\"</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p>在Lua中绑定Java类：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">--使用luajava绑定一个java类</span></div><div class=\"line\"><span class=\"keyword\">local</span> logger_method = luajava.bindClass(<span class=\"string\">\"com.tw.login.tools.Logger\"</span>);</div><div class=\"line\"><span class=\"comment\">--调用类的静态方法/变量</span></div><div class=\"line\">logger_method:info(<span class=\"string\">\"test call static java function in lua\"</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(logger_method.TAG)</div><div class=\"line\"><span class=\"comment\">-- 使用绑定类创建类的实例（对象）</span></div><div class=\"line\"><span class=\"keyword\">local</span> logger_instance = luajava.new(logger_method)</div><div class=\"line\"><span class=\"comment\">-- 调用对象方法</span></div><div class=\"line\">logger_instance:TestLogger(<span class=\"string\">\"Test call java in lua1\"</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当前我们只是实现了Lua中调用Java的逻辑，但是作为一种脚本语言，Lua没办法脱离高级语言而独立运行起来，所以要测试Lua是否能正常实现对Java的调用，还是需要在Java中运行此Lua脚本，参考之前在Java调用<code>.lua</code>脚本文件的方法，在Java中的main入口函数中添加一下内容：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Globals globals = JsePlatform.standardGlobals();</div><div class=\"line\">globals.loadfile(<span class=\"string\">\"res/lua/test.lua\"</span>).call();</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>结果输出日志：</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger TestLogger</div><div class=\"line\">信息: Test call java in lua0</div><div class=\"line\">四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger info</div><div class=\"line\">信息: test call static java function in lua</div><div class=\"line\">Logger</div><div class=\"line\">四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger TestLogger</div><div class=\"line\">信息: Test call java in lua1</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"其他：\"><a href=\"#其他：\" class=\"headerlink\" title=\"其他：\"></a><strong>其他：</strong></h3><ul>\n<li><code>LuaJ</code>直到代码运行结束前都会阻塞线程，这时候开启一个新的线程专门运行即可，但是<code>LuaJ</code>运行以后无法中断（即使你中断了它所在的线程），比如你的.lua中有一个<code>while true do end</code>循环，那么你将永远无法中断它，除非退出你的整个Java应用。</li>\n<li>在<code>LuaJava</code>上，发现调用了<code>L.close()</code>方法也是不能中断执行。</li>\n</ul>\n<hr>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a><strong>参考：</strong></h3><ul>\n<li><a href=\"http://yangzb.iteye.com/blog/560299\" target=\"_blank\" rel=\"external\">在Java中使用Lua脚本语言</a></li>\n<li><a href=\"http://www.360doc.com/content/15/0117/17/9200790_441588770.shtml\" target=\"_blank\" rel=\"external\">关于在java上使用lua脚本</a></li>\n<li><a href=\"http://blog.csdn.net/mislead/article/details/51657477\" target=\"_blank\" rel=\"external\">luaj——java程序中运行lua</a></li>\n<li><a href=\"http://www.cnblogs.com/mingwuyun/p/5924911.html\" target=\"_blank\" rel=\"external\">LuaJ 调用java方法性能研究</a></li>\n<li><a href=\"http://www.cnblogs.com/mokey/p/4443561.html\" target=\"_blank\" rel=\"external\">lua调用java java调用lua</a></li>\n<li><a href=\"http://blog.csdn.net/mislead/article/details/51657493\" target=\"_blank\" rel=\"external\">luaj-lua中实例化JavaClass</a></li>\n</ul>\n<hr>\n<ul>\n<li><a href=\"http://hovertree.com/h/bjaf/wcxci250.htm\" target=\"_blank\" rel=\"external\">在JAVA中使用LUA脚本记,javaj调用lua脚本的函数</a></li>\n<li><a href=\"http://blog.csdn.net/sunning9001/article/details/50471740\" target=\"_blank\" rel=\"external\">luaj:初探</a></li>\n</ul>\n","excerpt":"<p><code>Lua</code>是一种小巧的脚本语言，如今常用于游戏开发，特别是客户端开发，基本上都是基于Lua来实现热更新，在Unity开发中更有<code>uLua</code>（最新版改名为<code>toLua</code>）这样成熟的热更框架。这里我设想用<code>Lua</code>+<code>Java</code>来实现服务器的热更，不成熟的想法，这里想尝试一下<code>Lua</code>和<code>Java</code>如何互相调用。</p>","more":"<h3 id=\"插件选择：\"><a href=\"#插件选择：\" class=\"headerlink\" title=\"插件选择：\"></a><strong>插件选择：</strong></h3><p>假如引入第三方库，可以找到比较常用的两个选择：<code>LuaJava</code>和<code>LuaJ</code>，简单做一下对比：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">第三方库</th>\n<th style=\"text-align:center\">实现</th>\n<th style=\"text-align:center\">特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">LuaJava</td>\n<td style=\"text-align:center\">非纯Java实现，需要通过native方法调用C库，依赖于Lua 5.1</td>\n<td style=\"text-align:center\">会导致JVM崩溃，不再更新，没人维护</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LuaJ（LuaJavaBridge）</td>\n<td style=\"text-align:center\">纯Java实现的Lua解析器，无需使用native</td>\n<td style=\"text-align:center\">不会因错误导致JVM crash，支持JSR-223</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"LuaJava简介：\"><a href=\"#LuaJava简介：\" class=\"headerlink\" title=\"LuaJava简介：\"></a><strong>LuaJava简介：</strong></h4><p>Lua是支持内嵌在C程序中的，但是官方不支持Java，所以我们只能寻找第三方插件了，找到了一个<code>LuaJava</code>，这是一个开源项目，实现方式：LuaJava实际上就是按照Lua官方文档，把Lua的C接口通过<code>JNI</code>包装成Java的库。下载资源，里面是一个<code>.dll</code>和 一个<code>.jar</code>。把<code>.dll</code>放到<code>java.library.path</code>下，再把<code>.lib</code>放到<code>classpath</code>中。</p>\n<h4 id=\"LuaJ简介：\"><a href=\"#LuaJ简介：\" class=\"headerlink\" title=\"LuaJ简介：\"></a><strong>LuaJ简介：</strong></h4><p><strong>主要特征：</strong></p>\n<ul>\n<li>可以从 <code>Lua</code> 调用 <code>Java Class Static Method</code>（Java的静态方法）；</li>\n<li>调用 <code>Java</code> 方法时，支持 <code>int/float/boolean/String/Lua function</code> 五种参数类型；</li>\n<li>可以将 <code>Lua function</code> 作为参数传递给 <code>Java</code>，并让 <code>Java</code> 保存 <code>Lua function</code> 的引用；</li>\n<li>可以从 <code>Java</code> 调用 <code>Lua</code> 的全局函数，或者调用引用指向的 <code>Lua function</code>。</li>\n</ul>\n<h4 id=\"LuaJ核心原理：\"><a href=\"#LuaJ核心原理：\" class=\"headerlink\" title=\"LuaJ核心原理：\"></a><strong>LuaJ核心原理：</strong></h4><p><code>LuaJ</code>的核心其实就是：从<code>Lua</code>调用<code>Java</code>和从<code>Java</code>调用<code>Lua</code>。</p>\n<p>经过上述对比，最终我还是选择纯Java实现，且仍然有人维护更新的<code>LuaJ</code>解析器，而且它也支持<code>LuaJava API</code>。</p>\n<hr>\n<h3 id=\"LuaJ的下载使用：\"><a href=\"#LuaJ的下载使用：\" class=\"headerlink\" title=\"LuaJ的下载使用：\"></a><strong>LuaJ的下载使用：</strong></h3><h4 id=\"下载：\"><a href=\"#下载：\" class=\"headerlink\" title=\"下载：\"></a><strong>下载：</strong></h4><ul>\n<li>方式一：直接到<a href=\"http://www.luaj.org/luaj/3.0/README.html\">LuaJ官网</a>下载，选择相对较新的版本<a href=\"https://nchc.dl.sourceforge.net/project/luaj/luaj-3.0/3.0.1/luaj-3.0.1.zip\">LuaJ 3.0.1</a>，将解压后的<code>lib</code>目录下的<code>luaj-jse-3.0.1.jar</code>导入项目中使用。</li>\n<li><p>方式二：当然加入是使用Maven来管理项目的就不用这么麻烦了，直接在<code>pom.xml</code>中添加库依赖内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.luaj/luaj-jse --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.luaj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>luaj-jse<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>方式三：直接下载<a href=\"https://sourceforge.net/projects/luaj/\">LuaJ源码</a>，添加到项目中，这种方法可以进行Debug，将源码中<code>src</code>目录下的<code>core</code>和<code>jse</code>目录中的代码复制到项目中。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"实战：\"><a href=\"#实战：\" class=\"headerlink\" title=\"实战：\"></a><strong>实战：</strong></h3><h4 id=\"在Java中调用Lua：\"><a href=\"#在Java中调用Lua：\" class=\"headerlink\" title=\"在Java中调用Lua：\"></a><strong>在Java中调用Lua：</strong></h4><ul>\n<li><p>直接把lua代码当做String字符串内嵌到Java代码中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String luaStr = <span class=\"string\">\"print 'hello,world!'\"</span>;</div><div class=\"line\">Globals globals = JsePlatform.standardGlobals();</div><div class=\"line\">LuaValue chunk = globals.load(luaStr);</div><div class=\"line\">chunk.call();</div></pre></td></tr></table></figure>\n<p>此处luaStr中只能放一个lua的方法，或者是一句lua语句，不可以出现多个function放在同一个String中使用此方法来调用。</p>\n</li>\n<li><p>将Lua代码都写在<code>.lua</code>脚本文件中，在Java中调用Lua脚本文件，指定要执行的<code>lua function</code>，可以直接如下：</p>\n<ul>\n<li><p>创建一个<code>login.lua</code>脚本，内容如下：</p>\n <figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"comment\">--无参函数</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span></div><div class=\"line\">      <span class=\"built_in\">print</span> <span class=\"string\">'hello'</span></div><div class=\"line\">   <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"comment\">--带参函数</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span><span class=\"params\">(str)</span></span></div><div class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'data from java is:'</span>..str)</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'haha'</span></div><div class=\"line\">   <span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>Java先载入<code>login.lua</code>脚本并编译，然后再获取指定名称的函数，无参的直接使用<code>call()</code>方法调用，带参的需要通过<code>invoke(LuaValue[])</code>传入参数表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">   String luaPath = <span class=\"string\">\"res/lua/login.lua\"</span>;\t<span class=\"comment\">//lua脚本文件所在路径</span></div><div class=\"line\">   Globals globals = JsePlatform.standardGlobals();</div><div class=\"line\"><span class=\"comment\">//加载脚本文件login.lua，并编译</span></div><div class=\"line\">globals.loadfile(luaPath).call();</div><div class=\"line\"><span class=\"comment\">//获取无参函数hello</span></div><div class=\"line\">LuaValue func = globals.get(LuaValue.valueOf(<span class=\"string\">\"hello\"</span>));</div><div class=\"line\"><span class=\"comment\">//执行hello方法</span></div><div class=\"line\">func.call();</div><div class=\"line\"><span class=\"comment\">//获取带参函数test</span></div><div class=\"line\">LuaValue func1 = globals.get(LuaValue.valueOf(<span class=\"string\">\"test\"</span>));</div><div class=\"line\"><span class=\"comment\">//执行test方法,传入String类型的参数参数</span></div><div class=\"line\">String data = func1.call(LuaValue.valueOf(<span class=\"string\">\"I'am from Java!\"</span>)).toString();</div><div class=\"line\">   <span class=\"comment\">//打印lua函数回传的数据</span></div><div class=\"line\">   Logger.info(<span class=\"string\">\"data return from lua is:\"</span>+data);</div></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hello</div><div class=\"line\">data from java is:I&apos;am from Java!</div><div class=\"line\">四月 07, 2017 5:31:25 下午 com.tw.login.tools.Logger info</div><div class=\"line\">信息: lua return data：haha</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>这里需要理解<code>LuaValue</code>和<code>Globals</code>的含义：<br><code>Globals</code>继承<code>LuaValue</code>对象，<code>LuaValue</code>对象用来表示在Lua语言的基本数据类型，比如:<code>Nil</code>,<code>Number</code>,<code>String</code>,<code>Table</code>,<code>userdata</code>,<code>Function</code>等。<strong>尤其要注意<code>LuaValue</code>也表示了Lua语言中的函数</strong>。所以,对于Lua语言中的函数操作都是通过<code>LuaValue</code>来实现的。</p>\n</li>\n</ul>\n<h4 id=\"在Lua中调用Java\"><a href=\"#在Lua中调用Java\" class=\"headerlink\" title=\"在Lua中调用Java:\"></a><strong>在Lua中调用Java:</strong></h4><ul>\n<li><p><strong>创建Java类：</strong><br>假设在Java中有这样的一个日志类<code>Logger.java</code>：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.tw.login.tools;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.Log;</div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.LogFactory;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String TAG = <span class=\"string\">\"Logger\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Log logger = LogFactory.getLog(Logger.class);;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Logger</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(logger == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            logger = LogFactory.getLog(Logger.class);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">TestLogger</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">        logger.info(str);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">info</span><span class=\"params\">(String content)</span></span>&#123;</div><div class=\"line\">        logger.info(content);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>创建一个lua脚本：</strong><br>命名为<code>test.lua</code>，存放在当前项目根目录下的<code>res/lua</code>目录下，详细代码如下：</p>\n<ul>\n<li><p>在Lua中直接创建Java类的实例的方法：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">--使用luajava创建java类的实例（对象）</span></div><div class=\"line\"><span class=\"keyword\">local</span> logger = luajava.newInstance(<span class=\"string\">\"com.tw.login.tools.Logger\"</span>)</div><div class=\"line\"><span class=\"comment\">--调用对象方法</span></div><div class=\"line\">logger:TestLogger(<span class=\"string\">\"Test call java in lua0\"</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p>在Lua中绑定Java类：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">--使用luajava绑定一个java类</span></div><div class=\"line\"><span class=\"keyword\">local</span> logger_method = luajava.bindClass(<span class=\"string\">\"com.tw.login.tools.Logger\"</span>);</div><div class=\"line\"><span class=\"comment\">--调用类的静态方法/变量</span></div><div class=\"line\">logger_method:info(<span class=\"string\">\"test call static java function in lua\"</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(logger_method.TAG)</div><div class=\"line\"><span class=\"comment\">-- 使用绑定类创建类的实例（对象）</span></div><div class=\"line\"><span class=\"keyword\">local</span> logger_instance = luajava.new(logger_method)</div><div class=\"line\"><span class=\"comment\">-- 调用对象方法</span></div><div class=\"line\">logger_instance:TestLogger(<span class=\"string\">\"Test call java in lua1\"</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当前我们只是实现了Lua中调用Java的逻辑，但是作为一种脚本语言，Lua没办法脱离高级语言而独立运行起来，所以要测试Lua是否能正常实现对Java的调用，还是需要在Java中运行此Lua脚本，参考之前在Java调用<code>.lua</code>脚本文件的方法，在Java中的main入口函数中添加一下内容：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Globals globals = JsePlatform.standardGlobals();</div><div class=\"line\">globals.loadfile(<span class=\"string\">\"res/lua/test.lua\"</span>).call();</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>结果输出日志：</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger TestLogger</div><div class=\"line\">信息: Test call java in lua0</div><div class=\"line\">四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger info</div><div class=\"line\">信息: test call static java function in lua</div><div class=\"line\">Logger</div><div class=\"line\">四月 07, 2017 2:17:04 下午 com.tw.login.tools.Logger TestLogger</div><div class=\"line\">信息: Test call java in lua1</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"其他：\"><a href=\"#其他：\" class=\"headerlink\" title=\"其他：\"></a><strong>其他：</strong></h3><ul>\n<li><code>LuaJ</code>直到代码运行结束前都会阻塞线程，这时候开启一个新的线程专门运行即可，但是<code>LuaJ</code>运行以后无法中断（即使你中断了它所在的线程），比如你的.lua中有一个<code>while true do end</code>循环，那么你将永远无法中断它，除非退出你的整个Java应用。</li>\n<li>在<code>LuaJava</code>上，发现调用了<code>L.close()</code>方法也是不能中断执行。</li>\n</ul>\n<hr>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a><strong>参考：</strong></h3><ul>\n<li><a href=\"http://yangzb.iteye.com/blog/560299\">在Java中使用Lua脚本语言</a></li>\n<li><a href=\"http://www.360doc.com/content/15/0117/17/9200790_441588770.shtml\">关于在java上使用lua脚本</a></li>\n<li><a href=\"http://blog.csdn.net/mislead/article/details/51657477\">luaj——java程序中运行lua</a></li>\n<li><a href=\"http://www.cnblogs.com/mingwuyun/p/5924911.html\">LuaJ 调用java方法性能研究</a></li>\n<li><a href=\"http://www.cnblogs.com/mokey/p/4443561.html\">lua调用java java调用lua</a></li>\n<li><a href=\"http://blog.csdn.net/mislead/article/details/51657493\">luaj-lua中实例化JavaClass</a></li>\n</ul>\n<hr>\n<ul>\n<li><a href=\"http://hovertree.com/h/bjaf/wcxci250.htm\">在JAVA中使用LUA脚本记,javaj调用lua脚本的函数</a></li>\n<li><a href=\"http://blog.csdn.net/sunning9001/article/details/50471740\">luaj:初探</a></li>\n</ul>"},{"title":"Unity——NGUI染色遮罩Sharer","date":"2017-02-14T02:57:00.000Z","photos":["http://img.blog.csdn.net/20170214103154480"],"_content":"\n>简述：\n遮罩的意思是指对原图被遮住的部分进行一定的处理，这里使用最简单的处理就是染色，所以我们需要创建一个遮罩层，通常使用另一个图片来作为遮罩层，也就是mask图。\n\n<!--more-->\n---\n###一、mask图的作用：\n跟UITexture使用的图片尺寸大小必须一致，将原图中需要被遮住（染色）的部分的位置在mask图中对应位置用纯色（例如：绿色（三原色的一种））涂满，学过flash动画的应该知道遮罩动画的原理，mask图其实就是一个遮罩层。\n\n---\n###二、sharer的实现思路：\n其实就是获取原图UITexture上的每个像素点，然后根据坐标位置去获取mask图UITexture对应位置上指定颜色值的有无，然后乘以透明度（.a属性），例如：mask图为绿色，这获取mask图像素点的.g属性值，加入不为0，则该像素点要染色，否则则不染色，具体该像素点要染成什么颜色可以通过变量传给shader。\n\n---\n###三、实例：\n下面是一个染色shader的代码：\n```cg\nShader \"Micro/TransparentMasked\" {\n\tProperties {\n\t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {}\n\t\t_MaskTex (\"Base (RGB)\", 2D) = \"white\" {}\n\t\t_MyColor (\"MyColor\", Color) = (0,0,1,1)\n\t}\n\t\n\tCategory\n\t{\t\n\t\tTags {\"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\"}\n\t\tLighting Off\n\t\tZWrite On\n\t\tBlend One Zero\n\t\tSubShader {\n\t\t\tPass {\n\t\t\t\tCGPROGRAM\n\t\t\t\t#pragma vertex vert_img\n\t\t\t\t#pragma fragment frag\n\t\n\t\t\t\t#include \"UnityCG.cginc\"\n\t\n\t\t\t\tuniform sampler2D _MainTex;\n\t\t\t\tuniform sampler2D _MaskTex;\n\t\t\t\tfloat4 _MyColor;\n\t\n\t\t\t\tfloat4 frag(v2f_img i) : COLOR \n\t\t\t\t{\n\t\t\t\t\tfloat4 layer = tex2D(_MainTex, i.uv);\t\t\t\t\t\n\t\t\t\t\tfloat4 mask = tex2D(_MaskTex, i.uv);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tfloat4 returnColor = layer;\n\n\t\t\t\t\tfloat gValue = max(0 ,mask.g - mask.b) * mask.a;\n\n\t\t\t\t\treturnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;\n\n\t\t\t\t\treturnColor.a = layer.a;\n\t\t\t\t\treturn returnColor;\n\t\t\t\t}\n\t\t\t\tENDCG\n\t\t\t}\n\t\t}\n\t}\n}\n```\n####1.输入声明：\n首先是输入的声明，这里我们需要明确进行此操作所需的输入有：原图（Texture）、遮罩图（Texture）、目标染色色值（float4），即可声明如下：\n```\n\t\t\t\tuniform sampler2D _MainTex;\n\t\t\t\tuniform sampler2D _MaskTex;\n\t\t\t\tfloat4 _MyColor;\n```\n\n####2.处理函数：\n关键部分在于每个像素点处理函数部分代码：\n```\nfloat4 frag(v2f_img i) : COLOR \n\t\t\t\t{\n\t\t\t\t\tfloat4 layer = tex2D(_MainTex, i.uv);\t\t\t\t\t\n\t\t\t\t\tfloat4 mask = tex2D(_MaskTex, i.uv);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tfloat4 returnColor = layer;\n\n\t\t\t\t\tfloat gValue = max(0 ,mask.g - mask.b) * mask.a;\n\n\t\t\t\t\treturnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;\n\n\t\t\t\t\treturnColor.a = layer.a;\n\t\t\t\t\treturn returnColor;\n\t\t\t\t}\n```\n####3.源码解析：\n接下来我们进行逐句解析：\n- 首先，我们需要将两张图片传入到shader中，用两个float4四元矩阵layer和mask来保存图片数据，每个像素点的数据都是一个float4值，即表示（r,b,g,a）——>（红，绿，蓝，透明度），其中layer是原图层，mask为遮罩层；\n- 通过``float gValue = max(0 ,mask.g - mask.b) * mask.a;``获得该像素点是否染色的状态；\n- 计算每个像素点染色之后的结果``returnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;``，计算得到每个像素点的输出值；\n- 透明度与原图保持一致``returnColor.a = layer.a;``。\n\n---\n###四、Unity实践：\n- 1.新建一个Shader文件，步骤：在Project窗口中右键->Create->Shader，内容为上边的源码，命名为``MaskColor.shader``：\n![MaskColor](http://img.blog.csdn.net/20170214103445766)\n- 2.导入两张图片，原图和mask图：\n![原图和mask图](http://img.blog.csdn.net/20170214103154480)\n- 3.新建一个材质球，步骤：在Project窗口中右键->Create->Material，取名为选中``MaskColor.mat``，选中次材质球，将其Shader修改为我们刚刚创建的``MaskColor.shader``：\n![MaskColor.mat](http://img.blog.csdn.net/20170214103401577)\n假如一切正常，更改后选中该材质球，在Inspecteor窗口查看其属性可以看到：\n![属性](http://img.blog.csdn.net/20170214103809974)\n- 4.将Avatar.png拖入到材质球的第一个Texture中，将Avatar_mask.png拖入到材质球的第二个Texture中，修改MyColor的色值，这个色值就是我们的遮罩目标染色值，可以在预览窗口看到染色结果：\n![](http://img.blog.csdn.net/20170214104456655)\n- 5.为了更加直观地观察到染色结果，可以使用NGUI在场景中创建一个UITexture，将``MaskColor.mat``拖到其Material属性中，即可在Game视窗中看到结果：\n![](http://img.blog.csdn.net/20170214105647261)\n- 6.加入要动态修改染色的颜色，通过代码对MyColor属性进行赋值：\n    ```C#\n    using UnityEngine;\n    using System.Collections;\n\n    public class TestColor : MonoBehaviour {\n        public UITexture texture;\n        // Use this for initialization\n        void Start () {\n            //染成紫色\n            texture.material.SetColor (\"_MyColor\", new Color(0.619f, 0.431f, 0.717f));\n        }\n    }\n    ```\n    得到新的染色结果:\n    ![](http://img.blog.csdn.net/20170214110324296)\n\n\t最终资源文件结构：\n\t![](http://img.blog.csdn.net/20170214111019580)\n\n####补充：\n其实，Shader中的图片也是可以通过代码动态替换的，将散图放在``Resources``文件夹下，然后通过``Resources.Load(资源路径);``进行动态获取，然后通过材质的方法``material.SetTexture``进行赋值。","source":"_posts/NGUI使用mask染色.md","raw":"---\ntitle: Unity——NGUI染色遮罩Sharer\ndate: 2017-02-14 10:57:00\ntags: Unity\ncategories: 游戏前端\nphotos:\n- http://img.blog.csdn.net/20170214103154480\n---\n\n>简述：\n遮罩的意思是指对原图被遮住的部分进行一定的处理，这里使用最简单的处理就是染色，所以我们需要创建一个遮罩层，通常使用另一个图片来作为遮罩层，也就是mask图。\n\n<!--more-->\n---\n###一、mask图的作用：\n跟UITexture使用的图片尺寸大小必须一致，将原图中需要被遮住（染色）的部分的位置在mask图中对应位置用纯色（例如：绿色（三原色的一种））涂满，学过flash动画的应该知道遮罩动画的原理，mask图其实就是一个遮罩层。\n\n---\n###二、sharer的实现思路：\n其实就是获取原图UITexture上的每个像素点，然后根据坐标位置去获取mask图UITexture对应位置上指定颜色值的有无，然后乘以透明度（.a属性），例如：mask图为绿色，这获取mask图像素点的.g属性值，加入不为0，则该像素点要染色，否则则不染色，具体该像素点要染成什么颜色可以通过变量传给shader。\n\n---\n###三、实例：\n下面是一个染色shader的代码：\n```cg\nShader \"Micro/TransparentMasked\" {\n\tProperties {\n\t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {}\n\t\t_MaskTex (\"Base (RGB)\", 2D) = \"white\" {}\n\t\t_MyColor (\"MyColor\", Color) = (0,0,1,1)\n\t}\n\t\n\tCategory\n\t{\t\n\t\tTags {\"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\"}\n\t\tLighting Off\n\t\tZWrite On\n\t\tBlend One Zero\n\t\tSubShader {\n\t\t\tPass {\n\t\t\t\tCGPROGRAM\n\t\t\t\t#pragma vertex vert_img\n\t\t\t\t#pragma fragment frag\n\t\n\t\t\t\t#include \"UnityCG.cginc\"\n\t\n\t\t\t\tuniform sampler2D _MainTex;\n\t\t\t\tuniform sampler2D _MaskTex;\n\t\t\t\tfloat4 _MyColor;\n\t\n\t\t\t\tfloat4 frag(v2f_img i) : COLOR \n\t\t\t\t{\n\t\t\t\t\tfloat4 layer = tex2D(_MainTex, i.uv);\t\t\t\t\t\n\t\t\t\t\tfloat4 mask = tex2D(_MaskTex, i.uv);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tfloat4 returnColor = layer;\n\n\t\t\t\t\tfloat gValue = max(0 ,mask.g - mask.b) * mask.a;\n\n\t\t\t\t\treturnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;\n\n\t\t\t\t\treturnColor.a = layer.a;\n\t\t\t\t\treturn returnColor;\n\t\t\t\t}\n\t\t\t\tENDCG\n\t\t\t}\n\t\t}\n\t}\n}\n```\n####1.输入声明：\n首先是输入的声明，这里我们需要明确进行此操作所需的输入有：原图（Texture）、遮罩图（Texture）、目标染色色值（float4），即可声明如下：\n```\n\t\t\t\tuniform sampler2D _MainTex;\n\t\t\t\tuniform sampler2D _MaskTex;\n\t\t\t\tfloat4 _MyColor;\n```\n\n####2.处理函数：\n关键部分在于每个像素点处理函数部分代码：\n```\nfloat4 frag(v2f_img i) : COLOR \n\t\t\t\t{\n\t\t\t\t\tfloat4 layer = tex2D(_MainTex, i.uv);\t\t\t\t\t\n\t\t\t\t\tfloat4 mask = tex2D(_MaskTex, i.uv);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tfloat4 returnColor = layer;\n\n\t\t\t\t\tfloat gValue = max(0 ,mask.g - mask.b) * mask.a;\n\n\t\t\t\t\treturnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;\n\n\t\t\t\t\treturnColor.a = layer.a;\n\t\t\t\t\treturn returnColor;\n\t\t\t\t}\n```\n####3.源码解析：\n接下来我们进行逐句解析：\n- 首先，我们需要将两张图片传入到shader中，用两个float4四元矩阵layer和mask来保存图片数据，每个像素点的数据都是一个float4值，即表示（r,b,g,a）——>（红，绿，蓝，透明度），其中layer是原图层，mask为遮罩层；\n- 通过``float gValue = max(0 ,mask.g - mask.b) * mask.a;``获得该像素点是否染色的状态；\n- 计算每个像素点染色之后的结果``returnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;``，计算得到每个像素点的输出值；\n- 透明度与原图保持一致``returnColor.a = layer.a;``。\n\n---\n###四、Unity实践：\n- 1.新建一个Shader文件，步骤：在Project窗口中右键->Create->Shader，内容为上边的源码，命名为``MaskColor.shader``：\n![MaskColor](http://img.blog.csdn.net/20170214103445766)\n- 2.导入两张图片，原图和mask图：\n![原图和mask图](http://img.blog.csdn.net/20170214103154480)\n- 3.新建一个材质球，步骤：在Project窗口中右键->Create->Material，取名为选中``MaskColor.mat``，选中次材质球，将其Shader修改为我们刚刚创建的``MaskColor.shader``：\n![MaskColor.mat](http://img.blog.csdn.net/20170214103401577)\n假如一切正常，更改后选中该材质球，在Inspecteor窗口查看其属性可以看到：\n![属性](http://img.blog.csdn.net/20170214103809974)\n- 4.将Avatar.png拖入到材质球的第一个Texture中，将Avatar_mask.png拖入到材质球的第二个Texture中，修改MyColor的色值，这个色值就是我们的遮罩目标染色值，可以在预览窗口看到染色结果：\n![](http://img.blog.csdn.net/20170214104456655)\n- 5.为了更加直观地观察到染色结果，可以使用NGUI在场景中创建一个UITexture，将``MaskColor.mat``拖到其Material属性中，即可在Game视窗中看到结果：\n![](http://img.blog.csdn.net/20170214105647261)\n- 6.加入要动态修改染色的颜色，通过代码对MyColor属性进行赋值：\n    ```C#\n    using UnityEngine;\n    using System.Collections;\n\n    public class TestColor : MonoBehaviour {\n        public UITexture texture;\n        // Use this for initialization\n        void Start () {\n            //染成紫色\n            texture.material.SetColor (\"_MyColor\", new Color(0.619f, 0.431f, 0.717f));\n        }\n    }\n    ```\n    得到新的染色结果:\n    ![](http://img.blog.csdn.net/20170214110324296)\n\n\t最终资源文件结构：\n\t![](http://img.blog.csdn.net/20170214111019580)\n\n####补充：\n其实，Shader中的图片也是可以通过代码动态替换的，将散图放在``Resources``文件夹下，然后通过``Resources.Load(资源路径);``进行动态获取，然后通过材质的方法``material.SetTexture``进行赋值。","slug":"NGUI使用mask染色","published":1,"updated":"2017-06-24T02:13:49.443Z","comments":1,"layout":"post","link":"","_id":"cj4anjfjn000f9gfj2usghmf4","content":"<blockquote>\n<p>简述：<br>遮罩的意思是指对原图被遮住的部分进行一定的处理，这里使用最简单的处理就是染色，所以我们需要创建一个遮罩层，通常使用另一个图片来作为遮罩层，也就是mask图。</p>\n</blockquote>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><p>###一、mask图的作用：<br>跟UITexture使用的图片尺寸大小必须一致，将原图中需要被遮住（染色）的部分的位置在mask图中对应位置用纯色（例如：绿色（三原色的一种））涂满，学过flash动画的应该知道遮罩动画的原理，mask图其实就是一个遮罩层。</p>\n<hr>\n<p>###二、sharer的实现思路：<br>其实就是获取原图UITexture上的每个像素点，然后根据坐标位置去获取mask图UITexture对应位置上指定颜色值的有无，然后乘以透明度（.a属性），例如：mask图为绿色，这获取mask图像素点的.g属性值，加入不为0，则该像素点要染色，否则则不染色，具体该像素点要染成什么颜色可以通过变量传给shader。</p>\n<hr>\n<p>###三、实例：<br>下面是一个染色shader的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">Shader &quot;Micro/TransparentMasked&quot; &#123;</div><div class=\"line\">\tProperties &#123;</div><div class=\"line\">\t\t_MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</div><div class=\"line\">\t\t_MaskTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</div><div class=\"line\">\t\t_MyColor (&quot;MyColor&quot;, Color) = (0,0,1,1)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tCategory</div><div class=\"line\">\t&#123;\t</div><div class=\"line\">\t\tTags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot;&#125;</div><div class=\"line\">\t\tLighting Off</div><div class=\"line\">\t\tZWrite On</div><div class=\"line\">\t\tBlend One Zero</div><div class=\"line\">\t\tSubShader &#123;</div><div class=\"line\">\t\t\tPass &#123;</div><div class=\"line\">\t\t\t\tCGPROGRAM</div><div class=\"line\">\t\t\t\t#pragma vertex vert_img</div><div class=\"line\">\t\t\t\t#pragma fragment frag</div><div class=\"line\">\t</div><div class=\"line\">\t\t\t\t#include &quot;UnityCG.cginc&quot;</div><div class=\"line\">\t</div><div class=\"line\">\t\t\t\tuniform sampler2D _MainTex;</div><div class=\"line\">\t\t\t\tuniform sampler2D _MaskTex;</div><div class=\"line\">\t\t\t\tfloat4 _MyColor;</div><div class=\"line\">\t</div><div class=\"line\">\t\t\t\tfloat4 frag(v2f_img i) : COLOR </div><div class=\"line\">\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\tfloat4 layer = tex2D(_MainTex, i.uv);\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\tfloat4 mask = tex2D(_MaskTex, i.uv);</div><div class=\"line\">\t\t\t\t\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\tfloat4 returnColor = layer;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\tfloat gValue = max(0 ,mask.g - mask.b) * mask.a;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\treturnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\treturnColor.a = layer.a;</div><div class=\"line\">\t\t\t\t\treturn returnColor;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tENDCG</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>####1.输入声明：<br>首先是输入的声明，这里我们需要明确进行此操作所需的输入有：原图（Texture）、遮罩图（Texture）、目标染色色值（float4），即可声明如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">uniform sampler2D _MainTex;</div><div class=\"line\">uniform sampler2D _MaskTex;</div><div class=\"line\">float4 _MyColor;</div></pre></td></tr></table></figure></p>\n<p>####2.处理函数：<br>关键部分在于每个像素点处理函数部分代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">float4 frag(v2f_img i) : COLOR </div><div class=\"line\">\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\tfloat4 layer = tex2D(_MainTex, i.uv);\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\tfloat4 mask = tex2D(_MaskTex, i.uv);</div><div class=\"line\">\t\t\t\t\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\tfloat4 returnColor = layer;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\tfloat gValue = max(0 ,mask.g - mask.b) * mask.a;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\treturnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\treturnColor.a = layer.a;</div><div class=\"line\">\t\t\t\t\treturn returnColor;</div><div class=\"line\">\t\t\t\t&#125;</div></pre></td></tr></table></figure></p>\n<p>####3.源码解析：<br>接下来我们进行逐句解析：</p>\n<ul>\n<li>首先，我们需要将两张图片传入到shader中，用两个float4四元矩阵layer和mask来保存图片数据，每个像素点的数据都是一个float4值，即表示（r,b,g,a）——&gt;（红，绿，蓝，透明度），其中layer是原图层，mask为遮罩层；</li>\n<li>通过<code>float gValue = max(0 ,mask.g - mask.b) * mask.a;</code>获得该像素点是否染色的状态；</li>\n<li>计算每个像素点染色之后的结果<code>returnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;</code>，计算得到每个像素点的输出值；</li>\n<li>透明度与原图保持一致<code>returnColor.a = layer.a;</code>。</li>\n</ul>\n<hr>\n<p>###四、Unity实践：</p>\n<ul>\n<li>1.新建一个Shader文件，步骤：在Project窗口中右键-&gt;Create-&gt;Shader，内容为上边的源码，命名为<code>MaskColor.shader</code>：<br><img src=\"http://img.blog.csdn.net/20170214103445766\" alt=\"MaskColor\"></li>\n<li>2.导入两张图片，原图和mask图：<br><img src=\"http://img.blog.csdn.net/20170214103154480\" alt=\"原图和mask图\"></li>\n<li>3.新建一个材质球，步骤：在Project窗口中右键-&gt;Create-&gt;Material，取名为选中<code>MaskColor.mat</code>，选中次材质球，将其Shader修改为我们刚刚创建的<code>MaskColor.shader</code>：<br><img src=\"http://img.blog.csdn.net/20170214103401577\" alt=\"MaskColor.mat\"><br>假如一切正常，更改后选中该材质球，在Inspecteor窗口查看其属性可以看到：<br><img src=\"http://img.blog.csdn.net/20170214103809974\" alt=\"属性\"></li>\n<li>4.将Avatar.png拖入到材质球的第一个Texture中，将Avatar_mask.png拖入到材质球的第二个Texture中，修改MyColor的色值，这个色值就是我们的遮罩目标染色值，可以在预览窗口看到染色结果：<br><img src=\"http://img.blog.csdn.net/20170214104456655\" alt=\"\"></li>\n<li>5.为了更加直观地观察到染色结果，可以使用NGUI在场景中创建一个UITexture，将<code>MaskColor.mat</code>拖到其Material属性中，即可在Game视窗中看到结果：<br><img src=\"http://img.blog.csdn.net/20170214105647261\" alt=\"\"></li>\n<li><p>6.加入要动态修改染色的颜色，通过代码对MyColor属性进行赋值：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;</div><div class=\"line\">using System.Collections;</div><div class=\"line\"></div><div class=\"line\">public class TestColor : MonoBehaviour &#123;</div><div class=\"line\">    public UITexture texture;</div><div class=\"line\">    // Use this for initialization</div><div class=\"line\">    void Start () &#123;</div><div class=\"line\">        //染成紫色</div><div class=\"line\">        texture.material.SetColor (&quot;_MyColor&quot;, new Color(0.619f, 0.431f, 0.717f));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  得到新的染色结果:<br>  <img src=\"http://img.blog.csdn.net/20170214110324296\" alt=\"\"></p>\n<p>  最终资源文件结构：<br>  <img src=\"http://img.blog.csdn.net/20170214111019580\" alt=\"\"></p>\n</li>\n</ul>\n<p>####补充：<br>其实，Shader中的图片也是可以通过代码动态替换的，将散图放在<code>Resources</code>文件夹下，然后通过<code>Resources.Load(资源路径);</code>进行动态获取，然后通过材质的方法<code>material.SetTexture</code>进行赋值。</p>\n","excerpt":"<blockquote>\n<p>简述：<br>遮罩的意思是指对原图被遮住的部分进行一定的处理，这里使用最简单的处理就是染色，所以我们需要创建一个遮罩层，通常使用另一个图片来作为遮罩层，也就是mask图。</p>\n</blockquote>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><p>###一、mask图的作用：<br>跟UITexture使用的图片尺寸大小必须一致，将原图中需要被遮住（染色）的部分的位置在mask图中对应位置用纯色（例如：绿色（三原色的一种））涂满，学过flash动画的应该知道遮罩动画的原理，mask图其实就是一个遮罩层。</p>\n<hr>\n<p>###二、sharer的实现思路：<br>其实就是获取原图UITexture上的每个像素点，然后根据坐标位置去获取mask图UITexture对应位置上指定颜色值的有无，然后乘以透明度（.a属性），例如：mask图为绿色，这获取mask图像素点的.g属性值，加入不为0，则该像素点要染色，否则则不染色，具体该像素点要染成什么颜色可以通过变量传给shader。</p>\n<hr>\n<p>###三、实例：<br>下面是一个染色shader的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">Shader &quot;Micro/TransparentMasked&quot; &#123;</div><div class=\"line\">\tProperties &#123;</div><div class=\"line\">\t\t_MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</div><div class=\"line\">\t\t_MaskTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</div><div class=\"line\">\t\t_MyColor (&quot;MyColor&quot;, Color) = (0,0,1,1)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tCategory</div><div class=\"line\">\t&#123;\t</div><div class=\"line\">\t\tTags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot;&#125;</div><div class=\"line\">\t\tLighting Off</div><div class=\"line\">\t\tZWrite On</div><div class=\"line\">\t\tBlend One Zero</div><div class=\"line\">\t\tSubShader &#123;</div><div class=\"line\">\t\t\tPass &#123;</div><div class=\"line\">\t\t\t\tCGPROGRAM</div><div class=\"line\">\t\t\t\t#pragma vertex vert_img</div><div class=\"line\">\t\t\t\t#pragma fragment frag</div><div class=\"line\">\t</div><div class=\"line\">\t\t\t\t#include &quot;UnityCG.cginc&quot;</div><div class=\"line\">\t</div><div class=\"line\">\t\t\t\tuniform sampler2D _MainTex;</div><div class=\"line\">\t\t\t\tuniform sampler2D _MaskTex;</div><div class=\"line\">\t\t\t\tfloat4 _MyColor;</div><div class=\"line\">\t</div><div class=\"line\">\t\t\t\tfloat4 frag(v2f_img i) : COLOR </div><div class=\"line\">\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\tfloat4 layer = tex2D(_MainTex, i.uv);\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\tfloat4 mask = tex2D(_MaskTex, i.uv);</div><div class=\"line\">\t\t\t\t\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\tfloat4 returnColor = layer;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\tfloat gValue = max(0 ,mask.g - mask.b) * mask.a;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\treturnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\treturnColor.a = layer.a;</div><div class=\"line\">\t\t\t\t\treturn returnColor;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tENDCG</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>####1.输入声明：<br>首先是输入的声明，这里我们需要明确进行此操作所需的输入有：原图（Texture）、遮罩图（Texture）、目标染色色值（float4），即可声明如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">uniform sampler2D _MainTex;</div><div class=\"line\">uniform sampler2D _MaskTex;</div><div class=\"line\">float4 _MyColor;</div></pre></td></tr></table></figure></p>\n<p>####2.处理函数：<br>关键部分在于每个像素点处理函数部分代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">float4 frag(v2f_img i) : COLOR </div><div class=\"line\">\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\tfloat4 layer = tex2D(_MainTex, i.uv);\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\tfloat4 mask = tex2D(_MaskTex, i.uv);</div><div class=\"line\">\t\t\t\t\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\tfloat4 returnColor = layer;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\tfloat gValue = max(0 ,mask.g - mask.b) * mask.a;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\treturnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\treturnColor.a = layer.a;</div><div class=\"line\">\t\t\t\t\treturn returnColor;</div><div class=\"line\">\t\t\t\t&#125;</div></pre></td></tr></table></figure></p>\n<p>####3.源码解析：<br>接下来我们进行逐句解析：</p>\n<ul>\n<li>首先，我们需要将两张图片传入到shader中，用两个float4四元矩阵layer和mask来保存图片数据，每个像素点的数据都是一个float4值，即表示（r,b,g,a）——&gt;（红，绿，蓝，透明度），其中layer是原图层，mask为遮罩层；</li>\n<li>通过<code>float gValue = max(0 ,mask.g - mask.b) * mask.a;</code>获得该像素点是否染色的状态；</li>\n<li>计算每个像素点染色之后的结果<code>returnColor = (returnColor * (1 - gValue)) + (_MyColor * returnColor) * gValue;</code>，计算得到每个像素点的输出值；</li>\n<li>透明度与原图保持一致<code>returnColor.a = layer.a;</code>。</li>\n</ul>\n<hr>\n<p>###四、Unity实践：</p>\n<ul>\n<li>1.新建一个Shader文件，步骤：在Project窗口中右键-&gt;Create-&gt;Shader，内容为上边的源码，命名为<code>MaskColor.shader</code>：<br><img src=\"http://img.blog.csdn.net/20170214103445766\" alt=\"MaskColor\"></li>\n<li>2.导入两张图片，原图和mask图：<br><img src=\"http://img.blog.csdn.net/20170214103154480\" alt=\"原图和mask图\"></li>\n<li>3.新建一个材质球，步骤：在Project窗口中右键-&gt;Create-&gt;Material，取名为选中<code>MaskColor.mat</code>，选中次材质球，将其Shader修改为我们刚刚创建的<code>MaskColor.shader</code>：<br><img src=\"http://img.blog.csdn.net/20170214103401577\" alt=\"MaskColor.mat\"><br>假如一切正常，更改后选中该材质球，在Inspecteor窗口查看其属性可以看到：<br><img src=\"http://img.blog.csdn.net/20170214103809974\" alt=\"属性\"></li>\n<li>4.将Avatar.png拖入到材质球的第一个Texture中，将Avatar_mask.png拖入到材质球的第二个Texture中，修改MyColor的色值，这个色值就是我们的遮罩目标染色值，可以在预览窗口看到染色结果：<br><img src=\"http://img.blog.csdn.net/20170214104456655\" alt=\"\"></li>\n<li>5.为了更加直观地观察到染色结果，可以使用NGUI在场景中创建一个UITexture，将<code>MaskColor.mat</code>拖到其Material属性中，即可在Game视窗中看到结果：<br><img src=\"http://img.blog.csdn.net/20170214105647261\" alt=\"\"></li>\n<li><p>6.加入要动态修改染色的颜色，通过代码对MyColor属性进行赋值：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;</div><div class=\"line\">using System.Collections;</div><div class=\"line\"></div><div class=\"line\">public class TestColor : MonoBehaviour &#123;</div><div class=\"line\">    public UITexture texture;</div><div class=\"line\">    // Use this for initialization</div><div class=\"line\">    void Start () &#123;</div><div class=\"line\">        //染成紫色</div><div class=\"line\">        texture.material.SetColor (&quot;_MyColor&quot;, new Color(0.619f, 0.431f, 0.717f));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  得到新的染色结果:<br>  <img src=\"http://img.blog.csdn.net/20170214110324296\" alt=\"\"></p>\n<p>  最终资源文件结构：<br>  <img src=\"http://img.blog.csdn.net/20170214111019580\" alt=\"\"></p>\n</li>\n</ul>\n<p>####补充：<br>其实，Shader中的图片也是可以通过代码动态替换的，将散图放在<code>Resources</code>文件夹下，然后通过<code>Resources.Load(资源路径);</code>进行动态获取，然后通过材质的方法<code>material.SetTexture</code>进行赋值。</p>"},{"title":"Next主题的fancybox展示图片","date":"2016-09-03T09:15:22.000Z","photos":["http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg","http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg"],"_content":"\n### 描述\n在创建的文章开头假如图片，并且支持点击放大功能，这是Next主题包含的一个功能。\n\n<!--more-->\n\n### 实现\n使用方法就是在开头匹配内容中假如```photos```字段，可以加图片链接列表：\n\n\t---\n\ttitle: Next主题的fancybox展示图片\n\tdate: 2016-09-03 17:15:22\n\ttags:\n\tphotos:\n\t- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n\t- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n\t---\n\n### 效果\n此案例的运行结果，如本文的开头所示。\n","source":"_posts/Next主题的fancybox展示图片.md","raw":"---\ntitle: Next主题的fancybox展示图片\ndate: 2016-09-03 17:15:22\ntags: Hexo,Next\ncategories: Web\nphotos:\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n---\n\n### 描述\n在创建的文章开头假如图片，并且支持点击放大功能，这是Next主题包含的一个功能。\n\n<!--more-->\n\n### 实现\n使用方法就是在开头匹配内容中假如```photos```字段，可以加图片链接列表：\n\n\t---\n\ttitle: Next主题的fancybox展示图片\n\tdate: 2016-09-03 17:15:22\n\ttags:\n\tphotos:\n\t- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n\t- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n\t---\n\n### 效果\n此案例的运行结果，如本文的开头所示。\n","slug":"Next主题的fancybox展示图片","published":1,"updated":"2017-06-24T02:13:49.446Z","comments":1,"layout":"post","link":"","_id":"cj4anjfjt000i9gfjpcbe27eq","content":"<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>在创建的文章开头假如图片，并且支持点击放大功能，这是Next主题包含的一个功能。</p>\n<a id=\"more\"></a>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>使用方法就是在开头匹配内容中假如<code>photos</code>字段，可以加图片链接列表：</p>\n<pre><code>---\ntitle: Next主题的fancybox展示图片\ndate: 2016-09-03 17:15:22\ntags:\nphotos:\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n---\n</code></pre><h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p>此案例的运行结果，如本文的开头所示。</p>\n","excerpt":"<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>在创建的文章开头假如图片，并且支持点击放大功能，这是Next主题包含的一个功能。</p>","more":"<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>使用方法就是在开头匹配内容中假如<code>photos</code>字段，可以加图片链接列表：</p>\n<pre><code>---\ntitle: Next主题的fancybox展示图片\ndate: 2016-09-03 17:15:22\ntags:\nphotos:\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n---\n</code></pre><h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p>此案例的运行结果，如本文的开头所示。</p>"},{"title":"Python Web 1 —— python和MongoDB安装","date":"2016-09-03T07:28:22.000Z","_content":"\n> 做了很长时间的客户端，主要从事过Android软件开发和Unity 3D的游戏开发，之前还看过一段时间的Java Web，但是由于没有实际的应用，所以就搁置了很久。最近突然有对服务器后台编程产生了浓厚的兴趣，想试着用Python + Mongo DB进行游戏后台的开发。\n\n### Python\nPython是一门具有强类型(即变量类型是强制要求的)、动态性、隐式类型(不需要做变量声明)、大小写敏感(var和VAR代表了不同的变量)以及面向对象等特点的编程语言。**Python是一种解释型的语言，相比于C语言，Python的运行速度慢，且不能进行加密。**\n<!--more-->\n\n#### 一、Python的安装：\n由于我使用的开发环境是Mac OS，所以自带了Python，但由于10.10自带的版本是2.7的，所以我们需要重新安装3.x的版本，安装方法：\n\n 1.没有安装Homebrew的先安装此Mac插件，安装方法就是打开终端，输入以下指令：\n```ruby\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n2.使用以下指令安装Python3：\n\n- 先查看当前计算机的python版本：**python**\n\n![这里写图片描述](http://img.blog.csdn.net/20160611163033678)\n- 安装新版本：**brew install python3**\n\n![这里写图片描述](http://img.blog.csdn.net/20160611163202196)\n这里我的安装出错了，出错不可怕，解决就好了，不难看出这个错误出现的原因是对/usr/local/share/man/man3目录的权限不够，那么解决方法：**sudo chown -R linshuhe /usr/local/share/man/man3**\n![这里写图片描述](http://img.blog.csdn.net/20160611172025531)\n但是，这里又出现了多版本的python共存和版本切换的问题了：\n![这里写图片描述](http://img.blog.csdn.net/20160611172635305)\n假如不想修改或者删除系统自带的python，我们可以直接通过以下方式指定使用哪个版本执行代码：\n![这里写图片描述](http://img.blog.csdn.net/20160611173455348)\n\n除了上述方法之外，还可以直接到官网下载最新版本，直接安装即可。\n \n____\n\n### Mongo DB\n#### 一、安装\n使用Homebrew进行安装是比较简单的安装方式：\n1.更新Homebrew:**brew update**\n![这里写图片描述](http://img.blog.csdn.net/20160610091546638)\n2.开始安装mongodb:**brew install mongodb**\n![这里写图片描述](http://img.blog.csdn.net/20160610091527985)\n3.根据安装完成最后的提示，启动mongodb:\n**mongod —config /usr/local/etc/mongod.conf**\n\n4.下载一个可视化管理工具Robomongo：下载的地址为：\nhttps://robomongo.org/download\n![这里写图片描述](http://img.blog.csdn.net/20160610091457232)\n____\n","source":"_posts/Python-Web-1-——-python和MongoDB安装.md","raw":"---\ntitle: Python Web 1 —— python和MongoDB安装\ndate: 2016-09-03 15:28:22\ntags: Python\ncategories: python\n---\n\n> 做了很长时间的客户端，主要从事过Android软件开发和Unity 3D的游戏开发，之前还看过一段时间的Java Web，但是由于没有实际的应用，所以就搁置了很久。最近突然有对服务器后台编程产生了浓厚的兴趣，想试着用Python + Mongo DB进行游戏后台的开发。\n\n### Python\nPython是一门具有强类型(即变量类型是强制要求的)、动态性、隐式类型(不需要做变量声明)、大小写敏感(var和VAR代表了不同的变量)以及面向对象等特点的编程语言。**Python是一种解释型的语言，相比于C语言，Python的运行速度慢，且不能进行加密。**\n<!--more-->\n\n#### 一、Python的安装：\n由于我使用的开发环境是Mac OS，所以自带了Python，但由于10.10自带的版本是2.7的，所以我们需要重新安装3.x的版本，安装方法：\n\n 1.没有安装Homebrew的先安装此Mac插件，安装方法就是打开终端，输入以下指令：\n```ruby\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n2.使用以下指令安装Python3：\n\n- 先查看当前计算机的python版本：**python**\n\n![这里写图片描述](http://img.blog.csdn.net/20160611163033678)\n- 安装新版本：**brew install python3**\n\n![这里写图片描述](http://img.blog.csdn.net/20160611163202196)\n这里我的安装出错了，出错不可怕，解决就好了，不难看出这个错误出现的原因是对/usr/local/share/man/man3目录的权限不够，那么解决方法：**sudo chown -R linshuhe /usr/local/share/man/man3**\n![这里写图片描述](http://img.blog.csdn.net/20160611172025531)\n但是，这里又出现了多版本的python共存和版本切换的问题了：\n![这里写图片描述](http://img.blog.csdn.net/20160611172635305)\n假如不想修改或者删除系统自带的python，我们可以直接通过以下方式指定使用哪个版本执行代码：\n![这里写图片描述](http://img.blog.csdn.net/20160611173455348)\n\n除了上述方法之外，还可以直接到官网下载最新版本，直接安装即可。\n \n____\n\n### Mongo DB\n#### 一、安装\n使用Homebrew进行安装是比较简单的安装方式：\n1.更新Homebrew:**brew update**\n![这里写图片描述](http://img.blog.csdn.net/20160610091546638)\n2.开始安装mongodb:**brew install mongodb**\n![这里写图片描述](http://img.blog.csdn.net/20160610091527985)\n3.根据安装完成最后的提示，启动mongodb:\n**mongod —config /usr/local/etc/mongod.conf**\n\n4.下载一个可视化管理工具Robomongo：下载的地址为：\nhttps://robomongo.org/download\n![这里写图片描述](http://img.blog.csdn.net/20160610091457232)\n____\n","slug":"Python-Web-1-——-python和MongoDB安装","published":1,"updated":"2017-06-24T02:13:49.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfjy000l9gfj06djy52o","content":"<blockquote>\n<p>做了很长时间的客户端，主要从事过Android软件开发和Unity 3D的游戏开发，之前还看过一段时间的Java Web，但是由于没有实际的应用，所以就搁置了很久。最近突然有对服务器后台编程产生了浓厚的兴趣，想试着用Python + Mongo DB进行游戏后台的开发。</p>\n</blockquote>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p>Python是一门具有强类型(即变量类型是强制要求的)、动态性、隐式类型(不需要做变量声明)、大小写敏感(var和VAR代表了不同的变量)以及面向对象等特点的编程语言。<strong>Python是一种解释型的语言，相比于C语言，Python的运行速度慢，且不能进行加密。</strong><br><a id=\"more\"></a></p>\n<h4 id=\"一、Python的安装：\"><a href=\"#一、Python的安装：\" class=\"headerlink\" title=\"一、Python的安装：\"></a>一、Python的安装：</h4><p>由于我使用的开发环境是Mac OS，所以自带了Python，但由于10.10自带的版本是2.7的，所以我们需要重新安装3.x的版本，安装方法：</p>\n<p> 1.没有安装Homebrew的先安装此Mac插件，安装方法就是打开终端，输入以下指令：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ruby -e <span class=\"string\">\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"</span></div></pre></td></tr></table></figure></p>\n<p>2.使用以下指令安装Python3：</p>\n<ul>\n<li>先查看当前计算机的python版本：<strong>python</strong></li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20160611163033678\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>安装新版本：<strong>brew install python3</strong></li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20160611163202196\" alt=\"这里写图片描述\"><br>这里我的安装出错了，出错不可怕，解决就好了，不难看出这个错误出现的原因是对/usr/local/share/man/man3目录的权限不够，那么解决方法：<strong>sudo chown -R linshuhe /usr/local/share/man/man3</strong><br><img src=\"http://img.blog.csdn.net/20160611172025531\" alt=\"这里写图片描述\"><br>但是，这里又出现了多版本的python共存和版本切换的问题了：<br><img src=\"http://img.blog.csdn.net/20160611172635305\" alt=\"这里写图片描述\"><br>假如不想修改或者删除系统自带的python，我们可以直接通过以下方式指定使用哪个版本执行代码：<br><img src=\"http://img.blog.csdn.net/20160611173455348\" alt=\"这里写图片描述\"></p>\n<p>除了上述方法之外，还可以直接到官网下载最新版本，直接安装即可。</p>\n<hr>\n<h3 id=\"Mongo-DB\"><a href=\"#Mongo-DB\" class=\"headerlink\" title=\"Mongo DB\"></a>Mongo DB</h3><h4 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h4><p>使用Homebrew进行安装是比较简单的安装方式：<br>1.更新Homebrew:<strong>brew update</strong><br><img src=\"http://img.blog.csdn.net/20160610091546638\" alt=\"这里写图片描述\"><br>2.开始安装mongodb:<strong>brew install mongodb</strong><br><img src=\"http://img.blog.csdn.net/20160610091527985\" alt=\"这里写图片描述\"><br>3.根据安装完成最后的提示，启动mongodb:<br><strong>mongod —config /usr/local/etc/mongod.conf</strong></p>\n<p>4.下载一个可视化管理工具Robomongo：下载的地址为：<br><a href=\"https://robomongo.org/download\" target=\"_blank\" rel=\"external\">https://robomongo.org/download</a><br><img src=\"http://img.blog.csdn.net/20160610091457232\" alt=\"这里写图片描述\"></p>\n<hr>\n","excerpt":"<blockquote>\n<p>做了很长时间的客户端，主要从事过Android软件开发和Unity 3D的游戏开发，之前还看过一段时间的Java Web，但是由于没有实际的应用，所以就搁置了很久。最近突然有对服务器后台编程产生了浓厚的兴趣，想试着用Python + Mongo DB进行游戏后台的开发。</p>\n</blockquote>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p>Python是一门具有强类型(即变量类型是强制要求的)、动态性、隐式类型(不需要做变量声明)、大小写敏感(var和VAR代表了不同的变量)以及面向对象等特点的编程语言。<strong>Python是一种解释型的语言，相比于C语言，Python的运行速度慢，且不能进行加密。</strong><br>","more":"</p>\n<h4 id=\"一、Python的安装：\"><a href=\"#一、Python的安装：\" class=\"headerlink\" title=\"一、Python的安装：\"></a>一、Python的安装：</h4><p>由于我使用的开发环境是Mac OS，所以自带了Python，但由于10.10自带的版本是2.7的，所以我们需要重新安装3.x的版本，安装方法：</p>\n<p> 1.没有安装Homebrew的先安装此Mac插件，安装方法就是打开终端，输入以下指令：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ruby -e <span class=\"string\">\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"</span></div></pre></td></tr></table></figure></p>\n<p>2.使用以下指令安装Python3：</p>\n<ul>\n<li>先查看当前计算机的python版本：<strong>python</strong></li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20160611163033678\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>安装新版本：<strong>brew install python3</strong></li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20160611163202196\" alt=\"这里写图片描述\"><br>这里我的安装出错了，出错不可怕，解决就好了，不难看出这个错误出现的原因是对/usr/local/share/man/man3目录的权限不够，那么解决方法：<strong>sudo chown -R linshuhe /usr/local/share/man/man3</strong><br><img src=\"http://img.blog.csdn.net/20160611172025531\" alt=\"这里写图片描述\"><br>但是，这里又出现了多版本的python共存和版本切换的问题了：<br><img src=\"http://img.blog.csdn.net/20160611172635305\" alt=\"这里写图片描述\"><br>假如不想修改或者删除系统自带的python，我们可以直接通过以下方式指定使用哪个版本执行代码：<br><img src=\"http://img.blog.csdn.net/20160611173455348\" alt=\"这里写图片描述\"></p>\n<p>除了上述方法之外，还可以直接到官网下载最新版本，直接安装即可。</p>\n<hr>\n<h3 id=\"Mongo-DB\"><a href=\"#Mongo-DB\" class=\"headerlink\" title=\"Mongo DB\"></a>Mongo DB</h3><h4 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h4><p>使用Homebrew进行安装是比较简单的安装方式：<br>1.更新Homebrew:<strong>brew update</strong><br><img src=\"http://img.blog.csdn.net/20160610091546638\" alt=\"这里写图片描述\"><br>2.开始安装mongodb:<strong>brew install mongodb</strong><br><img src=\"http://img.blog.csdn.net/20160610091527985\" alt=\"这里写图片描述\"><br>3.根据安装完成最后的提示，启动mongodb:<br><strong>mongod —config /usr/local/etc/mongod.conf</strong></p>\n<p>4.下载一个可视化管理工具Robomongo：下载的地址为：<br><a href=\"https://robomongo.org/download\">https://robomongo.org/download</a><br><img src=\"http://img.blog.csdn.net/20160610091457232\" alt=\"这里写图片描述\"></p>\n<hr>"},{"title":"Redis数据库","date":"2016-09-08T02:29:03.000Z","_content":"\n## Redis简介：\n**Redis**是一种常用的Nosql（Not Only SQL，非关系型）数据库，遵守BSD协议，是一个高性能的**key-value数据库**，一般用来代替Memcached做缓存服务，同时，它也支持数据的持久化。\n\n更详细的介绍可以查看[redis官网](http://redis.io/)，这里我们主要讲解一下如何安装和使用它。\n\n<!--more-->\n\nRedis相比于其他key-value缓存产品，具有以下特点：\n\n- 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；\n- 不仅支持简单的key-value类型的数据，还提供对于list、set、zset、hash等数据结构的存储；\n- 支持数据的备份，即master-slave模式的数据备份。\n\n## Redis的安装和配置：\n### 1.安装：\n这里我下载的是最新的版本3.2.3：[redis-3.2.3.tar.gz](http://download.redis.io/releases/redis-3.2.3.tar.gz)\n\n下载\n\n### 2.配置：\n\n\n\n## Redis的使用操作：\n### 1.启动：\n\n### 2.访问：\n\n### 3.关闭：","source":"_posts/Redis简介.md","raw":"---\ntitle: Redis数据库\ndate: 2016-09-08 10:29:03\ntags: Redis\ncategories: 数据库\n---\n\n## Redis简介：\n**Redis**是一种常用的Nosql（Not Only SQL，非关系型）数据库，遵守BSD协议，是一个高性能的**key-value数据库**，一般用来代替Memcached做缓存服务，同时，它也支持数据的持久化。\n\n更详细的介绍可以查看[redis官网](http://redis.io/)，这里我们主要讲解一下如何安装和使用它。\n\n<!--more-->\n\nRedis相比于其他key-value缓存产品，具有以下特点：\n\n- 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；\n- 不仅支持简单的key-value类型的数据，还提供对于list、set、zset、hash等数据结构的存储；\n- 支持数据的备份，即master-slave模式的数据备份。\n\n## Redis的安装和配置：\n### 1.安装：\n这里我下载的是最新的版本3.2.3：[redis-3.2.3.tar.gz](http://download.redis.io/releases/redis-3.2.3.tar.gz)\n\n下载\n\n### 2.配置：\n\n\n\n## Redis的使用操作：\n### 1.启动：\n\n### 2.访问：\n\n### 3.关闭：","slug":"Redis简介","published":1,"updated":"2017-06-24T02:13:49.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfk4000o9gfjrtble11z","content":"<h2 id=\"Redis简介：\"><a href=\"#Redis简介：\" class=\"headerlink\" title=\"Redis简介：\"></a>Redis简介：</h2><p><strong>Redis</strong>是一种常用的Nosql（Not Only SQL，非关系型）数据库，遵守BSD协议，是一个高性能的<strong>key-value数据库</strong>，一般用来代替Memcached做缓存服务，同时，它也支持数据的持久化。</p>\n<p>更详细的介绍可以查看<a href=\"http://redis.io/\" target=\"_blank\" rel=\"external\">redis官网</a>，这里我们主要讲解一下如何安装和使用它。</p>\n<a id=\"more\"></a>\n<p>Redis相比于其他key-value缓存产品，具有以下特点：</p>\n<ul>\n<li>支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；</li>\n<li>不仅支持简单的key-value类型的数据，还提供对于list、set、zset、hash等数据结构的存储；</li>\n<li>支持数据的备份，即master-slave模式的数据备份。</li>\n</ul>\n<h2 id=\"Redis的安装和配置：\"><a href=\"#Redis的安装和配置：\" class=\"headerlink\" title=\"Redis的安装和配置：\"></a>Redis的安装和配置：</h2><h3 id=\"1-安装：\"><a href=\"#1-安装：\" class=\"headerlink\" title=\"1.安装：\"></a>1.安装：</h3><p>这里我下载的是最新的版本3.2.3：<a href=\"http://download.redis.io/releases/redis-3.2.3.tar.gz\" target=\"_blank\" rel=\"external\">redis-3.2.3.tar.gz</a></p>\n<p>下载</p>\n<h3 id=\"2-配置：\"><a href=\"#2-配置：\" class=\"headerlink\" title=\"2.配置：\"></a>2.配置：</h3><h2 id=\"Redis的使用操作：\"><a href=\"#Redis的使用操作：\" class=\"headerlink\" title=\"Redis的使用操作：\"></a>Redis的使用操作：</h2><h3 id=\"1-启动：\"><a href=\"#1-启动：\" class=\"headerlink\" title=\"1.启动：\"></a>1.启动：</h3><h3 id=\"2-访问：\"><a href=\"#2-访问：\" class=\"headerlink\" title=\"2.访问：\"></a>2.访问：</h3><h3 id=\"3-关闭：\"><a href=\"#3-关闭：\" class=\"headerlink\" title=\"3.关闭：\"></a>3.关闭：</h3>","excerpt":"<h2 id=\"Redis简介：\"><a href=\"#Redis简介：\" class=\"headerlink\" title=\"Redis简介：\"></a>Redis简介：</h2><p><strong>Redis</strong>是一种常用的Nosql（Not Only SQL，非关系型）数据库，遵守BSD协议，是一个高性能的<strong>key-value数据库</strong>，一般用来代替Memcached做缓存服务，同时，它也支持数据的持久化。</p>\n<p>更详细的介绍可以查看<a href=\"http://redis.io/\">redis官网</a>，这里我们主要讲解一下如何安装和使用它。</p>","more":"<p>Redis相比于其他key-value缓存产品，具有以下特点：</p>\n<ul>\n<li>支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；</li>\n<li>不仅支持简单的key-value类型的数据，还提供对于list、set、zset、hash等数据结构的存储；</li>\n<li>支持数据的备份，即master-slave模式的数据备份。</li>\n</ul>\n<h2 id=\"Redis的安装和配置：\"><a href=\"#Redis的安装和配置：\" class=\"headerlink\" title=\"Redis的安装和配置：\"></a>Redis的安装和配置：</h2><h3 id=\"1-安装：\"><a href=\"#1-安装：\" class=\"headerlink\" title=\"1.安装：\"></a>1.安装：</h3><p>这里我下载的是最新的版本3.2.3：<a href=\"http://download.redis.io/releases/redis-3.2.3.tar.gz\">redis-3.2.3.tar.gz</a></p>\n<p>下载</p>\n<h3 id=\"2-配置：\"><a href=\"#2-配置：\" class=\"headerlink\" title=\"2.配置：\"></a>2.配置：</h3><h2 id=\"Redis的使用操作：\"><a href=\"#Redis的使用操作：\" class=\"headerlink\" title=\"Redis的使用操作：\"></a>Redis的使用操作：</h2><h3 id=\"1-启动：\"><a href=\"#1-启动：\" class=\"headerlink\" title=\"1.启动：\"></a>1.启动：</h3><h3 id=\"2-访问：\"><a href=\"#2-访问：\" class=\"headerlink\" title=\"2.访问：\"></a>2.访问：</h3><h3 id=\"3-关闭：\"><a href=\"#3-关闭：\" class=\"headerlink\" title=\"3.关闭：\"></a>3.关闭：</h3>"},{"title":"UE4笔记（1） 源码编译和安装","date":"2017-01-21T02:57:00.000Z","photos":["http://img.blog.csdn.net/20170121112115334"],"_content":">序言\n近来UE4渐渐有了抬头的趋势，并且因为其在VR游戏设计中表现突出的渲染性能而饱受开发者青睐，更令人惊叹不已的是这个引擎的源码是开源的，这对于希望研究引擎底层代码的码农来说，优秀得有点过分啦。\n\n<!--more-->\n\n---\n\n###一、引擎安装：\n关于引擎安装，其实有两种方式：\n- 通过官方提供的Laucher下载引擎、工具和资源，具体步骤：登录Epic Games账号后，打开[https://www.unrealengine.com/dashboard](https://www.unrealengine.com/dashboard)，在第一项中选择平台下载安装引擎所需的EpicGamesLauncherInstaller；\n![获取引擎](http://img.blog.csdn.net/20170116153109625)\n- 下载Github官方源码，然后使用Visual Studio进行编译得到引擎工具。\n\n###二、UE4源码下载：\n打开UE4的[官网](https://www.unrealengine.com)链接，注册一个Epic Games的个人账号。登录账号后，参考官方[如何链接您的Github账户以下载虚幻引擎4源代码](https://www.unrealengine.com/zh-CN/ue4-on-github)的相关说明，即可通过github下载完整的Unreal Engine源码。\n\n---\n\n###三、源码编译：\n下载源码后，解压到**不包含中文**的本地目录下：\n![目录结构](http://img.blog.csdn.net/20170116153304065)\n- 编译需要借助Visual Studio编程工具，所以需提前安装2013版或2012版的VS；\n- 在解压根目录找到``GenerateProjectFiles.bat``文件，双击此文件即可生成源码项目的``UE4.sh``文件；\n- 双击上述生成的.sh文件，会在VS中打开源码，带导入完毕，选中``UE4.sh``，``右键``->``生成``，等待编译完成。\n- 生成完毕之后，在当前源码根目录下，打开``Engine\\Binaries``，会有适用于不同平台的的文件夹，打开win64，打开``UE4Editor.exe``即可打开UE4编辑器。\n\n---\n\n###四、缺陷说明：\n使用源码编译的引擎工具有一点不足，那就是访问MarketPlace时必须通过Laucher，而只要安装并启动了官方的Laucher，则会自动下载最新的引擎工具包（大概7G），那此时机器上就会同时存在两个版本的UE4（官方Laucher下载安装的和自己编译得到的），不过使用官方Laucher在MarketPlace中下载的资源，在自己编译得到的引擎工具中是可以正常使用的。\n\n\n","source":"_posts/UE4源码编译安装.md","raw":"---\ntitle: UE4笔记（1） 源码编译和安装\ndate: 2017-01-21 10:57:00\ntags: UE4\ncategories: 游戏前端\nphotos:\n- http://img.blog.csdn.net/20170121112115334\n---\n>序言\n近来UE4渐渐有了抬头的趋势，并且因为其在VR游戏设计中表现突出的渲染性能而饱受开发者青睐，更令人惊叹不已的是这个引擎的源码是开源的，这对于希望研究引擎底层代码的码农来说，优秀得有点过分啦。\n\n<!--more-->\n\n---\n\n###一、引擎安装：\n关于引擎安装，其实有两种方式：\n- 通过官方提供的Laucher下载引擎、工具和资源，具体步骤：登录Epic Games账号后，打开[https://www.unrealengine.com/dashboard](https://www.unrealengine.com/dashboard)，在第一项中选择平台下载安装引擎所需的EpicGamesLauncherInstaller；\n![获取引擎](http://img.blog.csdn.net/20170116153109625)\n- 下载Github官方源码，然后使用Visual Studio进行编译得到引擎工具。\n\n###二、UE4源码下载：\n打开UE4的[官网](https://www.unrealengine.com)链接，注册一个Epic Games的个人账号。登录账号后，参考官方[如何链接您的Github账户以下载虚幻引擎4源代码](https://www.unrealengine.com/zh-CN/ue4-on-github)的相关说明，即可通过github下载完整的Unreal Engine源码。\n\n---\n\n###三、源码编译：\n下载源码后，解压到**不包含中文**的本地目录下：\n![目录结构](http://img.blog.csdn.net/20170116153304065)\n- 编译需要借助Visual Studio编程工具，所以需提前安装2013版或2012版的VS；\n- 在解压根目录找到``GenerateProjectFiles.bat``文件，双击此文件即可生成源码项目的``UE4.sh``文件；\n- 双击上述生成的.sh文件，会在VS中打开源码，带导入完毕，选中``UE4.sh``，``右键``->``生成``，等待编译完成。\n- 生成完毕之后，在当前源码根目录下，打开``Engine\\Binaries``，会有适用于不同平台的的文件夹，打开win64，打开``UE4Editor.exe``即可打开UE4编辑器。\n\n---\n\n###四、缺陷说明：\n使用源码编译的引擎工具有一点不足，那就是访问MarketPlace时必须通过Laucher，而只要安装并启动了官方的Laucher，则会自动下载最新的引擎工具包（大概7G），那此时机器上就会同时存在两个版本的UE4（官方Laucher下载安装的和自己编译得到的），不过使用官方Laucher在MarketPlace中下载的资源，在自己编译得到的引擎工具中是可以正常使用的。\n\n\n","slug":"UE4源码编译安装","published":1,"updated":"2017-06-24T02:13:49.455Z","comments":1,"layout":"post","link":"","_id":"cj4anjfkc000r9gfj7nk44ptb","content":"<blockquote>\n<p>序言<br>近来UE4渐渐有了抬头的趋势，并且因为其在VR游戏设计中表现突出的渲染性能而饱受开发者青睐，更令人惊叹不已的是这个引擎的源码是开源的，这对于希望研究引擎底层代码的码农来说，优秀得有点过分啦。</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<p>###一、引擎安装：<br>关于引擎安装，其实有两种方式：</p>\n<ul>\n<li>通过官方提供的Laucher下载引擎、工具和资源，具体步骤：登录Epic Games账号后，打开<a href=\"https://www.unrealengine.com/dashboard\" target=\"_blank\" rel=\"external\">https://www.unrealengine.com/dashboard</a>，在第一项中选择平台下载安装引擎所需的EpicGamesLauncherInstaller；<br><img src=\"http://img.blog.csdn.net/20170116153109625\" alt=\"获取引擎\"></li>\n<li>下载Github官方源码，然后使用Visual Studio进行编译得到引擎工具。</li>\n</ul>\n<p>###二、UE4源码下载：<br>打开UE4的<a href=\"https://www.unrealengine.com\" target=\"_blank\" rel=\"external\">官网</a>链接，注册一个Epic Games的个人账号。登录账号后，参考官方<a href=\"https://www.unrealengine.com/zh-CN/ue4-on-github\" target=\"_blank\" rel=\"external\">如何链接您的Github账户以下载虚幻引擎4源代码</a>的相关说明，即可通过github下载完整的Unreal Engine源码。</p>\n<hr>\n<p>###三、源码编译：<br>下载源码后，解压到<strong>不包含中文</strong>的本地目录下：<br><img src=\"http://img.blog.csdn.net/20170116153304065\" alt=\"目录结构\"></p>\n<ul>\n<li>编译需要借助Visual Studio编程工具，所以需提前安装2013版或2012版的VS；</li>\n<li>在解压根目录找到<code>GenerateProjectFiles.bat</code>文件，双击此文件即可生成源码项目的<code>UE4.sh</code>文件；</li>\n<li>双击上述生成的.sh文件，会在VS中打开源码，带导入完毕，选中<code>UE4.sh</code>，<code>右键</code>-&gt;<code>生成</code>，等待编译完成。</li>\n<li>生成完毕之后，在当前源码根目录下，打开<code>Engine\\Binaries</code>，会有适用于不同平台的的文件夹，打开win64，打开<code>UE4Editor.exe</code>即可打开UE4编辑器。</li>\n</ul>\n<hr>\n<p>###四、缺陷说明：<br>使用源码编译的引擎工具有一点不足，那就是访问MarketPlace时必须通过Laucher，而只要安装并启动了官方的Laucher，则会自动下载最新的引擎工具包（大概7G），那此时机器上就会同时存在两个版本的UE4（官方Laucher下载安装的和自己编译得到的），不过使用官方Laucher在MarketPlace中下载的资源，在自己编译得到的引擎工具中是可以正常使用的。</p>\n","excerpt":"<blockquote>\n<p>序言<br>近来UE4渐渐有了抬头的趋势，并且因为其在VR游戏设计中表现突出的渲染性能而饱受开发者青睐，更令人惊叹不已的是这个引擎的源码是开源的，这对于希望研究引擎底层代码的码农来说，优秀得有点过分啦。</p>\n</blockquote>","more":"<hr>\n<p>###一、引擎安装：<br>关于引擎安装，其实有两种方式：</p>\n<ul>\n<li>通过官方提供的Laucher下载引擎、工具和资源，具体步骤：登录Epic Games账号后，打开<a href=\"https://www.unrealengine.com/dashboard\">https://www.unrealengine.com/dashboard</a>，在第一项中选择平台下载安装引擎所需的EpicGamesLauncherInstaller；<br><img src=\"http://img.blog.csdn.net/20170116153109625\" alt=\"获取引擎\"></li>\n<li>下载Github官方源码，然后使用Visual Studio进行编译得到引擎工具。</li>\n</ul>\n<p>###二、UE4源码下载：<br>打开UE4的<a href=\"https://www.unrealengine.com\">官网</a>链接，注册一个Epic Games的个人账号。登录账号后，参考官方<a href=\"https://www.unrealengine.com/zh-CN/ue4-on-github\">如何链接您的Github账户以下载虚幻引擎4源代码</a>的相关说明，即可通过github下载完整的Unreal Engine源码。</p>\n<hr>\n<p>###三、源码编译：<br>下载源码后，解压到<strong>不包含中文</strong>的本地目录下：<br><img src=\"http://img.blog.csdn.net/20170116153304065\" alt=\"目录结构\"></p>\n<ul>\n<li>编译需要借助Visual Studio编程工具，所以需提前安装2013版或2012版的VS；</li>\n<li>在解压根目录找到<code>GenerateProjectFiles.bat</code>文件，双击此文件即可生成源码项目的<code>UE4.sh</code>文件；</li>\n<li>双击上述生成的.sh文件，会在VS中打开源码，带导入完毕，选中<code>UE4.sh</code>，<code>右键</code>-&gt;<code>生成</code>，等待编译完成。</li>\n<li>生成完毕之后，在当前源码根目录下，打开<code>Engine\\Binaries</code>，会有适用于不同平台的的文件夹，打开win64，打开<code>UE4Editor.exe</code>即可打开UE4编辑器。</li>\n</ul>\n<hr>\n<p>###四、缺陷说明：<br>使用源码编译的引擎工具有一点不足，那就是访问MarketPlace时必须通过Laucher，而只要安装并启动了官方的Laucher，则会自动下载最新的引擎工具包（大概7G），那此时机器上就会同时存在两个版本的UE4（官方Laucher下载安装的和自己编译得到的），不过使用官方Laucher在MarketPlace中下载的资源，在自己编译得到的引擎工具中是可以正常使用的。</p>"},{"title":"Unity ShaderLab基础（一）概述","date":"2016-09-05T06:20:07.000Z","_content":"\n## 什么是Shader?\n### 1.Shader的概念：\n**Shader**，即着色器，是一种运行在GPU上的程序，用来对三维物体进行着色处理、光和影的计算、纹理颜色的呈现等，从而将一个个作为抽象的几何数据存在的模型、场景和特效，以近似于真实世界的光与影的形式呈现出来。（简单点的理解就是：利用GPU编程使得构件出来的对象近似于真实世界中的对象呈现出来的处理）**通过Shader可以改变物体的形状、大小、位置以及旋转等**。\n<!--more-->\n\n### 2.Shader和Material的关系：\nShader负责将输入的Mesh(网格)以指定的方式和输入的贴图或者颜色等组合起来输出，绘图单元可以依据这个输出来将图像绘制在屏幕之上。输入的贴图或颜色，加上对应的Shader和Shader的特定参数设置，这些打包存储在一起就得到了一个Material。\n\n### 3.以面向对象的思想理解Shader：\n假设把Shader当做一个类，那么在对某个物体使用此Shader时，就需要实例化此Shader，得到一个对象，而**Material就相当于是一个Shader的对象**。\n\n### 4.Shader的分类：\nShader的基础类型有两种：**顶点Shader**和**片段Shader**，它们的特点：\n\n- **顶点Shader**：具有可以处理、变换，最终会渲染到屏幕上的网格物体的顶点位置的功能，但它不能生成新的顶点；\n- **片段Shader**：会对一个片段（预备像素）进行各种测试，如Z深度测试、Alpha比较测试，能通过各种测试的片段，最终会被写入渲染的输出帧中，从而成为屏幕上的一个可见像素。\n\n## GPU编程和Shader的编程语言\n### 1.GPU编程简介：\n**GPU**——Programmable Graphics Processing Unit，即可编程图形处理单元，也成为可编程图形硬件，至于GPU上的编程，实质上就是GPU允许应用程序指定一个序列的指令进行顶点操作控制\n\n### 2.Shader的编程语言：\nGPU与CPU是截然不同的，这不仅仅再其硬件结构的差异上，这也就决定了在两者运行环境下的编程过程也是不同的。目前面向GPU的编程，有**3种高级图像语言**，分别是：\n\n- 微软的 **HLST** (High Level Shading Language)，是通过Direct3D图形软件库来写Shader程序的语言；\n- OpenGL提供的 **GLSL** (OpenGL Shading Language)来写Shader程序；\n- NVIDIA提供的 **Cg** (C for graphics)语言（以HLST为基础，很相似），兼容Direct3D和OpenGL图形接口；\n\n考虑到最大化的跨平台支持，选择使用兼容性最高的 **Cg** 作为编写Shader的语言，但假如只针对Unity 3D引擎，也可以选择 **GLSL**。\n\n## 如何使用Cg编写Shader：\n在开始进行实际的编程之前，我们应该先清楚实现步骤，这就需要我们了解一下GPU进行图形绘制的操作步骤。\n\n### 1.GPU图形绘制：\n用图形绘制管线描述GPU渲染流程，即“给定视点、三维物体、光源、照明模式和纹理等元素，如何绘制一幅二维图像”。图像绘制其实分为三个阶段：**应用程序阶段**、**几何阶段**和**光栅阶段**：\n\n- **应用程序阶段**：使用高级语言（C、C++等）进行开发，主要和CPU、内存打交道，诸如：碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段。**在该阶段末端，几何体数据（顶点坐标、法向量、纹理等）通过数据总线传送给图形硬件**。\n- **几何阶段**：主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，该阶段基于GPU进行计算。**在该阶段末端，得到经过变换和投影之后的顶点坐标、颜色、以及纹理坐标**。\n- **光栅阶段**：基于几何阶段的输出数据，为像素（Pixel）正确配色，以便绘制完整图像，该阶段进行的都是单个像素的操作，每个像素的信息存储在颜色缓冲器（color buffer或者frame buffer）中。\n\n（例如：光照计算属于几何阶段、雾化以及涉及物体透明度的计算属于光栅阶段、深度信息（Z值）的计算属于几何阶段并传递给光栅阶段。）\n\n### 2.Unity中使用Cg写Shader：\n基本步骤如下：\n\n- 定义一些属性，用于指定此Shader将有哪些输入；\n- 定义一个或者多个子着色器，每个着色器中包含一个或者多个Pass；\n- 指定一个回滚，用于处理所有SubShader都不能运行的情况。 \n","source":"_posts/Unity-ShaderLab基础（一）.md","raw":"---\ntitle: Unity ShaderLab基础（一）概述\ndate: 2016-09-05 14:20:07\ntags: Unity,ShaderLab\ncategories: Unity\n---\n\n## 什么是Shader?\n### 1.Shader的概念：\n**Shader**，即着色器，是一种运行在GPU上的程序，用来对三维物体进行着色处理、光和影的计算、纹理颜色的呈现等，从而将一个个作为抽象的几何数据存在的模型、场景和特效，以近似于真实世界的光与影的形式呈现出来。（简单点的理解就是：利用GPU编程使得构件出来的对象近似于真实世界中的对象呈现出来的处理）**通过Shader可以改变物体的形状、大小、位置以及旋转等**。\n<!--more-->\n\n### 2.Shader和Material的关系：\nShader负责将输入的Mesh(网格)以指定的方式和输入的贴图或者颜色等组合起来输出，绘图单元可以依据这个输出来将图像绘制在屏幕之上。输入的贴图或颜色，加上对应的Shader和Shader的特定参数设置，这些打包存储在一起就得到了一个Material。\n\n### 3.以面向对象的思想理解Shader：\n假设把Shader当做一个类，那么在对某个物体使用此Shader时，就需要实例化此Shader，得到一个对象，而**Material就相当于是一个Shader的对象**。\n\n### 4.Shader的分类：\nShader的基础类型有两种：**顶点Shader**和**片段Shader**，它们的特点：\n\n- **顶点Shader**：具有可以处理、变换，最终会渲染到屏幕上的网格物体的顶点位置的功能，但它不能生成新的顶点；\n- **片段Shader**：会对一个片段（预备像素）进行各种测试，如Z深度测试、Alpha比较测试，能通过各种测试的片段，最终会被写入渲染的输出帧中，从而成为屏幕上的一个可见像素。\n\n## GPU编程和Shader的编程语言\n### 1.GPU编程简介：\n**GPU**——Programmable Graphics Processing Unit，即可编程图形处理单元，也成为可编程图形硬件，至于GPU上的编程，实质上就是GPU允许应用程序指定一个序列的指令进行顶点操作控制\n\n### 2.Shader的编程语言：\nGPU与CPU是截然不同的，这不仅仅再其硬件结构的差异上，这也就决定了在两者运行环境下的编程过程也是不同的。目前面向GPU的编程，有**3种高级图像语言**，分别是：\n\n- 微软的 **HLST** (High Level Shading Language)，是通过Direct3D图形软件库来写Shader程序的语言；\n- OpenGL提供的 **GLSL** (OpenGL Shading Language)来写Shader程序；\n- NVIDIA提供的 **Cg** (C for graphics)语言（以HLST为基础，很相似），兼容Direct3D和OpenGL图形接口；\n\n考虑到最大化的跨平台支持，选择使用兼容性最高的 **Cg** 作为编写Shader的语言，但假如只针对Unity 3D引擎，也可以选择 **GLSL**。\n\n## 如何使用Cg编写Shader：\n在开始进行实际的编程之前，我们应该先清楚实现步骤，这就需要我们了解一下GPU进行图形绘制的操作步骤。\n\n### 1.GPU图形绘制：\n用图形绘制管线描述GPU渲染流程，即“给定视点、三维物体、光源、照明模式和纹理等元素，如何绘制一幅二维图像”。图像绘制其实分为三个阶段：**应用程序阶段**、**几何阶段**和**光栅阶段**：\n\n- **应用程序阶段**：使用高级语言（C、C++等）进行开发，主要和CPU、内存打交道，诸如：碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段。**在该阶段末端，几何体数据（顶点坐标、法向量、纹理等）通过数据总线传送给图形硬件**。\n- **几何阶段**：主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，该阶段基于GPU进行计算。**在该阶段末端，得到经过变换和投影之后的顶点坐标、颜色、以及纹理坐标**。\n- **光栅阶段**：基于几何阶段的输出数据，为像素（Pixel）正确配色，以便绘制完整图像，该阶段进行的都是单个像素的操作，每个像素的信息存储在颜色缓冲器（color buffer或者frame buffer）中。\n\n（例如：光照计算属于几何阶段、雾化以及涉及物体透明度的计算属于光栅阶段、深度信息（Z值）的计算属于几何阶段并传递给光栅阶段。）\n\n### 2.Unity中使用Cg写Shader：\n基本步骤如下：\n\n- 定义一些属性，用于指定此Shader将有哪些输入；\n- 定义一个或者多个子着色器，每个着色器中包含一个或者多个Pass；\n- 指定一个回滚，用于处理所有SubShader都不能运行的情况。 \n","slug":"Unity-ShaderLab基础（一）","published":1,"updated":"2017-06-24T02:13:49.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfkh000u9gfjlnhvalj3","content":"<h2 id=\"什么是Shader\"><a href=\"#什么是Shader\" class=\"headerlink\" title=\"什么是Shader?\"></a>什么是Shader?</h2><h3 id=\"1-Shader的概念：\"><a href=\"#1-Shader的概念：\" class=\"headerlink\" title=\"1.Shader的概念：\"></a>1.Shader的概念：</h3><p><strong>Shader</strong>，即着色器，是一种运行在GPU上的程序，用来对三维物体进行着色处理、光和影的计算、纹理颜色的呈现等，从而将一个个作为抽象的几何数据存在的模型、场景和特效，以近似于真实世界的光与影的形式呈现出来。（简单点的理解就是：利用GPU编程使得构件出来的对象近似于真实世界中的对象呈现出来的处理）<strong>通过Shader可以改变物体的形状、大小、位置以及旋转等</strong>。<br><a id=\"more\"></a></p>\n<h3 id=\"2-Shader和Material的关系：\"><a href=\"#2-Shader和Material的关系：\" class=\"headerlink\" title=\"2.Shader和Material的关系：\"></a>2.Shader和Material的关系：</h3><p>Shader负责将输入的Mesh(网格)以指定的方式和输入的贴图或者颜色等组合起来输出，绘图单元可以依据这个输出来将图像绘制在屏幕之上。输入的贴图或颜色，加上对应的Shader和Shader的特定参数设置，这些打包存储在一起就得到了一个Material。</p>\n<h3 id=\"3-以面向对象的思想理解Shader：\"><a href=\"#3-以面向对象的思想理解Shader：\" class=\"headerlink\" title=\"3.以面向对象的思想理解Shader：\"></a>3.以面向对象的思想理解Shader：</h3><p>假设把Shader当做一个类，那么在对某个物体使用此Shader时，就需要实例化此Shader，得到一个对象，而<strong>Material就相当于是一个Shader的对象</strong>。</p>\n<h3 id=\"4-Shader的分类：\"><a href=\"#4-Shader的分类：\" class=\"headerlink\" title=\"4.Shader的分类：\"></a>4.Shader的分类：</h3><p>Shader的基础类型有两种：<strong>顶点Shader</strong>和<strong>片段Shader</strong>，它们的特点：</p>\n<ul>\n<li><strong>顶点Shader</strong>：具有可以处理、变换，最终会渲染到屏幕上的网格物体的顶点位置的功能，但它不能生成新的顶点；</li>\n<li><strong>片段Shader</strong>：会对一个片段（预备像素）进行各种测试，如Z深度测试、Alpha比较测试，能通过各种测试的片段，最终会被写入渲染的输出帧中，从而成为屏幕上的一个可见像素。</li>\n</ul>\n<h2 id=\"GPU编程和Shader的编程语言\"><a href=\"#GPU编程和Shader的编程语言\" class=\"headerlink\" title=\"GPU编程和Shader的编程语言\"></a>GPU编程和Shader的编程语言</h2><h3 id=\"1-GPU编程简介：\"><a href=\"#1-GPU编程简介：\" class=\"headerlink\" title=\"1.GPU编程简介：\"></a>1.GPU编程简介：</h3><p><strong>GPU</strong>——Programmable Graphics Processing Unit，即可编程图形处理单元，也成为可编程图形硬件，至于GPU上的编程，实质上就是GPU允许应用程序指定一个序列的指令进行顶点操作控制</p>\n<h3 id=\"2-Shader的编程语言：\"><a href=\"#2-Shader的编程语言：\" class=\"headerlink\" title=\"2.Shader的编程语言：\"></a>2.Shader的编程语言：</h3><p>GPU与CPU是截然不同的，这不仅仅再其硬件结构的差异上，这也就决定了在两者运行环境下的编程过程也是不同的。目前面向GPU的编程，有<strong>3种高级图像语言</strong>，分别是：</p>\n<ul>\n<li>微软的 <strong>HLST</strong> (High Level Shading Language)，是通过Direct3D图形软件库来写Shader程序的语言；</li>\n<li>OpenGL提供的 <strong>GLSL</strong> (OpenGL Shading Language)来写Shader程序；</li>\n<li>NVIDIA提供的 <strong>Cg</strong> (C for graphics)语言（以HLST为基础，很相似），兼容Direct3D和OpenGL图形接口；</li>\n</ul>\n<p>考虑到最大化的跨平台支持，选择使用兼容性最高的 <strong>Cg</strong> 作为编写Shader的语言，但假如只针对Unity 3D引擎，也可以选择 <strong>GLSL</strong>。</p>\n<h2 id=\"如何使用Cg编写Shader：\"><a href=\"#如何使用Cg编写Shader：\" class=\"headerlink\" title=\"如何使用Cg编写Shader：\"></a>如何使用Cg编写Shader：</h2><p>在开始进行实际的编程之前，我们应该先清楚实现步骤，这就需要我们了解一下GPU进行图形绘制的操作步骤。</p>\n<h3 id=\"1-GPU图形绘制：\"><a href=\"#1-GPU图形绘制：\" class=\"headerlink\" title=\"1.GPU图形绘制：\"></a>1.GPU图形绘制：</h3><p>用图形绘制管线描述GPU渲染流程，即“给定视点、三维物体、光源、照明模式和纹理等元素，如何绘制一幅二维图像”。图像绘制其实分为三个阶段：<strong>应用程序阶段</strong>、<strong>几何阶段</strong>和<strong>光栅阶段</strong>：</p>\n<ul>\n<li><strong>应用程序阶段</strong>：使用高级语言（C、C++等）进行开发，主要和CPU、内存打交道，诸如：碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段。<strong>在该阶段末端，几何体数据（顶点坐标、法向量、纹理等）通过数据总线传送给图形硬件</strong>。</li>\n<li><strong>几何阶段</strong>：主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，该阶段基于GPU进行计算。<strong>在该阶段末端，得到经过变换和投影之后的顶点坐标、颜色、以及纹理坐标</strong>。</li>\n<li><strong>光栅阶段</strong>：基于几何阶段的输出数据，为像素（Pixel）正确配色，以便绘制完整图像，该阶段进行的都是单个像素的操作，每个像素的信息存储在颜色缓冲器（color buffer或者frame buffer）中。</li>\n</ul>\n<p>（例如：光照计算属于几何阶段、雾化以及涉及物体透明度的计算属于光栅阶段、深度信息（Z值）的计算属于几何阶段并传递给光栅阶段。）</p>\n<h3 id=\"2-Unity中使用Cg写Shader：\"><a href=\"#2-Unity中使用Cg写Shader：\" class=\"headerlink\" title=\"2.Unity中使用Cg写Shader：\"></a>2.Unity中使用Cg写Shader：</h3><p>基本步骤如下：</p>\n<ul>\n<li>定义一些属性，用于指定此Shader将有哪些输入；</li>\n<li>定义一个或者多个子着色器，每个着色器中包含一个或者多个Pass；</li>\n<li>指定一个回滚，用于处理所有SubShader都不能运行的情况。 </li>\n</ul>\n","excerpt":"<h2 id=\"什么是Shader\"><a href=\"#什么是Shader\" class=\"headerlink\" title=\"什么是Shader?\"></a>什么是Shader?</h2><h3 id=\"1-Shader的概念：\"><a href=\"#1-Shader的概念：\" class=\"headerlink\" title=\"1.Shader的概念：\"></a>1.Shader的概念：</h3><p><strong>Shader</strong>，即着色器，是一种运行在GPU上的程序，用来对三维物体进行着色处理、光和影的计算、纹理颜色的呈现等，从而将一个个作为抽象的几何数据存在的模型、场景和特效，以近似于真实世界的光与影的形式呈现出来。（简单点的理解就是：利用GPU编程使得构件出来的对象近似于真实世界中的对象呈现出来的处理）<strong>通过Shader可以改变物体的形状、大小、位置以及旋转等</strong>。<br>","more":"</p>\n<h3 id=\"2-Shader和Material的关系：\"><a href=\"#2-Shader和Material的关系：\" class=\"headerlink\" title=\"2.Shader和Material的关系：\"></a>2.Shader和Material的关系：</h3><p>Shader负责将输入的Mesh(网格)以指定的方式和输入的贴图或者颜色等组合起来输出，绘图单元可以依据这个输出来将图像绘制在屏幕之上。输入的贴图或颜色，加上对应的Shader和Shader的特定参数设置，这些打包存储在一起就得到了一个Material。</p>\n<h3 id=\"3-以面向对象的思想理解Shader：\"><a href=\"#3-以面向对象的思想理解Shader：\" class=\"headerlink\" title=\"3.以面向对象的思想理解Shader：\"></a>3.以面向对象的思想理解Shader：</h3><p>假设把Shader当做一个类，那么在对某个物体使用此Shader时，就需要实例化此Shader，得到一个对象，而<strong>Material就相当于是一个Shader的对象</strong>。</p>\n<h3 id=\"4-Shader的分类：\"><a href=\"#4-Shader的分类：\" class=\"headerlink\" title=\"4.Shader的分类：\"></a>4.Shader的分类：</h3><p>Shader的基础类型有两种：<strong>顶点Shader</strong>和<strong>片段Shader</strong>，它们的特点：</p>\n<ul>\n<li><strong>顶点Shader</strong>：具有可以处理、变换，最终会渲染到屏幕上的网格物体的顶点位置的功能，但它不能生成新的顶点；</li>\n<li><strong>片段Shader</strong>：会对一个片段（预备像素）进行各种测试，如Z深度测试、Alpha比较测试，能通过各种测试的片段，最终会被写入渲染的输出帧中，从而成为屏幕上的一个可见像素。</li>\n</ul>\n<h2 id=\"GPU编程和Shader的编程语言\"><a href=\"#GPU编程和Shader的编程语言\" class=\"headerlink\" title=\"GPU编程和Shader的编程语言\"></a>GPU编程和Shader的编程语言</h2><h3 id=\"1-GPU编程简介：\"><a href=\"#1-GPU编程简介：\" class=\"headerlink\" title=\"1.GPU编程简介：\"></a>1.GPU编程简介：</h3><p><strong>GPU</strong>——Programmable Graphics Processing Unit，即可编程图形处理单元，也成为可编程图形硬件，至于GPU上的编程，实质上就是GPU允许应用程序指定一个序列的指令进行顶点操作控制</p>\n<h3 id=\"2-Shader的编程语言：\"><a href=\"#2-Shader的编程语言：\" class=\"headerlink\" title=\"2.Shader的编程语言：\"></a>2.Shader的编程语言：</h3><p>GPU与CPU是截然不同的，这不仅仅再其硬件结构的差异上，这也就决定了在两者运行环境下的编程过程也是不同的。目前面向GPU的编程，有<strong>3种高级图像语言</strong>，分别是：</p>\n<ul>\n<li>微软的 <strong>HLST</strong> (High Level Shading Language)，是通过Direct3D图形软件库来写Shader程序的语言；</li>\n<li>OpenGL提供的 <strong>GLSL</strong> (OpenGL Shading Language)来写Shader程序；</li>\n<li>NVIDIA提供的 <strong>Cg</strong> (C for graphics)语言（以HLST为基础，很相似），兼容Direct3D和OpenGL图形接口；</li>\n</ul>\n<p>考虑到最大化的跨平台支持，选择使用兼容性最高的 <strong>Cg</strong> 作为编写Shader的语言，但假如只针对Unity 3D引擎，也可以选择 <strong>GLSL</strong>。</p>\n<h2 id=\"如何使用Cg编写Shader：\"><a href=\"#如何使用Cg编写Shader：\" class=\"headerlink\" title=\"如何使用Cg编写Shader：\"></a>如何使用Cg编写Shader：</h2><p>在开始进行实际的编程之前，我们应该先清楚实现步骤，这就需要我们了解一下GPU进行图形绘制的操作步骤。</p>\n<h3 id=\"1-GPU图形绘制：\"><a href=\"#1-GPU图形绘制：\" class=\"headerlink\" title=\"1.GPU图形绘制：\"></a>1.GPU图形绘制：</h3><p>用图形绘制管线描述GPU渲染流程，即“给定视点、三维物体、光源、照明模式和纹理等元素，如何绘制一幅二维图像”。图像绘制其实分为三个阶段：<strong>应用程序阶段</strong>、<strong>几何阶段</strong>和<strong>光栅阶段</strong>：</p>\n<ul>\n<li><strong>应用程序阶段</strong>：使用高级语言（C、C++等）进行开发，主要和CPU、内存打交道，诸如：碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段。<strong>在该阶段末端，几何体数据（顶点坐标、法向量、纹理等）通过数据总线传送给图形硬件</strong>。</li>\n<li><strong>几何阶段</strong>：主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，该阶段基于GPU进行计算。<strong>在该阶段末端，得到经过变换和投影之后的顶点坐标、颜色、以及纹理坐标</strong>。</li>\n<li><strong>光栅阶段</strong>：基于几何阶段的输出数据，为像素（Pixel）正确配色，以便绘制完整图像，该阶段进行的都是单个像素的操作，每个像素的信息存储在颜色缓冲器（color buffer或者frame buffer）中。</li>\n</ul>\n<p>（例如：光照计算属于几何阶段、雾化以及涉及物体透明度的计算属于光栅阶段、深度信息（Z值）的计算属于几何阶段并传递给光栅阶段。）</p>\n<h3 id=\"2-Unity中使用Cg写Shader：\"><a href=\"#2-Unity中使用Cg写Shader：\" class=\"headerlink\" title=\"2.Unity中使用Cg写Shader：\"></a>2.Unity中使用Cg写Shader：</h3><p>基本步骤如下：</p>\n<ul>\n<li>定义一些属性，用于指定此Shader将有哪些输入；</li>\n<li>定义一个或者多个子着色器，每个着色器中包含一个或者多个Pass；</li>\n<li>指定一个回滚，用于处理所有SubShader都不能运行的情况。 </li>\n</ul>"},{"title":"Unity ShaderLab基础（三）Unity创建一个Shader","date":"2016-09-07T07:32:31.000Z","_content":"Unity引擎是一个非常强大的支持跨平台开发的游戏引擎，基于Mono这个开源.Net的框架设计而成，在Unity中定义了**ShaderLab**来组织Shader的内容，针对不同平台进行编译。了解了Shader和Cg的一些基础知识之后，接下来我们要做的就是：学会如何在Unity中使用Cg编写Shader并实现一些简单的Shader效果。\n\n<!--more-->\n\n## Unity Shader：\n说到底，Shader其实只是一段规定好输入（颜色，贴图等）和输出（渲染器能读懂的点和颜色的对应关系）的程序。那么，**设计一个Shader的过程其实就是根据输入，进行计算变换从而产生输出而已**。\n\n### 1.分类：\n在Unity中的Shader分为两类：\n\n- **表面着色器**（Surface Shader）:已经为我们完成了大部分的工作，只需要简单的操作即可得到不错的效果；\n- **片段着色器**（Fragment Shader）:可以自己设计出很多东西，因为可自行设置的内容更多，但也更加难写。使用片段着色器的目的是可以在更加底层进行更复杂（或者针对目标设备更高效）的开发。\n\n### 2.Shader程序基本结构：\n使用Unity中的框架来编写Shader程序，其实相对于其他游戏引擎要简单一些，在Cocos2d中还得从OpenGL层面开始编写逻辑，但是在Unity只需要往框架中填入需要控制的内容即可，一个Shader程序的基本结构如下图所示：\n\n![](http://i.imgur.com/a6T9fF8.png)\n\n- 首先，定义一些属性，用来指定代码将有哪些输入；\n- 其次，会有一个或者多个子着色器，但是在实际运行中哪一个子着色器被使用是由运行的平台所决定的；\n- 子着色器是代码的主体，每个子着色器包含一个或多个Pass；\n- 最后指定一个回滚，用来处理所有Subshader都不能运行的情况（比如设备太老）。\n\n执行着色时，平台选择最优先可以使用的子着色器，然后依次执行该子着色器中的Pass，然后输出结果。\n\n\n### 3.Unity创建第一个Shader：\n在Unity的Project面板中，``右键``-``Create``-``Shader``，取名为``Diffuse_Texture``，使用VS打开可以查看新建的Shader的内容如下所示：\n\n```C#\n\tShader \"Custom/Diffuse_Texture\" {\n\t\tProperties {\n\t\t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {}\n\t\t}\n\t\tSubShader {\n\t\t\tTags { \"RenderType\"=\"Opaque\" }\n\t\t\tLOD 200\n\t\t\t\n\t\t\tCGPROGRAM\n\t\t\t#pragma surface surf Lambert\n\t\n\t\t\tsampler2D _MainTex;\n\t\n\t\t\tstruct Input {\n\t\t\t\tfloat2 uv_MainTex;\n\t\t\t};\n\t\n\t\t\tvoid surf (Input IN, inout SurfaceOutput o) {\n\t\t\t\thalf4 c = tex2D (_MainTex, IN.uv_MainTex);\n\t\t\t\to.Albedo = c.rgb;\n\t\t\t\to.Alpha = c.a;\n\t\t\t}\n\t\t\tENDCG\n\t\t} \n\t\tFallBack \"Diffuse\"\n\t}\n```\n\n接下来我们要做的，就是解析这个Shader中每一行的含义和作用，包括了属性、Tags、LOD、光照模型等。\n\n#### **解析：**\n第一行指定了此Shader的名字，严格来说是指定了它的路径，在材质面板中选择Shader时，我们可以根据这个路径找到此Shader。\n\n#### **属性**\n\n在``Properties{}``块中定义的内容就是着色器的属性，【可以理解为一些CPU语言例如java类在开始处定义的一些属性（全局变量或常量）】，**这些属性将作为输入提供给所有的子着色器**。每个属性定义的语法：\n```C#\n\t_Name(\"Display_Name\",type) = defaultValue[{options}]\n```\n* ``_Name``：属性的名称，或者理解为变量名，在之后整个\tShader代码中通过此名称获取属性内容；\n- ``Display_Name``：此字符串是Shader在Unity的材质编辑器中作为Shader可视化信息；\n* ``type``：此属性的类型，Unity中支持的类型有：\n   - Color：颜色，由RGBA(红绿蓝和透明度)四个量定义；\n   - 2D：一张2的阶数大小（256，512等）的贴图，此贴图将在采样后被转为对应基于模型UV的每个像素的颜色，最终显示出来；\n   - Rect：一个非2阶数大小的贴图；\n   - Cube：即Cub map texture(立方体纹理)，即6张有联系的2D贴图的组合，主要用来做**反射效果**（比如：天空盒和动态反射），也会被转换为对应点的采样；\n   - Range(min,max)：一个介于最大值max和最小值min之间的浮点数，一般用作调整Shader某些特性的参数（例如：透明度从0到1）；\n   - Float：一个浮点数；\n   - Vector：一个四维数；\n* ``defaultValue``：定义的这个属性的默认值或者初始值，但不同属性类型的默认值格式不同，例如：\n   - Color：咦0~1定义的rgba颜色，可以赋值(1,1,1,1);\n   - 2D/Rect/Cube：贴图默认值需要是一个代表tini颜色的字符串，可以是空字符串或者\"white\",\"black\",\"gray\",\"bump\"中的一个；\n   - Float、Range：任意浮点数即可；\n   - Vector：四维数，格式(x,y,z,w)；\n* ``{option}``：只对2D、Rect和Cube贴图有关，初始值至少要在贴图后面写一对空白的``{}``，当需要打开特定选项时可以吧其写入到此花括号中，多个选项以空白分隔。可能的选项：ObjectLinear, EyeLinear, SphereMap, CubeReflect, CubeNormal，这些都是OpenGL中TexGen的模式。\n\n**例子：**\n\n```C#\n\t//颜色输入\n\t_MainColor (\"Main Color\", Color) = (0,0.5,1,0.5)\n\t//2的阶数大小的贴图输入\n\t_Texture (\"Texture\", 2D) = \"white\" {}\n```\n\n#### **Subshader**\n上面已经解析了Shader代码的第一部分，接下来我们要将的就是Shader的代码主体，即SubShader的内容，在``SubShader{}``中的内容就是一个SubShader。\n\n##### **(1) Tags**\nSubShader中的第一句就是：\n```C#\nTags { \"RenderType\"=\"Opaque\" }\n```\n这是SubShader的标签，因为表面着色器可以被若干个标签（tags）所修饰，而**硬件正是通过判定这些标签（Tags）来决定什么时候调用该着色器**。所以，我们例子中的这一句``\"RenderType\"=\"Opaque\"``的意思：告诉系统应该在渲染非透明物体时调用此SubShader，这与RenderType是Opaque是相对应的。\n\n此外，**Tags其实也暗示了此Shader的输出情况**，例如：输出中都是半透明的物体，那就写在Opaque里；如果想渲染透明或者半透明的像素，那就应该写在Transparent里。\n\n另外比较有用的标签还有：\n\n- ``\"IgnoreProjector\"=\"True\"``：不被Projects影响；\n- ``\"ForceNoShadowCasting\"=\"True\"``：从不产生阴影；\n- ``\"Queue\"=\"xxx\"``：**指定渲染顺序队列**。在Unity中，如果需要进行透明和不透明物体混合时，可能会遇到不透明物体无法呈现在透明物体之后的情况，这是由于Shader的渲染顺序不正确导致的。Queue指定物体渲染顺序，预定义的Queue有：\n\t- Background：最早被调用的渲染，用于渲染天空盒或者背景；\n\t- Geometry：默认值，用来渲染非透明的物体；\n\t- AlphaTest：用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑；\n\t- Transparent：以后从后往前的顺序渲染透明物体；\n\t- Overlay：用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）；\n\n以上这些预定义的值，本质上是一组定义**整数**，Background = 1000， Geometry = 2000, AlphaTest = 2450， Transparent = 3000，最后Overlay = 4000。当然，在实际设置Queue值时，不仅可以使用上述的预定义值，还可以指定自己的Queue值，例如：``\"Queue\"=\"Transparent+100\"``，表示一个在Transparent之后100的Queue上进行调用。\n\n**通过调整Queue值，我们可以确保某些物体一定在另一个物体之前或之后被渲染**。\n\n##### **(2) LOD**\n第二行中的内容：\n\n```C#\n\tLOD 200\n```\n\nLOD，即Level of Detail，这其实是**Unity的内建Diffuse着色器的设定值，决定了我们能够用什么样的Shader**。在Unity的Quality Settings中，我们可以设置允许的最大LOD，当设定的LOD小于SubShader的LOD时，这个SubShader将不可用。\n\nUnity内建Shader定义了一组LOD的数值，我们在实现自己的Shader的时候可以将其作为参考来设定自己的LOD数值，这样在之后调整根据设备图形性能来调整画质时可以进行比较精确的控制。\n\n- VertexLit及其系列 = 100\n- Decal, Reflective VertexLit = 150\n- Diffuse = 200\n- Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit = 250\n- Bumped, Specular = 300\n- Bumped Specular = 400\n- Parallax = 500\n- Parallax Specular = 600\n\n##### **(2) CGPROGRAM...ENDCG**\n用``CGPROGRAM``开始和``ENDCG``结束，表明这部分是Cg代码。这是SubShader的主体部分，我们前面已经提到了属性中定义了此Shader的输入，那么此处代码的作用，便是对输入进行处理，并输出。接下来我们逐句进行解析：\n\n- ``#pragma surface surf Lambert``：这是一个编译指令，声明此Shader是一个表面着色器，并指定了着色器的自动调用的函数名称为surf,而且指定光照模型为Lambert(普通的diffuse)，它的一般语法如下：\n\n```CG\n#pragma surface surfaceFunction lightModel [optionalparams]\n```\n\n   - surface：声明的是一个表面着色器\n   - surfaceFunction：着色器代码的方法名称，着色器其作用时被调用\n   - lightModel：使用的光照模型\n\n---\n\n- ``sampler2D _MainTex;``：其中``sampler2D``是GLSL中2D贴图的类型，类似的还有sampler1D、sampler3D、samplerCube等格式，主要用于存储texture数据。``_MainTex``是与之前在Proterties属性模块中声明的图贴所对应的，因为这个Shader是由两个独立的程序块组成的：外部的属性声明和回滚等Unity可以直接使用和编译的ShaderLab；而在``CGPROGRAM...ENDCG``中的代码块，是一段CG程序。**假如要在CG程序中访问Proterties中所定义的变量，必须使用和之前的变量相同的名字进行声明**。所以此句Cg代码的作用就是**再次声明并链接_MainTex，使接下来的Cg程序能够使用此变量**。\n\t\n---\n- Input结构体：这其实是用来把需要参与计算的数据封装起来，然后作为输入参数传入到下面surf函数中使用的，而且必须以``Input``命名。\n\n```\nstruct Input {\n\tfloat2 uv_MainTex;\n};\n```\n这里我们的Input结构体很简单，只是定义了一个float2类型的变量，这是Cg的数据类型，表示2个float类型的数据打包在一起，所以此处``uv_MainTex``表示的就是包含两个浮点数的变量，类似的还有float3和float4。\n\n这里以uv作为前缀，其实UV mapping的作用是将一个2D贴图上的点按照一定规律映射到3D模型上，是3D渲染中最常见的一种顶点处理手段。所以在Cg中，在一个贴图变量（例如这里的_MainTex）前面加上uv，表示提取它的uv值（其实就是两个代表贴图上点的二维坐标）。后面的**surf函数中直接通过访问uv_MainTex来去的这张贴图当前需要计算的点的坐标值**。\n\n---\n\n- surf函数：这是在之前``#progma``中指定的着色器的调用方法，这也是着色器最核心的部分，这个方法的定义需要按照规定：**第一个参数是一个Input结构，第二个参数是一个inout的SurfaceOutput结构**。\n```\nvoid surf (Input IN, inout SurfaceOutput o) {\n\thalf4 c = tex2D (_MainTex, IN.uv_MainTex);\n\to.Albedo = c.rgb;\n\to.Alpha = c.a;\n}\n```\n上面已经说过了Input结构体的定义和使用，**在计算输出时，Shader会多次调用surf函数，每次给入一个贴图上的点坐标，用来计算输出**。\n\nsurf的第二个参数是一个可写的``SurfaceOutput``，SurfaceOutput是一个预定义的输出结构，我们的surf函数的目标就是根据输入把这个输出结构填上。SurfaceOutput结构体的定义如下：\n```bash\nstruct SurfaceOutput {\n    half3 Albedo;     //像素的颜色\n    half3 Normal;     //像素的法向值\n    half3 Emission;   //像素的发散颜色\n    half Specular;    //像素的镜面高光\n    half Gloss;       //像素的发光强度\n    half Alpha;       //像素的透明度\n};\n```\nhalf其实跟float与double类似，都是浮点数，只是精度不同，half称为半精度浮点数。\n\n这个例子中，surf的代码如下：\n```bash\n\thalf4 c = tex2D (_MainTex, IN.uv_MainTex);\n\to.Albedo = c.rgb;\n\to.Alpha = c.a;\n```\n这里的``tex2D``函数是Cg中用来在一张贴图中对点进行采样的方法，返回一个float4。这里，我们队_MainTex在输入点上进行采样，并将其颜色的rgb值``c.rgb``赋给输出的像素颜色``o.Albedo``，将透明度``c.a``赋值给输出像素透明度``o.Alpha``。\n\n\n#### 参考链接：\n\n- 了解Shader的基础知识：[猫都能学会的Unity3D Shader入门指南（一）](https://onevcat.com/2013/07/shader-tutorial-1/)\n- Unity官方关于Shader的一些资料：[Materials, Shaders & Textures](https://docs.unity3d.com/Manual/Shaders.html)\n- 了解Shader的机制：[【Unity Shaders】初探Surface Shader背后的机制](http://blog.csdn.net/candycat1992/article/details/39994049)\n\n#### 推荐书籍：\n\n- 《Unity Shader and Effect Cookbook》，中文版：《Unity着色器和屏幕特效开发秘笈》\n- 《GPU 编程与CG 语言之阳春白雪下里巴人》","source":"_posts/Unity-ShaderLab基础（三）.md","raw":"---\ntitle: Unity ShaderLab基础（三）Unity创建一个Shader\ndate: 2016-09-07 15:32:31\ntags: Unity,ShaderLab\ncategories: Unity\n---\nUnity引擎是一个非常强大的支持跨平台开发的游戏引擎，基于Mono这个开源.Net的框架设计而成，在Unity中定义了**ShaderLab**来组织Shader的内容，针对不同平台进行编译。了解了Shader和Cg的一些基础知识之后，接下来我们要做的就是：学会如何在Unity中使用Cg编写Shader并实现一些简单的Shader效果。\n\n<!--more-->\n\n## Unity Shader：\n说到底，Shader其实只是一段规定好输入（颜色，贴图等）和输出（渲染器能读懂的点和颜色的对应关系）的程序。那么，**设计一个Shader的过程其实就是根据输入，进行计算变换从而产生输出而已**。\n\n### 1.分类：\n在Unity中的Shader分为两类：\n\n- **表面着色器**（Surface Shader）:已经为我们完成了大部分的工作，只需要简单的操作即可得到不错的效果；\n- **片段着色器**（Fragment Shader）:可以自己设计出很多东西，因为可自行设置的内容更多，但也更加难写。使用片段着色器的目的是可以在更加底层进行更复杂（或者针对目标设备更高效）的开发。\n\n### 2.Shader程序基本结构：\n使用Unity中的框架来编写Shader程序，其实相对于其他游戏引擎要简单一些，在Cocos2d中还得从OpenGL层面开始编写逻辑，但是在Unity只需要往框架中填入需要控制的内容即可，一个Shader程序的基本结构如下图所示：\n\n![](http://i.imgur.com/a6T9fF8.png)\n\n- 首先，定义一些属性，用来指定代码将有哪些输入；\n- 其次，会有一个或者多个子着色器，但是在实际运行中哪一个子着色器被使用是由运行的平台所决定的；\n- 子着色器是代码的主体，每个子着色器包含一个或多个Pass；\n- 最后指定一个回滚，用来处理所有Subshader都不能运行的情况（比如设备太老）。\n\n执行着色时，平台选择最优先可以使用的子着色器，然后依次执行该子着色器中的Pass，然后输出结果。\n\n\n### 3.Unity创建第一个Shader：\n在Unity的Project面板中，``右键``-``Create``-``Shader``，取名为``Diffuse_Texture``，使用VS打开可以查看新建的Shader的内容如下所示：\n\n```C#\n\tShader \"Custom/Diffuse_Texture\" {\n\t\tProperties {\n\t\t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {}\n\t\t}\n\t\tSubShader {\n\t\t\tTags { \"RenderType\"=\"Opaque\" }\n\t\t\tLOD 200\n\t\t\t\n\t\t\tCGPROGRAM\n\t\t\t#pragma surface surf Lambert\n\t\n\t\t\tsampler2D _MainTex;\n\t\n\t\t\tstruct Input {\n\t\t\t\tfloat2 uv_MainTex;\n\t\t\t};\n\t\n\t\t\tvoid surf (Input IN, inout SurfaceOutput o) {\n\t\t\t\thalf4 c = tex2D (_MainTex, IN.uv_MainTex);\n\t\t\t\to.Albedo = c.rgb;\n\t\t\t\to.Alpha = c.a;\n\t\t\t}\n\t\t\tENDCG\n\t\t} \n\t\tFallBack \"Diffuse\"\n\t}\n```\n\n接下来我们要做的，就是解析这个Shader中每一行的含义和作用，包括了属性、Tags、LOD、光照模型等。\n\n#### **解析：**\n第一行指定了此Shader的名字，严格来说是指定了它的路径，在材质面板中选择Shader时，我们可以根据这个路径找到此Shader。\n\n#### **属性**\n\n在``Properties{}``块中定义的内容就是着色器的属性，【可以理解为一些CPU语言例如java类在开始处定义的一些属性（全局变量或常量）】，**这些属性将作为输入提供给所有的子着色器**。每个属性定义的语法：\n```C#\n\t_Name(\"Display_Name\",type) = defaultValue[{options}]\n```\n* ``_Name``：属性的名称，或者理解为变量名，在之后整个\tShader代码中通过此名称获取属性内容；\n- ``Display_Name``：此字符串是Shader在Unity的材质编辑器中作为Shader可视化信息；\n* ``type``：此属性的类型，Unity中支持的类型有：\n   - Color：颜色，由RGBA(红绿蓝和透明度)四个量定义；\n   - 2D：一张2的阶数大小（256，512等）的贴图，此贴图将在采样后被转为对应基于模型UV的每个像素的颜色，最终显示出来；\n   - Rect：一个非2阶数大小的贴图；\n   - Cube：即Cub map texture(立方体纹理)，即6张有联系的2D贴图的组合，主要用来做**反射效果**（比如：天空盒和动态反射），也会被转换为对应点的采样；\n   - Range(min,max)：一个介于最大值max和最小值min之间的浮点数，一般用作调整Shader某些特性的参数（例如：透明度从0到1）；\n   - Float：一个浮点数；\n   - Vector：一个四维数；\n* ``defaultValue``：定义的这个属性的默认值或者初始值，但不同属性类型的默认值格式不同，例如：\n   - Color：咦0~1定义的rgba颜色，可以赋值(1,1,1,1);\n   - 2D/Rect/Cube：贴图默认值需要是一个代表tini颜色的字符串，可以是空字符串或者\"white\",\"black\",\"gray\",\"bump\"中的一个；\n   - Float、Range：任意浮点数即可；\n   - Vector：四维数，格式(x,y,z,w)；\n* ``{option}``：只对2D、Rect和Cube贴图有关，初始值至少要在贴图后面写一对空白的``{}``，当需要打开特定选项时可以吧其写入到此花括号中，多个选项以空白分隔。可能的选项：ObjectLinear, EyeLinear, SphereMap, CubeReflect, CubeNormal，这些都是OpenGL中TexGen的模式。\n\n**例子：**\n\n```C#\n\t//颜色输入\n\t_MainColor (\"Main Color\", Color) = (0,0.5,1,0.5)\n\t//2的阶数大小的贴图输入\n\t_Texture (\"Texture\", 2D) = \"white\" {}\n```\n\n#### **Subshader**\n上面已经解析了Shader代码的第一部分，接下来我们要将的就是Shader的代码主体，即SubShader的内容，在``SubShader{}``中的内容就是一个SubShader。\n\n##### **(1) Tags**\nSubShader中的第一句就是：\n```C#\nTags { \"RenderType\"=\"Opaque\" }\n```\n这是SubShader的标签，因为表面着色器可以被若干个标签（tags）所修饰，而**硬件正是通过判定这些标签（Tags）来决定什么时候调用该着色器**。所以，我们例子中的这一句``\"RenderType\"=\"Opaque\"``的意思：告诉系统应该在渲染非透明物体时调用此SubShader，这与RenderType是Opaque是相对应的。\n\n此外，**Tags其实也暗示了此Shader的输出情况**，例如：输出中都是半透明的物体，那就写在Opaque里；如果想渲染透明或者半透明的像素，那就应该写在Transparent里。\n\n另外比较有用的标签还有：\n\n- ``\"IgnoreProjector\"=\"True\"``：不被Projects影响；\n- ``\"ForceNoShadowCasting\"=\"True\"``：从不产生阴影；\n- ``\"Queue\"=\"xxx\"``：**指定渲染顺序队列**。在Unity中，如果需要进行透明和不透明物体混合时，可能会遇到不透明物体无法呈现在透明物体之后的情况，这是由于Shader的渲染顺序不正确导致的。Queue指定物体渲染顺序，预定义的Queue有：\n\t- Background：最早被调用的渲染，用于渲染天空盒或者背景；\n\t- Geometry：默认值，用来渲染非透明的物体；\n\t- AlphaTest：用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑；\n\t- Transparent：以后从后往前的顺序渲染透明物体；\n\t- Overlay：用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）；\n\n以上这些预定义的值，本质上是一组定义**整数**，Background = 1000， Geometry = 2000, AlphaTest = 2450， Transparent = 3000，最后Overlay = 4000。当然，在实际设置Queue值时，不仅可以使用上述的预定义值，还可以指定自己的Queue值，例如：``\"Queue\"=\"Transparent+100\"``，表示一个在Transparent之后100的Queue上进行调用。\n\n**通过调整Queue值，我们可以确保某些物体一定在另一个物体之前或之后被渲染**。\n\n##### **(2) LOD**\n第二行中的内容：\n\n```C#\n\tLOD 200\n```\n\nLOD，即Level of Detail，这其实是**Unity的内建Diffuse着色器的设定值，决定了我们能够用什么样的Shader**。在Unity的Quality Settings中，我们可以设置允许的最大LOD，当设定的LOD小于SubShader的LOD时，这个SubShader将不可用。\n\nUnity内建Shader定义了一组LOD的数值，我们在实现自己的Shader的时候可以将其作为参考来设定自己的LOD数值，这样在之后调整根据设备图形性能来调整画质时可以进行比较精确的控制。\n\n- VertexLit及其系列 = 100\n- Decal, Reflective VertexLit = 150\n- Diffuse = 200\n- Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit = 250\n- Bumped, Specular = 300\n- Bumped Specular = 400\n- Parallax = 500\n- Parallax Specular = 600\n\n##### **(2) CGPROGRAM...ENDCG**\n用``CGPROGRAM``开始和``ENDCG``结束，表明这部分是Cg代码。这是SubShader的主体部分，我们前面已经提到了属性中定义了此Shader的输入，那么此处代码的作用，便是对输入进行处理，并输出。接下来我们逐句进行解析：\n\n- ``#pragma surface surf Lambert``：这是一个编译指令，声明此Shader是一个表面着色器，并指定了着色器的自动调用的函数名称为surf,而且指定光照模型为Lambert(普通的diffuse)，它的一般语法如下：\n\n```CG\n#pragma surface surfaceFunction lightModel [optionalparams]\n```\n\n   - surface：声明的是一个表面着色器\n   - surfaceFunction：着色器代码的方法名称，着色器其作用时被调用\n   - lightModel：使用的光照模型\n\n---\n\n- ``sampler2D _MainTex;``：其中``sampler2D``是GLSL中2D贴图的类型，类似的还有sampler1D、sampler3D、samplerCube等格式，主要用于存储texture数据。``_MainTex``是与之前在Proterties属性模块中声明的图贴所对应的，因为这个Shader是由两个独立的程序块组成的：外部的属性声明和回滚等Unity可以直接使用和编译的ShaderLab；而在``CGPROGRAM...ENDCG``中的代码块，是一段CG程序。**假如要在CG程序中访问Proterties中所定义的变量，必须使用和之前的变量相同的名字进行声明**。所以此句Cg代码的作用就是**再次声明并链接_MainTex，使接下来的Cg程序能够使用此变量**。\n\t\n---\n- Input结构体：这其实是用来把需要参与计算的数据封装起来，然后作为输入参数传入到下面surf函数中使用的，而且必须以``Input``命名。\n\n```\nstruct Input {\n\tfloat2 uv_MainTex;\n};\n```\n这里我们的Input结构体很简单，只是定义了一个float2类型的变量，这是Cg的数据类型，表示2个float类型的数据打包在一起，所以此处``uv_MainTex``表示的就是包含两个浮点数的变量，类似的还有float3和float4。\n\n这里以uv作为前缀，其实UV mapping的作用是将一个2D贴图上的点按照一定规律映射到3D模型上，是3D渲染中最常见的一种顶点处理手段。所以在Cg中，在一个贴图变量（例如这里的_MainTex）前面加上uv，表示提取它的uv值（其实就是两个代表贴图上点的二维坐标）。后面的**surf函数中直接通过访问uv_MainTex来去的这张贴图当前需要计算的点的坐标值**。\n\n---\n\n- surf函数：这是在之前``#progma``中指定的着色器的调用方法，这也是着色器最核心的部分，这个方法的定义需要按照规定：**第一个参数是一个Input结构，第二个参数是一个inout的SurfaceOutput结构**。\n```\nvoid surf (Input IN, inout SurfaceOutput o) {\n\thalf4 c = tex2D (_MainTex, IN.uv_MainTex);\n\to.Albedo = c.rgb;\n\to.Alpha = c.a;\n}\n```\n上面已经说过了Input结构体的定义和使用，**在计算输出时，Shader会多次调用surf函数，每次给入一个贴图上的点坐标，用来计算输出**。\n\nsurf的第二个参数是一个可写的``SurfaceOutput``，SurfaceOutput是一个预定义的输出结构，我们的surf函数的目标就是根据输入把这个输出结构填上。SurfaceOutput结构体的定义如下：\n```bash\nstruct SurfaceOutput {\n    half3 Albedo;     //像素的颜色\n    half3 Normal;     //像素的法向值\n    half3 Emission;   //像素的发散颜色\n    half Specular;    //像素的镜面高光\n    half Gloss;       //像素的发光强度\n    half Alpha;       //像素的透明度\n};\n```\nhalf其实跟float与double类似，都是浮点数，只是精度不同，half称为半精度浮点数。\n\n这个例子中，surf的代码如下：\n```bash\n\thalf4 c = tex2D (_MainTex, IN.uv_MainTex);\n\to.Albedo = c.rgb;\n\to.Alpha = c.a;\n```\n这里的``tex2D``函数是Cg中用来在一张贴图中对点进行采样的方法，返回一个float4。这里，我们队_MainTex在输入点上进行采样，并将其颜色的rgb值``c.rgb``赋给输出的像素颜色``o.Albedo``，将透明度``c.a``赋值给输出像素透明度``o.Alpha``。\n\n\n#### 参考链接：\n\n- 了解Shader的基础知识：[猫都能学会的Unity3D Shader入门指南（一）](https://onevcat.com/2013/07/shader-tutorial-1/)\n- Unity官方关于Shader的一些资料：[Materials, Shaders & Textures](https://docs.unity3d.com/Manual/Shaders.html)\n- 了解Shader的机制：[【Unity Shaders】初探Surface Shader背后的机制](http://blog.csdn.net/candycat1992/article/details/39994049)\n\n#### 推荐书籍：\n\n- 《Unity Shader and Effect Cookbook》，中文版：《Unity着色器和屏幕特效开发秘笈》\n- 《GPU 编程与CG 语言之阳春白雪下里巴人》","slug":"Unity-ShaderLab基础（三）","published":1,"updated":"2017-06-24T02:13:49.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfkl000x9gfj3pd7gaiz","content":"<p>Unity引擎是一个非常强大的支持跨平台开发的游戏引擎，基于Mono这个开源.Net的框架设计而成，在Unity中定义了<strong>ShaderLab</strong>来组织Shader的内容，针对不同平台进行编译。了解了Shader和Cg的一些基础知识之后，接下来我们要做的就是：学会如何在Unity中使用Cg编写Shader并实现一些简单的Shader效果。</p>\n<a id=\"more\"></a>\n<h2 id=\"Unity-Shader：\"><a href=\"#Unity-Shader：\" class=\"headerlink\" title=\"Unity Shader：\"></a>Unity Shader：</h2><p>说到底，Shader其实只是一段规定好输入（颜色，贴图等）和输出（渲染器能读懂的点和颜色的对应关系）的程序。那么，<strong>设计一个Shader的过程其实就是根据输入，进行计算变换从而产生输出而已</strong>。</p>\n<h3 id=\"1-分类：\"><a href=\"#1-分类：\" class=\"headerlink\" title=\"1.分类：\"></a>1.分类：</h3><p>在Unity中的Shader分为两类：</p>\n<ul>\n<li><strong>表面着色器</strong>（Surface Shader）:已经为我们完成了大部分的工作，只需要简单的操作即可得到不错的效果；</li>\n<li><strong>片段着色器</strong>（Fragment Shader）:可以自己设计出很多东西，因为可自行设置的内容更多，但也更加难写。使用片段着色器的目的是可以在更加底层进行更复杂（或者针对目标设备更高效）的开发。</li>\n</ul>\n<h3 id=\"2-Shader程序基本结构：\"><a href=\"#2-Shader程序基本结构：\" class=\"headerlink\" title=\"2.Shader程序基本结构：\"></a>2.Shader程序基本结构：</h3><p>使用Unity中的框架来编写Shader程序，其实相对于其他游戏引擎要简单一些，在Cocos2d中还得从OpenGL层面开始编写逻辑，但是在Unity只需要往框架中填入需要控制的内容即可，一个Shader程序的基本结构如下图所示：</p>\n<p><img src=\"http://i.imgur.com/a6T9fF8.png\" alt=\"\"></p>\n<ul>\n<li>首先，定义一些属性，用来指定代码将有哪些输入；</li>\n<li>其次，会有一个或者多个子着色器，但是在实际运行中哪一个子着色器被使用是由运行的平台所决定的；</li>\n<li>子着色器是代码的主体，每个子着色器包含一个或多个Pass；</li>\n<li>最后指定一个回滚，用来处理所有Subshader都不能运行的情况（比如设备太老）。</li>\n</ul>\n<p>执行着色时，平台选择最优先可以使用的子着色器，然后依次执行该子着色器中的Pass，然后输出结果。</p>\n<h3 id=\"3-Unity创建第一个Shader：\"><a href=\"#3-Unity创建第一个Shader：\" class=\"headerlink\" title=\"3.Unity创建第一个Shader：\"></a>3.Unity创建第一个Shader：</h3><p>在Unity的Project面板中，<code>右键</code>-<code>Create</code>-<code>Shader</code>，取名为<code>Diffuse_Texture</code>，使用VS打开可以查看新建的Shader的内容如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">Shader &quot;Custom/Diffuse_Texture&quot; &#123;</div><div class=\"line\">\tProperties &#123;</div><div class=\"line\">\t\t_MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tSubShader &#123;</div><div class=\"line\">\t\tTags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</div><div class=\"line\">\t\tLOD 200</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tCGPROGRAM</div><div class=\"line\">\t\t#pragma surface surf Lambert</div><div class=\"line\"></div><div class=\"line\">\t\tsampler2D _MainTex;</div><div class=\"line\"></div><div class=\"line\">\t\tstruct Input &#123;</div><div class=\"line\">\t\t\tfloat2 uv_MainTex;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t\tvoid surf (Input IN, inout SurfaceOutput o) &#123;</div><div class=\"line\">\t\t\thalf4 c = tex2D (_MainTex, IN.uv_MainTex);</div><div class=\"line\">\t\t\to.Albedo = c.rgb;</div><div class=\"line\">\t\t\to.Alpha = c.a;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tENDCG</div><div class=\"line\">\t&#125; </div><div class=\"line\">\tFallBack &quot;Diffuse&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来我们要做的，就是解析这个Shader中每一行的含义和作用，包括了属性、Tags、LOD、光照模型等。</p>\n<h4 id=\"解析：\"><a href=\"#解析：\" class=\"headerlink\" title=\"解析：\"></a><strong>解析：</strong></h4><p>第一行指定了此Shader的名字，严格来说是指定了它的路径，在材质面板中选择Shader时，我们可以根据这个路径找到此Shader。</p>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a><strong>属性</strong></h4><p>在<code>Properties{}</code>块中定义的内容就是着色器的属性，【可以理解为一些CPU语言例如java类在开始处定义的一些属性（全局变量或常量）】，<strong>这些属性将作为输入提供给所有的子着色器</strong>。每个属性定义的语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">_Name(&quot;Display_Name&quot;,type) = defaultValue[&#123;options&#125;]</div></pre></td></tr></table></figure></p>\n<ul>\n<li><code>_Name</code>：属性的名称，或者理解为变量名，在之后整个    Shader代码中通过此名称获取属性内容；</li>\n</ul>\n<ul>\n<li><code>Display_Name</code>：此字符串是Shader在Unity的材质编辑器中作为Shader可视化信息；</li>\n</ul>\n<ul>\n<li><code>type</code>：此属性的类型，Unity中支持的类型有：<ul>\n<li>Color：颜色，由RGBA(红绿蓝和透明度)四个量定义；</li>\n<li>2D：一张2的阶数大小（256，512等）的贴图，此贴图将在采样后被转为对应基于模型UV的每个像素的颜色，最终显示出来；</li>\n<li>Rect：一个非2阶数大小的贴图；</li>\n<li>Cube：即Cub map texture(立方体纹理)，即6张有联系的2D贴图的组合，主要用来做<strong>反射效果</strong>（比如：天空盒和动态反射），也会被转换为对应点的采样；</li>\n<li>Range(min,max)：一个介于最大值max和最小值min之间的浮点数，一般用作调整Shader某些特性的参数（例如：透明度从0到1）；</li>\n<li>Float：一个浮点数；</li>\n<li>Vector：一个四维数；</li>\n</ul>\n</li>\n<li><code>defaultValue</code>：定义的这个属性的默认值或者初始值，但不同属性类型的默认值格式不同，例如：<ul>\n<li>Color：咦0~1定义的rgba颜色，可以赋值(1,1,1,1);</li>\n<li>2D/Rect/Cube：贴图默认值需要是一个代表tini颜色的字符串，可以是空字符串或者”white”,”black”,”gray”,”bump”中的一个；</li>\n<li>Float、Range：任意浮点数即可；</li>\n<li>Vector：四维数，格式(x,y,z,w)；</li>\n</ul>\n</li>\n<li><code>{option}</code>：只对2D、Rect和Cube贴图有关，初始值至少要在贴图后面写一对空白的<code>{}</code>，当需要打开特定选项时可以吧其写入到此花括号中，多个选项以空白分隔。可能的选项：ObjectLinear, EyeLinear, SphereMap, CubeReflect, CubeNormal，这些都是OpenGL中TexGen的模式。</li>\n</ul>\n<p><strong>例子：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//颜色输入</div><div class=\"line\">_MainColor (&quot;Main Color&quot;, Color) = (0,0.5,1,0.5)</div><div class=\"line\">//2的阶数大小的贴图输入</div><div class=\"line\">_Texture (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Subshader\"><a href=\"#Subshader\" class=\"headerlink\" title=\"Subshader\"></a><strong>Subshader</strong></h4><p>上面已经解析了Shader代码的第一部分，接下来我们要将的就是Shader的代码主体，即SubShader的内容，在<code>SubShader{}</code>中的内容就是一个SubShader。</p>\n<h5 id=\"1-Tags\"><a href=\"#1-Tags\" class=\"headerlink\" title=\"(1) Tags\"></a><strong>(1) Tags</strong></h5><p>SubShader中的第一句就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</div></pre></td></tr></table></figure></p>\n<p>这是SubShader的标签，因为表面着色器可以被若干个标签（tags）所修饰，而<strong>硬件正是通过判定这些标签（Tags）来决定什么时候调用该着色器</strong>。所以，我们例子中的这一句<code>&quot;RenderType&quot;=&quot;Opaque&quot;</code>的意思：告诉系统应该在渲染非透明物体时调用此SubShader，这与RenderType是Opaque是相对应的。</p>\n<p>此外，<strong>Tags其实也暗示了此Shader的输出情况</strong>，例如：输出中都是半透明的物体，那就写在Opaque里；如果想渲染透明或者半透明的像素，那就应该写在Transparent里。</p>\n<p>另外比较有用的标签还有：</p>\n<ul>\n<li><code>&quot;IgnoreProjector&quot;=&quot;True&quot;</code>：不被Projects影响；</li>\n<li><code>&quot;ForceNoShadowCasting&quot;=&quot;True&quot;</code>：从不产生阴影；</li>\n<li><code>&quot;Queue&quot;=&quot;xxx&quot;</code>：<strong>指定渲染顺序队列</strong>。在Unity中，如果需要进行透明和不透明物体混合时，可能会遇到不透明物体无法呈现在透明物体之后的情况，这是由于Shader的渲染顺序不正确导致的。Queue指定物体渲染顺序，预定义的Queue有：<ul>\n<li>Background：最早被调用的渲染，用于渲染天空盒或者背景；</li>\n<li>Geometry：默认值，用来渲染非透明的物体；</li>\n<li>AlphaTest：用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑；</li>\n<li>Transparent：以后从后往前的顺序渲染透明物体；</li>\n<li>Overlay：用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）；</li>\n</ul>\n</li>\n</ul>\n<p>以上这些预定义的值，本质上是一组定义<strong>整数</strong>，Background = 1000， Geometry = 2000, AlphaTest = 2450， Transparent = 3000，最后Overlay = 4000。当然，在实际设置Queue值时，不仅可以使用上述的预定义值，还可以指定自己的Queue值，例如：<code>&quot;Queue&quot;=&quot;Transparent+100&quot;</code>，表示一个在Transparent之后100的Queue上进行调用。</p>\n<p><strong>通过调整Queue值，我们可以确保某些物体一定在另一个物体之前或之后被渲染</strong>。</p>\n<h5 id=\"2-LOD\"><a href=\"#2-LOD\" class=\"headerlink\" title=\"(2) LOD\"></a><strong>(2) LOD</strong></h5><p>第二行中的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOD 200</div></pre></td></tr></table></figure>\n<p>LOD，即Level of Detail，这其实是<strong>Unity的内建Diffuse着色器的设定值，决定了我们能够用什么样的Shader</strong>。在Unity的Quality Settings中，我们可以设置允许的最大LOD，当设定的LOD小于SubShader的LOD时，这个SubShader将不可用。</p>\n<p>Unity内建Shader定义了一组LOD的数值，我们在实现自己的Shader的时候可以将其作为参考来设定自己的LOD数值，这样在之后调整根据设备图形性能来调整画质时可以进行比较精确的控制。</p>\n<ul>\n<li>VertexLit及其系列 = 100</li>\n<li>Decal, Reflective VertexLit = 150</li>\n<li>Diffuse = 200</li>\n<li>Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit = 250</li>\n<li>Bumped, Specular = 300</li>\n<li>Bumped Specular = 400</li>\n<li>Parallax = 500</li>\n<li>Parallax Specular = 600</li>\n</ul>\n<h5 id=\"2-CGPROGRAM…ENDCG\"><a href=\"#2-CGPROGRAM…ENDCG\" class=\"headerlink\" title=\"(2) CGPROGRAM…ENDCG\"></a><strong>(2) CGPROGRAM…ENDCG</strong></h5><p>用<code>CGPROGRAM</code>开始和<code>ENDCG</code>结束，表明这部分是Cg代码。这是SubShader的主体部分，我们前面已经提到了属性中定义了此Shader的输入，那么此处代码的作用，便是对输入进行处理，并输出。接下来我们逐句进行解析：</p>\n<ul>\n<li><code>#pragma surface surf Lambert</code>：这是一个编译指令，声明此Shader是一个表面着色器，并指定了着色器的自动调用的函数名称为surf,而且指定光照模型为Lambert(普通的diffuse)，它的一般语法如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma surface surfaceFunction lightModel [optionalparams]</div></pre></td></tr></table></figure>\n<ul>\n<li>surface：声明的是一个表面着色器</li>\n<li>surfaceFunction：着色器代码的方法名称，着色器其作用时被调用</li>\n<li>lightModel：使用的光照模型</li>\n</ul>\n<hr>\n<ul>\n<li><code>sampler2D _MainTex;</code>：其中<code>sampler2D</code>是GLSL中2D贴图的类型，类似的还有sampler1D、sampler3D、samplerCube等格式，主要用于存储texture数据。<code>_MainTex</code>是与之前在Proterties属性模块中声明的图贴所对应的，因为这个Shader是由两个独立的程序块组成的：外部的属性声明和回滚等Unity可以直接使用和编译的ShaderLab；而在<code>CGPROGRAM...ENDCG</code>中的代码块，是一段CG程序。<strong>假如要在CG程序中访问Proterties中所定义的变量，必须使用和之前的变量相同的名字进行声明</strong>。所以此句Cg代码的作用就是<strong>再次声明并链接_MainTex，使接下来的Cg程序能够使用此变量</strong>。</li>\n</ul>\n<hr>\n<ul>\n<li>Input结构体：这其实是用来把需要参与计算的数据封装起来，然后作为输入参数传入到下面surf函数中使用的，而且必须以<code>Input</code>命名。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct Input &#123;</div><div class=\"line\">\tfloat2 uv_MainTex;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里我们的Input结构体很简单，只是定义了一个float2类型的变量，这是Cg的数据类型，表示2个float类型的数据打包在一起，所以此处<code>uv_MainTex</code>表示的就是包含两个浮点数的变量，类似的还有float3和float4。</p>\n<p>这里以uv作为前缀，其实UV mapping的作用是将一个2D贴图上的点按照一定规律映射到3D模型上，是3D渲染中最常见的一种顶点处理手段。所以在Cg中，在一个贴图变量（例如这里的_MainTex）前面加上uv，表示提取它的uv值（其实就是两个代表贴图上点的二维坐标）。后面的<strong>surf函数中直接通过访问uv_MainTex来去的这张贴图当前需要计算的点的坐标值</strong>。</p>\n<hr>\n<ul>\n<li>surf函数：这是在之前<code>#progma</code>中指定的着色器的调用方法，这也是着色器最核心的部分，这个方法的定义需要按照规定：<strong>第一个参数是一个Input结构，第二个参数是一个inout的SurfaceOutput结构</strong>。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void surf (Input IN, inout SurfaceOutput o) &#123;</div><div class=\"line\">\thalf4 c = tex2D (_MainTex, IN.uv_MainTex);</div><div class=\"line\">\to.Albedo = c.rgb;</div><div class=\"line\">\to.Alpha = c.a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面已经说过了Input结构体的定义和使用，<strong>在计算输出时，Shader会多次调用surf函数，每次给入一个贴图上的点坐标，用来计算输出</strong>。</p>\n<p>surf的第二个参数是一个可写的<code>SurfaceOutput</code>，SurfaceOutput是一个预定义的输出结构，我们的surf函数的目标就是根据输入把这个输出结构填上。SurfaceOutput结构体的定义如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct SurfaceOutput &#123;</div><div class=\"line\">    half3 Albedo;     //像素的颜色</div><div class=\"line\">    half3 Normal;     //像素的法向值</div><div class=\"line\">    half3 Emission;   //像素的发散颜色</div><div class=\"line\">    half Specular;    //像素的镜面高光</div><div class=\"line\">    half Gloss;       //像素的发光强度</div><div class=\"line\">    half Alpha;       //像素的透明度</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>half其实跟float与double类似，都是浮点数，只是精度不同，half称为半精度浮点数。</p>\n<p>这个例子中，surf的代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">half4 c = tex2D (_MainTex, IN.uv_MainTex);</div><div class=\"line\">o.Albedo = c.rgb;</div><div class=\"line\">o.Alpha = c.a;</div></pre></td></tr></table></figure></p>\n<p>这里的<code>tex2D</code>函数是Cg中用来在一张贴图中对点进行采样的方法，返回一个float4。这里，我们队_MainTex在输入点上进行采样，并将其颜色的rgb值<code>c.rgb</code>赋给输出的像素颜色<code>o.Albedo</code>，将透明度<code>c.a</code>赋值给输出像素透明度<code>o.Alpha</code>。</p>\n<h4 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h4><ul>\n<li>了解Shader的基础知识：<a href=\"https://onevcat.com/2013/07/shader-tutorial-1/\" target=\"_blank\" rel=\"external\">猫都能学会的Unity3D Shader入门指南（一）</a></li>\n<li>Unity官方关于Shader的一些资料：<a href=\"https://docs.unity3d.com/Manual/Shaders.html\" target=\"_blank\" rel=\"external\">Materials, Shaders &amp; Textures</a></li>\n<li>了解Shader的机制：<a href=\"http://blog.csdn.net/candycat1992/article/details/39994049\" target=\"_blank\" rel=\"external\">【Unity Shaders】初探Surface Shader背后的机制</a></li>\n</ul>\n<h4 id=\"推荐书籍：\"><a href=\"#推荐书籍：\" class=\"headerlink\" title=\"推荐书籍：\"></a>推荐书籍：</h4><ul>\n<li>《Unity Shader and Effect Cookbook》，中文版：《Unity着色器和屏幕特效开发秘笈》</li>\n<li>《GPU 编程与CG 语言之阳春白雪下里巴人》</li>\n</ul>\n","excerpt":"<p>Unity引擎是一个非常强大的支持跨平台开发的游戏引擎，基于Mono这个开源.Net的框架设计而成，在Unity中定义了<strong>ShaderLab</strong>来组织Shader的内容，针对不同平台进行编译。了解了Shader和Cg的一些基础知识之后，接下来我们要做的就是：学会如何在Unity中使用Cg编写Shader并实现一些简单的Shader效果。</p>","more":"<h2 id=\"Unity-Shader：\"><a href=\"#Unity-Shader：\" class=\"headerlink\" title=\"Unity Shader：\"></a>Unity Shader：</h2><p>说到底，Shader其实只是一段规定好输入（颜色，贴图等）和输出（渲染器能读懂的点和颜色的对应关系）的程序。那么，<strong>设计一个Shader的过程其实就是根据输入，进行计算变换从而产生输出而已</strong>。</p>\n<h3 id=\"1-分类：\"><a href=\"#1-分类：\" class=\"headerlink\" title=\"1.分类：\"></a>1.分类：</h3><p>在Unity中的Shader分为两类：</p>\n<ul>\n<li><strong>表面着色器</strong>（Surface Shader）:已经为我们完成了大部分的工作，只需要简单的操作即可得到不错的效果；</li>\n<li><strong>片段着色器</strong>（Fragment Shader）:可以自己设计出很多东西，因为可自行设置的内容更多，但也更加难写。使用片段着色器的目的是可以在更加底层进行更复杂（或者针对目标设备更高效）的开发。</li>\n</ul>\n<h3 id=\"2-Shader程序基本结构：\"><a href=\"#2-Shader程序基本结构：\" class=\"headerlink\" title=\"2.Shader程序基本结构：\"></a>2.Shader程序基本结构：</h3><p>使用Unity中的框架来编写Shader程序，其实相对于其他游戏引擎要简单一些，在Cocos2d中还得从OpenGL层面开始编写逻辑，但是在Unity只需要往框架中填入需要控制的内容即可，一个Shader程序的基本结构如下图所示：</p>\n<p><img src=\"http://i.imgur.com/a6T9fF8.png\" alt=\"\"></p>\n<ul>\n<li>首先，定义一些属性，用来指定代码将有哪些输入；</li>\n<li>其次，会有一个或者多个子着色器，但是在实际运行中哪一个子着色器被使用是由运行的平台所决定的；</li>\n<li>子着色器是代码的主体，每个子着色器包含一个或多个Pass；</li>\n<li>最后指定一个回滚，用来处理所有Subshader都不能运行的情况（比如设备太老）。</li>\n</ul>\n<p>执行着色时，平台选择最优先可以使用的子着色器，然后依次执行该子着色器中的Pass，然后输出结果。</p>\n<h3 id=\"3-Unity创建第一个Shader：\"><a href=\"#3-Unity创建第一个Shader：\" class=\"headerlink\" title=\"3.Unity创建第一个Shader：\"></a>3.Unity创建第一个Shader：</h3><p>在Unity的Project面板中，<code>右键</code>-<code>Create</code>-<code>Shader</code>，取名为<code>Diffuse_Texture</code>，使用VS打开可以查看新建的Shader的内容如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">Shader &quot;Custom/Diffuse_Texture&quot; &#123;</div><div class=\"line\">\tProperties &#123;</div><div class=\"line\">\t\t_MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tSubShader &#123;</div><div class=\"line\">\t\tTags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</div><div class=\"line\">\t\tLOD 200</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tCGPROGRAM</div><div class=\"line\">\t\t#pragma surface surf Lambert</div><div class=\"line\"></div><div class=\"line\">\t\tsampler2D _MainTex;</div><div class=\"line\"></div><div class=\"line\">\t\tstruct Input &#123;</div><div class=\"line\">\t\t\tfloat2 uv_MainTex;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t\tvoid surf (Input IN, inout SurfaceOutput o) &#123;</div><div class=\"line\">\t\t\thalf4 c = tex2D (_MainTex, IN.uv_MainTex);</div><div class=\"line\">\t\t\to.Albedo = c.rgb;</div><div class=\"line\">\t\t\to.Alpha = c.a;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tENDCG</div><div class=\"line\">\t&#125; </div><div class=\"line\">\tFallBack &quot;Diffuse&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来我们要做的，就是解析这个Shader中每一行的含义和作用，包括了属性、Tags、LOD、光照模型等。</p>\n<h4 id=\"解析：\"><a href=\"#解析：\" class=\"headerlink\" title=\"解析：\"></a><strong>解析：</strong></h4><p>第一行指定了此Shader的名字，严格来说是指定了它的路径，在材质面板中选择Shader时，我们可以根据这个路径找到此Shader。</p>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a><strong>属性</strong></h4><p>在<code>Properties{}</code>块中定义的内容就是着色器的属性，【可以理解为一些CPU语言例如java类在开始处定义的一些属性（全局变量或常量）】，<strong>这些属性将作为输入提供给所有的子着色器</strong>。每个属性定义的语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">_Name(&quot;Display_Name&quot;,type) = defaultValue[&#123;options&#125;]</div></pre></td></tr></table></figure></p>\n<ul>\n<li><code>_Name</code>：属性的名称，或者理解为变量名，在之后整个    Shader代码中通过此名称获取属性内容；</li>\n</ul>\n<ul>\n<li><code>Display_Name</code>：此字符串是Shader在Unity的材质编辑器中作为Shader可视化信息；</li>\n</ul>\n<ul>\n<li><code>type</code>：此属性的类型，Unity中支持的类型有：<ul>\n<li>Color：颜色，由RGBA(红绿蓝和透明度)四个量定义；</li>\n<li>2D：一张2的阶数大小（256，512等）的贴图，此贴图将在采样后被转为对应基于模型UV的每个像素的颜色，最终显示出来；</li>\n<li>Rect：一个非2阶数大小的贴图；</li>\n<li>Cube：即Cub map texture(立方体纹理)，即6张有联系的2D贴图的组合，主要用来做<strong>反射效果</strong>（比如：天空盒和动态反射），也会被转换为对应点的采样；</li>\n<li>Range(min,max)：一个介于最大值max和最小值min之间的浮点数，一般用作调整Shader某些特性的参数（例如：透明度从0到1）；</li>\n<li>Float：一个浮点数；</li>\n<li>Vector：一个四维数；</li>\n</ul>\n</li>\n<li><code>defaultValue</code>：定义的这个属性的默认值或者初始值，但不同属性类型的默认值格式不同，例如：<ul>\n<li>Color：咦0~1定义的rgba颜色，可以赋值(1,1,1,1);</li>\n<li>2D/Rect/Cube：贴图默认值需要是一个代表tini颜色的字符串，可以是空字符串或者”white”,”black”,”gray”,”bump”中的一个；</li>\n<li>Float、Range：任意浮点数即可；</li>\n<li>Vector：四维数，格式(x,y,z,w)；</li>\n</ul>\n</li>\n<li><code>{option}</code>：只对2D、Rect和Cube贴图有关，初始值至少要在贴图后面写一对空白的<code>{}</code>，当需要打开特定选项时可以吧其写入到此花括号中，多个选项以空白分隔。可能的选项：ObjectLinear, EyeLinear, SphereMap, CubeReflect, CubeNormal，这些都是OpenGL中TexGen的模式。</li>\n</ul>\n<p><strong>例子：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//颜色输入</div><div class=\"line\">_MainColor (&quot;Main Color&quot;, Color) = (0,0.5,1,0.5)</div><div class=\"line\">//2的阶数大小的贴图输入</div><div class=\"line\">_Texture (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Subshader\"><a href=\"#Subshader\" class=\"headerlink\" title=\"Subshader\"></a><strong>Subshader</strong></h4><p>上面已经解析了Shader代码的第一部分，接下来我们要将的就是Shader的代码主体，即SubShader的内容，在<code>SubShader{}</code>中的内容就是一个SubShader。</p>\n<h5 id=\"1-Tags\"><a href=\"#1-Tags\" class=\"headerlink\" title=\"(1) Tags\"></a><strong>(1) Tags</strong></h5><p>SubShader中的第一句就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</div></pre></td></tr></table></figure></p>\n<p>这是SubShader的标签，因为表面着色器可以被若干个标签（tags）所修饰，而<strong>硬件正是通过判定这些标签（Tags）来决定什么时候调用该着色器</strong>。所以，我们例子中的这一句<code>&quot;RenderType&quot;=&quot;Opaque&quot;</code>的意思：告诉系统应该在渲染非透明物体时调用此SubShader，这与RenderType是Opaque是相对应的。</p>\n<p>此外，<strong>Tags其实也暗示了此Shader的输出情况</strong>，例如：输出中都是半透明的物体，那就写在Opaque里；如果想渲染透明或者半透明的像素，那就应该写在Transparent里。</p>\n<p>另外比较有用的标签还有：</p>\n<ul>\n<li><code>&quot;IgnoreProjector&quot;=&quot;True&quot;</code>：不被Projects影响；</li>\n<li><code>&quot;ForceNoShadowCasting&quot;=&quot;True&quot;</code>：从不产生阴影；</li>\n<li><code>&quot;Queue&quot;=&quot;xxx&quot;</code>：<strong>指定渲染顺序队列</strong>。在Unity中，如果需要进行透明和不透明物体混合时，可能会遇到不透明物体无法呈现在透明物体之后的情况，这是由于Shader的渲染顺序不正确导致的。Queue指定物体渲染顺序，预定义的Queue有：<ul>\n<li>Background：最早被调用的渲染，用于渲染天空盒或者背景；</li>\n<li>Geometry：默认值，用来渲染非透明的物体；</li>\n<li>AlphaTest：用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑；</li>\n<li>Transparent：以后从后往前的顺序渲染透明物体；</li>\n<li>Overlay：用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）；</li>\n</ul>\n</li>\n</ul>\n<p>以上这些预定义的值，本质上是一组定义<strong>整数</strong>，Background = 1000， Geometry = 2000, AlphaTest = 2450， Transparent = 3000，最后Overlay = 4000。当然，在实际设置Queue值时，不仅可以使用上述的预定义值，还可以指定自己的Queue值，例如：<code>&quot;Queue&quot;=&quot;Transparent+100&quot;</code>，表示一个在Transparent之后100的Queue上进行调用。</p>\n<p><strong>通过调整Queue值，我们可以确保某些物体一定在另一个物体之前或之后被渲染</strong>。</p>\n<h5 id=\"2-LOD\"><a href=\"#2-LOD\" class=\"headerlink\" title=\"(2) LOD\"></a><strong>(2) LOD</strong></h5><p>第二行中的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOD 200</div></pre></td></tr></table></figure>\n<p>LOD，即Level of Detail，这其实是<strong>Unity的内建Diffuse着色器的设定值，决定了我们能够用什么样的Shader</strong>。在Unity的Quality Settings中，我们可以设置允许的最大LOD，当设定的LOD小于SubShader的LOD时，这个SubShader将不可用。</p>\n<p>Unity内建Shader定义了一组LOD的数值，我们在实现自己的Shader的时候可以将其作为参考来设定自己的LOD数值，这样在之后调整根据设备图形性能来调整画质时可以进行比较精确的控制。</p>\n<ul>\n<li>VertexLit及其系列 = 100</li>\n<li>Decal, Reflective VertexLit = 150</li>\n<li>Diffuse = 200</li>\n<li>Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit = 250</li>\n<li>Bumped, Specular = 300</li>\n<li>Bumped Specular = 400</li>\n<li>Parallax = 500</li>\n<li>Parallax Specular = 600</li>\n</ul>\n<h5 id=\"2-CGPROGRAM…ENDCG\"><a href=\"#2-CGPROGRAM…ENDCG\" class=\"headerlink\" title=\"(2) CGPROGRAM…ENDCG\"></a><strong>(2) CGPROGRAM…ENDCG</strong></h5><p>用<code>CGPROGRAM</code>开始和<code>ENDCG</code>结束，表明这部分是Cg代码。这是SubShader的主体部分，我们前面已经提到了属性中定义了此Shader的输入，那么此处代码的作用，便是对输入进行处理，并输出。接下来我们逐句进行解析：</p>\n<ul>\n<li><code>#pragma surface surf Lambert</code>：这是一个编译指令，声明此Shader是一个表面着色器，并指定了着色器的自动调用的函数名称为surf,而且指定光照模型为Lambert(普通的diffuse)，它的一般语法如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma surface surfaceFunction lightModel [optionalparams]</div></pre></td></tr></table></figure>\n<ul>\n<li>surface：声明的是一个表面着色器</li>\n<li>surfaceFunction：着色器代码的方法名称，着色器其作用时被调用</li>\n<li>lightModel：使用的光照模型</li>\n</ul>\n<hr>\n<ul>\n<li><code>sampler2D _MainTex;</code>：其中<code>sampler2D</code>是GLSL中2D贴图的类型，类似的还有sampler1D、sampler3D、samplerCube等格式，主要用于存储texture数据。<code>_MainTex</code>是与之前在Proterties属性模块中声明的图贴所对应的，因为这个Shader是由两个独立的程序块组成的：外部的属性声明和回滚等Unity可以直接使用和编译的ShaderLab；而在<code>CGPROGRAM...ENDCG</code>中的代码块，是一段CG程序。<strong>假如要在CG程序中访问Proterties中所定义的变量，必须使用和之前的变量相同的名字进行声明</strong>。所以此句Cg代码的作用就是<strong>再次声明并链接_MainTex，使接下来的Cg程序能够使用此变量</strong>。</li>\n</ul>\n<hr>\n<ul>\n<li>Input结构体：这其实是用来把需要参与计算的数据封装起来，然后作为输入参数传入到下面surf函数中使用的，而且必须以<code>Input</code>命名。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct Input &#123;</div><div class=\"line\">\tfloat2 uv_MainTex;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里我们的Input结构体很简单，只是定义了一个float2类型的变量，这是Cg的数据类型，表示2个float类型的数据打包在一起，所以此处<code>uv_MainTex</code>表示的就是包含两个浮点数的变量，类似的还有float3和float4。</p>\n<p>这里以uv作为前缀，其实UV mapping的作用是将一个2D贴图上的点按照一定规律映射到3D模型上，是3D渲染中最常见的一种顶点处理手段。所以在Cg中，在一个贴图变量（例如这里的_MainTex）前面加上uv，表示提取它的uv值（其实就是两个代表贴图上点的二维坐标）。后面的<strong>surf函数中直接通过访问uv_MainTex来去的这张贴图当前需要计算的点的坐标值</strong>。</p>\n<hr>\n<ul>\n<li>surf函数：这是在之前<code>#progma</code>中指定的着色器的调用方法，这也是着色器最核心的部分，这个方法的定义需要按照规定：<strong>第一个参数是一个Input结构，第二个参数是一个inout的SurfaceOutput结构</strong>。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void surf (Input IN, inout SurfaceOutput o) &#123;</div><div class=\"line\">\thalf4 c = tex2D (_MainTex, IN.uv_MainTex);</div><div class=\"line\">\to.Albedo = c.rgb;</div><div class=\"line\">\to.Alpha = c.a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面已经说过了Input结构体的定义和使用，<strong>在计算输出时，Shader会多次调用surf函数，每次给入一个贴图上的点坐标，用来计算输出</strong>。</p>\n<p>surf的第二个参数是一个可写的<code>SurfaceOutput</code>，SurfaceOutput是一个预定义的输出结构，我们的surf函数的目标就是根据输入把这个输出结构填上。SurfaceOutput结构体的定义如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct SurfaceOutput &#123;</div><div class=\"line\">    half3 Albedo;     //像素的颜色</div><div class=\"line\">    half3 Normal;     //像素的法向值</div><div class=\"line\">    half3 Emission;   //像素的发散颜色</div><div class=\"line\">    half Specular;    //像素的镜面高光</div><div class=\"line\">    half Gloss;       //像素的发光强度</div><div class=\"line\">    half Alpha;       //像素的透明度</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>half其实跟float与double类似，都是浮点数，只是精度不同，half称为半精度浮点数。</p>\n<p>这个例子中，surf的代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">half4 c = tex2D (_MainTex, IN.uv_MainTex);</div><div class=\"line\">o.Albedo = c.rgb;</div><div class=\"line\">o.Alpha = c.a;</div></pre></td></tr></table></figure></p>\n<p>这里的<code>tex2D</code>函数是Cg中用来在一张贴图中对点进行采样的方法，返回一个float4。这里，我们队_MainTex在输入点上进行采样，并将其颜色的rgb值<code>c.rgb</code>赋给输出的像素颜色<code>o.Albedo</code>，将透明度<code>c.a</code>赋值给输出像素透明度<code>o.Alpha</code>。</p>\n<h4 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h4><ul>\n<li>了解Shader的基础知识：<a href=\"https://onevcat.com/2013/07/shader-tutorial-1/\">猫都能学会的Unity3D Shader入门指南（一）</a></li>\n<li>Unity官方关于Shader的一些资料：<a href=\"https://docs.unity3d.com/Manual/Shaders.html\">Materials, Shaders &amp; Textures</a></li>\n<li>了解Shader的机制：<a href=\"http://blog.csdn.net/candycat1992/article/details/39994049\">【Unity Shaders】初探Surface Shader背后的机制</a></li>\n</ul>\n<h4 id=\"推荐书籍：\"><a href=\"#推荐书籍：\" class=\"headerlink\" title=\"推荐书籍：\"></a>推荐书籍：</h4><ul>\n<li>《Unity Shader and Effect Cookbook》，中文版：《Unity着色器和屏幕特效开发秘笈》</li>\n<li>《GPU 编程与CG 语言之阳春白雪下里巴人》</li>\n</ul>"},{"title":"Unity ShaderLab基础（二）Cg语言","date":"2016-09-06T03:55:59.000Z","_content":"学习一门新的语言，有几个基本需要掌握的：数据类型（基本数据类型和结构类型），基本语法（表达式和控制语句等），编译和运行方式，这一点在CPU编程语言和GPU编程语言中是相似的，Cg作为一门GPU图形学语言也是如此。\n<!--more-->\n\n## Cg的数据类型：\n### 1.基本数据类型\nCg支持7种基本的数据类型，分别是：\n\n- **float**， 32 位浮点数据，一个符号位。浮点数据类型被所有的 profile 支持\n- **half**，16 为浮点数据\n- **int**，32 位整形数据，有些 profile 会将 int 类型作为 float 类型使用\n- **fixed**，12 位定点数，被所有的 fragment profiles 所支持\n- **bool**，布尔数据，通常用于 if 和条件操作符（ ?: ） ，布尔数据类型被所有的profiles 支持\n- **simpler***， 纹理对象的句柄（ the handle to a texture object ） ，分为 6 类：\nsampler, sampler1D, sampler2D, sampler3D, samplerCUBE, 和 samplerRECT 。DirectX profiles 不支持 samplerRECT 类型， 除此之外这些类型被所有的 pixelprofiles 和 NV40 vertex program profile 所支持（ CgUsersManual 30 页） 。由此可见，在不远的未来，顶点程序也将广泛支持纹理操作\n- **string**，字符类型，该类型不被当前存在的 profile 所支持，实际上也没有必要在 Cg 程序中用到字符类型，但是你可以通过 Cg runtime API 声明该类型变量，并赋值；因此，该类型变量可以保存 Cg 文件的信息。\n\n>前6种类型为常用类型，**string**类型几乎不使用。\n\n### 2.其他内置数据类型：\n\n- **向量**\n\nCg还提供了内置的向量数据类型 (built-in vector data types) ，内置的向量数据类型基于基础数据类型。 例如： float4， 表示 float 类型的 4 元向量； bool4， 表示 bool类型 4 元向量。\n（注意： **向量最长不能超过 4 元**， 即在 Cg 程序中可以声明 float1 、 float2 、 float3 、float4 类型的数组变量，但是不能声明超过 4 元的向量。）\n向量初始化方式一般为：\n\n\tfloat4 array = float4(1.0, 2.0, 3.0, 4.0);\n较长的向量还可以通过较短的向量进行构建：\n\n\tfloat2 a = float2(1.0, 1.0);  \n\tfloat4 b = float4(a, 0.0, 0.0);  \n\n- **矩阵**\n\nCg还提供矩阵数据类型，不过**最大的维数不能超过4X4阶**，例如：\n\n\tfloat1x1 matrix1;//等价于float matirx1; x是字符，并不是乘号！  \n\tfloat2x3 matrix2;//表示 2*3 阶矩阵，包含6个float类型数据  \n\tfloat4x2 matrix3;//表示 4*2 阶矩阵，包含8个float类型数据  \n\tfloat4x4 matrix4;//表示 4*4 阶矩阵，这是最大的维数  \n矩阵初始化：\n\n\tfloat2x3 matrix5 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};  \n\n- **数组**\n\n**数组数据类型在Cg中的作用：作为函数的形参，用于大量数据的传递**，例如：顶点参数数组、光照参数数据等。\n\n一维数组：\n\n\tfloat a[10];//声明了一个数组，包含 10 个 float 类型数据  \n\tfloat a[4] = {1.0, 2.0, 3.0, 4.0}; //初始化一个数组  \n\tint length = a.length;//获取数组长度  \n多维数组：\n\n\tfloat b[2][3] = {{0.0, 0.0, 0.0},{1.0, 1.0, 1.0}};  \n\tint length1 = b.length; // length1 值为 2  \n\tint length2 = b[0].length; // length2 值为 3  \n\n\n注：在Cg中，向量、矩阵与数组是完全不同的，向量和矩阵是内置的数据类型，而数组则是一种数据结构。\n\n- **类型转换**\n\nCg 中的类型转换和 C 语言中的类型转换很类似。 C 语言中类型转换可以是**强制类型转换**，也可以是**隐式转换**，如果是后者，则数据类型从低精度向高精度转换。在 Cg 语言中也是如此：\n\n\tfloat a = 1.0;  \n\thalf b = 2.0;  \n\tfloat c = a+b; //等价于 float c = a + (float)b;  \n当有类型变量和无类型常量数据进行运算时，该常量数据不做类型转换，例如：\n\n\tfloat a = 1.0;  \n\tfloat b = a + 2.0;//2.0为无类型常量数据，编译时作为float 类型\nCg 语言中对于常量数据可以加上类型后缀，表示该数据的类型，例如：\n\n\tfloat a = 1.0;  \n\tfloat b = a + 2.0h;//2.0h为half类型常量数据，运算是需要做类型转换\n常量的类型后缀有3种：\n\n- f：表示float\n- h：表示half\n- x：表示fixed\n\n---\n\n## Cg的语法：\nCg的关系操作符、逻辑操作符、位移操作符都与C语言有相似之处，需要特别注意的是**Swizzle操作符**，例如：\n\n\tfloat4(a, b, c, d).xyz \t//等价于 float3(a, b, c)\n\tfloat4(a, b, c, d).xyy \t//等价于 float3(a, b, b)\n\tfloat4(a, b, c, d).wzyx //等价于 float4(d, c, b, a)\n\tfloat4(a, b, c, d).w \t//等价于 float d\n\n---\n\n## Cg的编译：\n### 1.编译方式：\n- **编译程序**：\n\n计算机只能理解和执行由 0 、 1 序列（电压序列）构成的机器语言，所以汇编语言和高级语言程序都需要进行翻译才能被计算机所理解， 担负这一任务的程序称为语言处理程序，通常也被称为编译程序。\n\n- **静态编译**：\n\n一旦编译后，除非改变程序代码，否则不需要重新编译，这种方式称为静态编译（ static compilation ） 。静态编译最重要的特征是：**一旦编译为可执行文件，在可执行文件运行期间不再需要源码信息**。\n\n- **动态编译**：\n\n编译程序和源码都要参与到程序的运行过程中，就像脚本语言（Lua、JavaScrpit等），源码嵌套到调用的宿主语言程序中，运行时进行编译。\n\n**Cg通常采用动态编译的方式（Cg也支持静态编译方式），即在宿主程序运行时，利用Cg运行库（Cg Runtimer Library）动态编译Cg代码。使用动态编译的方式，可以将Cg程序当做一个脚本，随时修改随时运行，节省时间，在OGRE图形引擎中就采用了这种方式。**\n\n### 2.编译器：\nCg 编译器首先将 Cg 程序翻译成可被图形 API （ OpenGL 和 Direct3D ）所接受的形式， 然后应用程序使用适当的 OpenGL 和 Direct3D 命令将翻译后的 Cg 程序传递给图形处理器， OpenGL 和 Direct3D 驱动程序最后把它翻译成图形处理器所需要的硬件可执行格式。**NVIDIA 提供的 Cg 编译器为 cgc.exe**。\n\n* 下载[Cg Toolkit](https://developer.nvidia.com/cg-toolkit-download)；\n* 安装之后，在安装目录的Cg\\bin中就有cgc.exe；\n* 打开命令行窗口，输入 ```cgc -h``` ，假如不报错则说明安装成功。\n\n### 3.Cg指令：\n\n**编译指令**\n\n\tcgc [options] file\n\n* ```[options]``` 表示可选配置项;\n* ```file``` 表示 Cg 程序文件名。\n\n例如，比较典型的编译方式：\n\n\tcgc -profile glslv -entry main_v test.cg\n \n* ```-profile``` 是profile配置项名；\n* ```glslv``` 是当前所使用的profile名称；\n* ```-entry``` 着色程序的入口函数名称配置项；\n* ```main_v``` 是顶点着色程序的入口函数名；\n* ```test.cg``` 是当前的着色程序文件名（必须带后缀名）,Cg源码文件需以**.cg**为后缀名；\n\n将Cg语言所写的着色程序转换为使用**GLSL**或**HLSL**所编写的程序：\n\n\tcgc –profile glslv –o direct.glsl –entry main_v test.cg\n表示编译文件 test.cg 中的顶点着色程序， 入口函数名为 main_v ， 并将顶点着色程序转换为 glsl 程序，然后保存成文件 direct.glsl 。\n\n**备注**：GPU编程，是无法跟踪调试着色程序的，一个着色程序，语法错误可以通过编译器发现，但是代码的逻辑错误只能认真查找。\n\n\n>关于Cg的更详细的介绍可以参考这篇博客，利用OpenGL、C++和Cg进行Cg的测试：[【GPU编程】开始Cg之旅，编译自己的第一个Cg程序](http://blog.csdn.net/xiajun07061225/article/details/6937272)\n\n### 4.**Cg Profiles:**\nCg 程序的编译不但依赖于宿主程序所使用的三维编程接口，而且依赖于图形硬件环境，因为图形硬件自身的限制，不一定支持某种 Cg 语句。\n**被特定的图形硬件环境或 AIP 所支持的 Cg 语言子集，被称为Cg Profiles** 。\n\nprofile分为：**顶点程序的profile**和**片段程序的profile**，所以编译顶点着色程序时必须选用当前图形硬件支持的顶点profile ，同理，编译片段着色程序时必须选用当前图形硬件支持的片段profile 。\n\n顶点 profile 和片段 profile 又基于 OpenGL 和 DirectX 的不同版本或扩展，划分为各种版本，当前 Cg compiler 所支持的 profiles 有：\n\n\tOpenGL ARB vertex programs\n\t        Runtime profile: CG_PROFILE_ARBVP1\n\t        Compiler option: _profile arbvp1\n\tOpenGL ARB fragment programs\n\t        Runtime profile: CG_PROFILE_ARBFP1\n\t        Compiler option: _profile arbfp1\n\t......\n\n\n","source":"_posts/Unity-ShaderLab基础（二）.md","raw":"---\ntitle: Unity ShaderLab基础（二）Cg语言\ndate: 2016-09-06 11:55:59\ntags: Unity,ShaderLab,Cg\ncategories: Unity\n---\n学习一门新的语言，有几个基本需要掌握的：数据类型（基本数据类型和结构类型），基本语法（表达式和控制语句等），编译和运行方式，这一点在CPU编程语言和GPU编程语言中是相似的，Cg作为一门GPU图形学语言也是如此。\n<!--more-->\n\n## Cg的数据类型：\n### 1.基本数据类型\nCg支持7种基本的数据类型，分别是：\n\n- **float**， 32 位浮点数据，一个符号位。浮点数据类型被所有的 profile 支持\n- **half**，16 为浮点数据\n- **int**，32 位整形数据，有些 profile 会将 int 类型作为 float 类型使用\n- **fixed**，12 位定点数，被所有的 fragment profiles 所支持\n- **bool**，布尔数据，通常用于 if 和条件操作符（ ?: ） ，布尔数据类型被所有的profiles 支持\n- **simpler***， 纹理对象的句柄（ the handle to a texture object ） ，分为 6 类：\nsampler, sampler1D, sampler2D, sampler3D, samplerCUBE, 和 samplerRECT 。DirectX profiles 不支持 samplerRECT 类型， 除此之外这些类型被所有的 pixelprofiles 和 NV40 vertex program profile 所支持（ CgUsersManual 30 页） 。由此可见，在不远的未来，顶点程序也将广泛支持纹理操作\n- **string**，字符类型，该类型不被当前存在的 profile 所支持，实际上也没有必要在 Cg 程序中用到字符类型，但是你可以通过 Cg runtime API 声明该类型变量，并赋值；因此，该类型变量可以保存 Cg 文件的信息。\n\n>前6种类型为常用类型，**string**类型几乎不使用。\n\n### 2.其他内置数据类型：\n\n- **向量**\n\nCg还提供了内置的向量数据类型 (built-in vector data types) ，内置的向量数据类型基于基础数据类型。 例如： float4， 表示 float 类型的 4 元向量； bool4， 表示 bool类型 4 元向量。\n（注意： **向量最长不能超过 4 元**， 即在 Cg 程序中可以声明 float1 、 float2 、 float3 、float4 类型的数组变量，但是不能声明超过 4 元的向量。）\n向量初始化方式一般为：\n\n\tfloat4 array = float4(1.0, 2.0, 3.0, 4.0);\n较长的向量还可以通过较短的向量进行构建：\n\n\tfloat2 a = float2(1.0, 1.0);  \n\tfloat4 b = float4(a, 0.0, 0.0);  \n\n- **矩阵**\n\nCg还提供矩阵数据类型，不过**最大的维数不能超过4X4阶**，例如：\n\n\tfloat1x1 matrix1;//等价于float matirx1; x是字符，并不是乘号！  \n\tfloat2x3 matrix2;//表示 2*3 阶矩阵，包含6个float类型数据  \n\tfloat4x2 matrix3;//表示 4*2 阶矩阵，包含8个float类型数据  \n\tfloat4x4 matrix4;//表示 4*4 阶矩阵，这是最大的维数  \n矩阵初始化：\n\n\tfloat2x3 matrix5 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};  \n\n- **数组**\n\n**数组数据类型在Cg中的作用：作为函数的形参，用于大量数据的传递**，例如：顶点参数数组、光照参数数据等。\n\n一维数组：\n\n\tfloat a[10];//声明了一个数组，包含 10 个 float 类型数据  \n\tfloat a[4] = {1.0, 2.0, 3.0, 4.0}; //初始化一个数组  \n\tint length = a.length;//获取数组长度  \n多维数组：\n\n\tfloat b[2][3] = {{0.0, 0.0, 0.0},{1.0, 1.0, 1.0}};  \n\tint length1 = b.length; // length1 值为 2  \n\tint length2 = b[0].length; // length2 值为 3  \n\n\n注：在Cg中，向量、矩阵与数组是完全不同的，向量和矩阵是内置的数据类型，而数组则是一种数据结构。\n\n- **类型转换**\n\nCg 中的类型转换和 C 语言中的类型转换很类似。 C 语言中类型转换可以是**强制类型转换**，也可以是**隐式转换**，如果是后者，则数据类型从低精度向高精度转换。在 Cg 语言中也是如此：\n\n\tfloat a = 1.0;  \n\thalf b = 2.0;  \n\tfloat c = a+b; //等价于 float c = a + (float)b;  \n当有类型变量和无类型常量数据进行运算时，该常量数据不做类型转换，例如：\n\n\tfloat a = 1.0;  \n\tfloat b = a + 2.0;//2.0为无类型常量数据，编译时作为float 类型\nCg 语言中对于常量数据可以加上类型后缀，表示该数据的类型，例如：\n\n\tfloat a = 1.0;  \n\tfloat b = a + 2.0h;//2.0h为half类型常量数据，运算是需要做类型转换\n常量的类型后缀有3种：\n\n- f：表示float\n- h：表示half\n- x：表示fixed\n\n---\n\n## Cg的语法：\nCg的关系操作符、逻辑操作符、位移操作符都与C语言有相似之处，需要特别注意的是**Swizzle操作符**，例如：\n\n\tfloat4(a, b, c, d).xyz \t//等价于 float3(a, b, c)\n\tfloat4(a, b, c, d).xyy \t//等价于 float3(a, b, b)\n\tfloat4(a, b, c, d).wzyx //等价于 float4(d, c, b, a)\n\tfloat4(a, b, c, d).w \t//等价于 float d\n\n---\n\n## Cg的编译：\n### 1.编译方式：\n- **编译程序**：\n\n计算机只能理解和执行由 0 、 1 序列（电压序列）构成的机器语言，所以汇编语言和高级语言程序都需要进行翻译才能被计算机所理解， 担负这一任务的程序称为语言处理程序，通常也被称为编译程序。\n\n- **静态编译**：\n\n一旦编译后，除非改变程序代码，否则不需要重新编译，这种方式称为静态编译（ static compilation ） 。静态编译最重要的特征是：**一旦编译为可执行文件，在可执行文件运行期间不再需要源码信息**。\n\n- **动态编译**：\n\n编译程序和源码都要参与到程序的运行过程中，就像脚本语言（Lua、JavaScrpit等），源码嵌套到调用的宿主语言程序中，运行时进行编译。\n\n**Cg通常采用动态编译的方式（Cg也支持静态编译方式），即在宿主程序运行时，利用Cg运行库（Cg Runtimer Library）动态编译Cg代码。使用动态编译的方式，可以将Cg程序当做一个脚本，随时修改随时运行，节省时间，在OGRE图形引擎中就采用了这种方式。**\n\n### 2.编译器：\nCg 编译器首先将 Cg 程序翻译成可被图形 API （ OpenGL 和 Direct3D ）所接受的形式， 然后应用程序使用适当的 OpenGL 和 Direct3D 命令将翻译后的 Cg 程序传递给图形处理器， OpenGL 和 Direct3D 驱动程序最后把它翻译成图形处理器所需要的硬件可执行格式。**NVIDIA 提供的 Cg 编译器为 cgc.exe**。\n\n* 下载[Cg Toolkit](https://developer.nvidia.com/cg-toolkit-download)；\n* 安装之后，在安装目录的Cg\\bin中就有cgc.exe；\n* 打开命令行窗口，输入 ```cgc -h``` ，假如不报错则说明安装成功。\n\n### 3.Cg指令：\n\n**编译指令**\n\n\tcgc [options] file\n\n* ```[options]``` 表示可选配置项;\n* ```file``` 表示 Cg 程序文件名。\n\n例如，比较典型的编译方式：\n\n\tcgc -profile glslv -entry main_v test.cg\n \n* ```-profile``` 是profile配置项名；\n* ```glslv``` 是当前所使用的profile名称；\n* ```-entry``` 着色程序的入口函数名称配置项；\n* ```main_v``` 是顶点着色程序的入口函数名；\n* ```test.cg``` 是当前的着色程序文件名（必须带后缀名）,Cg源码文件需以**.cg**为后缀名；\n\n将Cg语言所写的着色程序转换为使用**GLSL**或**HLSL**所编写的程序：\n\n\tcgc –profile glslv –o direct.glsl –entry main_v test.cg\n表示编译文件 test.cg 中的顶点着色程序， 入口函数名为 main_v ， 并将顶点着色程序转换为 glsl 程序，然后保存成文件 direct.glsl 。\n\n**备注**：GPU编程，是无法跟踪调试着色程序的，一个着色程序，语法错误可以通过编译器发现，但是代码的逻辑错误只能认真查找。\n\n\n>关于Cg的更详细的介绍可以参考这篇博客，利用OpenGL、C++和Cg进行Cg的测试：[【GPU编程】开始Cg之旅，编译自己的第一个Cg程序](http://blog.csdn.net/xiajun07061225/article/details/6937272)\n\n### 4.**Cg Profiles:**\nCg 程序的编译不但依赖于宿主程序所使用的三维编程接口，而且依赖于图形硬件环境，因为图形硬件自身的限制，不一定支持某种 Cg 语句。\n**被特定的图形硬件环境或 AIP 所支持的 Cg 语言子集，被称为Cg Profiles** 。\n\nprofile分为：**顶点程序的profile**和**片段程序的profile**，所以编译顶点着色程序时必须选用当前图形硬件支持的顶点profile ，同理，编译片段着色程序时必须选用当前图形硬件支持的片段profile 。\n\n顶点 profile 和片段 profile 又基于 OpenGL 和 DirectX 的不同版本或扩展，划分为各种版本，当前 Cg compiler 所支持的 profiles 有：\n\n\tOpenGL ARB vertex programs\n\t        Runtime profile: CG_PROFILE_ARBVP1\n\t        Compiler option: _profile arbvp1\n\tOpenGL ARB fragment programs\n\t        Runtime profile: CG_PROFILE_ARBFP1\n\t        Compiler option: _profile arbfp1\n\t......\n\n\n","slug":"Unity-ShaderLab基础（二）","published":1,"updated":"2017-06-24T02:13:49.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfkp000z9gfjzybx1irx","content":"<p>学习一门新的语言，有几个基本需要掌握的：数据类型（基本数据类型和结构类型），基本语法（表达式和控制语句等），编译和运行方式，这一点在CPU编程语言和GPU编程语言中是相似的，Cg作为一门GPU图形学语言也是如此。<br><a id=\"more\"></a></p>\n<h2 id=\"Cg的数据类型：\"><a href=\"#Cg的数据类型：\" class=\"headerlink\" title=\"Cg的数据类型：\"></a>Cg的数据类型：</h2><h3 id=\"1-基本数据类型\"><a href=\"#1-基本数据类型\" class=\"headerlink\" title=\"1.基本数据类型\"></a>1.基本数据类型</h3><p>Cg支持7种基本的数据类型，分别是：</p>\n<ul>\n<li><strong>float</strong>， 32 位浮点数据，一个符号位。浮点数据类型被所有的 profile 支持</li>\n<li><strong>half</strong>，16 为浮点数据</li>\n<li><strong>int</strong>，32 位整形数据，有些 profile 会将 int 类型作为 float 类型使用</li>\n<li><strong>fixed</strong>，12 位定点数，被所有的 fragment profiles 所支持</li>\n<li><strong>bool</strong>，布尔数据，通常用于 if 和条件操作符（ ?: ） ，布尔数据类型被所有的profiles 支持</li>\n<li><strong>simpler*</strong>， 纹理对象的句柄（ the handle to a texture object ） ，分为 6 类：<br>sampler, sampler1D, sampler2D, sampler3D, samplerCUBE, 和 samplerRECT 。DirectX profiles 不支持 samplerRECT 类型， 除此之外这些类型被所有的 pixelprofiles 和 NV40 vertex program profile 所支持（ CgUsersManual 30 页） 。由此可见，在不远的未来，顶点程序也将广泛支持纹理操作</li>\n<li><strong>string</strong>，字符类型，该类型不被当前存在的 profile 所支持，实际上也没有必要在 Cg 程序中用到字符类型，但是你可以通过 Cg runtime API 声明该类型变量，并赋值；因此，该类型变量可以保存 Cg 文件的信息。</li>\n</ul>\n<blockquote>\n<p>前6种类型为常用类型，<strong>string</strong>类型几乎不使用。</p>\n</blockquote>\n<h3 id=\"2-其他内置数据类型：\"><a href=\"#2-其他内置数据类型：\" class=\"headerlink\" title=\"2.其他内置数据类型：\"></a>2.其他内置数据类型：</h3><ul>\n<li><strong>向量</strong></li>\n</ul>\n<p>Cg还提供了内置的向量数据类型 (built-in vector data types) ，内置的向量数据类型基于基础数据类型。 例如： float4， 表示 float 类型的 4 元向量； bool4， 表示 bool类型 4 元向量。<br>（注意： <strong>向量最长不能超过 4 元</strong>， 即在 Cg 程序中可以声明 float1 、 float2 、 float3 、float4 类型的数组变量，但是不能声明超过 4 元的向量。）<br>向量初始化方式一般为：</p>\n<pre><code>float4 array = float4(1.0, 2.0, 3.0, 4.0);\n</code></pre><p>较长的向量还可以通过较短的向量进行构建：</p>\n<pre><code>float2 a = float2(1.0, 1.0);  \nfloat4 b = float4(a, 0.0, 0.0);  \n</code></pre><ul>\n<li><strong>矩阵</strong></li>\n</ul>\n<p>Cg还提供矩阵数据类型，不过<strong>最大的维数不能超过4X4阶</strong>，例如：</p>\n<pre><code>float1x1 matrix1;//等价于float matirx1; x是字符，并不是乘号！  \nfloat2x3 matrix2;//表示 2*3 阶矩阵，包含6个float类型数据  \nfloat4x2 matrix3;//表示 4*2 阶矩阵，包含8个float类型数据  \nfloat4x4 matrix4;//表示 4*4 阶矩阵，这是最大的维数  \n</code></pre><p>矩阵初始化：</p>\n<pre><code>float2x3 matrix5 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};  \n</code></pre><ul>\n<li><strong>数组</strong></li>\n</ul>\n<p><strong>数组数据类型在Cg中的作用：作为函数的形参，用于大量数据的传递</strong>，例如：顶点参数数组、光照参数数据等。</p>\n<p>一维数组：</p>\n<pre><code>float a[10];//声明了一个数组，包含 10 个 float 类型数据  \nfloat a[4] = {1.0, 2.0, 3.0, 4.0}; //初始化一个数组  \nint length = a.length;//获取数组长度  \n</code></pre><p>多维数组：</p>\n<pre><code>float b[2][3] = {{0.0, 0.0, 0.0},{1.0, 1.0, 1.0}};  \nint length1 = b.length; // length1 值为 2  \nint length2 = b[0].length; // length2 值为 3  \n</code></pre><p>注：在Cg中，向量、矩阵与数组是完全不同的，向量和矩阵是内置的数据类型，而数组则是一种数据结构。</p>\n<ul>\n<li><strong>类型转换</strong></li>\n</ul>\n<p>Cg 中的类型转换和 C 语言中的类型转换很类似。 C 语言中类型转换可以是<strong>强制类型转换</strong>，也可以是<strong>隐式转换</strong>，如果是后者，则数据类型从低精度向高精度转换。在 Cg 语言中也是如此：</p>\n<pre><code>float a = 1.0;  \nhalf b = 2.0;  \nfloat c = a+b; //等价于 float c = a + (float)b;  \n</code></pre><p>当有类型变量和无类型常量数据进行运算时，该常量数据不做类型转换，例如：</p>\n<pre><code>float a = 1.0;  \nfloat b = a + 2.0;//2.0为无类型常量数据，编译时作为float 类型\n</code></pre><p>Cg 语言中对于常量数据可以加上类型后缀，表示该数据的类型，例如：</p>\n<pre><code>float a = 1.0;  \nfloat b = a + 2.0h;//2.0h为half类型常量数据，运算是需要做类型转换\n</code></pre><p>常量的类型后缀有3种：</p>\n<ul>\n<li>f：表示float</li>\n<li>h：表示half</li>\n<li>x：表示fixed</li>\n</ul>\n<hr>\n<h2 id=\"Cg的语法：\"><a href=\"#Cg的语法：\" class=\"headerlink\" title=\"Cg的语法：\"></a>Cg的语法：</h2><p>Cg的关系操作符、逻辑操作符、位移操作符都与C语言有相似之处，需要特别注意的是<strong>Swizzle操作符</strong>，例如：</p>\n<pre><code>float4(a, b, c, d).xyz     //等价于 float3(a, b, c)\nfloat4(a, b, c, d).xyy     //等价于 float3(a, b, b)\nfloat4(a, b, c, d).wzyx //等价于 float4(d, c, b, a)\nfloat4(a, b, c, d).w     //等价于 float d\n</code></pre><hr>\n<h2 id=\"Cg的编译：\"><a href=\"#Cg的编译：\" class=\"headerlink\" title=\"Cg的编译：\"></a>Cg的编译：</h2><h3 id=\"1-编译方式：\"><a href=\"#1-编译方式：\" class=\"headerlink\" title=\"1.编译方式：\"></a>1.编译方式：</h3><ul>\n<li><strong>编译程序</strong>：</li>\n</ul>\n<p>计算机只能理解和执行由 0 、 1 序列（电压序列）构成的机器语言，所以汇编语言和高级语言程序都需要进行翻译才能被计算机所理解， 担负这一任务的程序称为语言处理程序，通常也被称为编译程序。</p>\n<ul>\n<li><strong>静态编译</strong>：</li>\n</ul>\n<p>一旦编译后，除非改变程序代码，否则不需要重新编译，这种方式称为静态编译（ static compilation ） 。静态编译最重要的特征是：<strong>一旦编译为可执行文件，在可执行文件运行期间不再需要源码信息</strong>。</p>\n<ul>\n<li><strong>动态编译</strong>：</li>\n</ul>\n<p>编译程序和源码都要参与到程序的运行过程中，就像脚本语言（Lua、JavaScrpit等），源码嵌套到调用的宿主语言程序中，运行时进行编译。</p>\n<p><strong>Cg通常采用动态编译的方式（Cg也支持静态编译方式），即在宿主程序运行时，利用Cg运行库（Cg Runtimer Library）动态编译Cg代码。使用动态编译的方式，可以将Cg程序当做一个脚本，随时修改随时运行，节省时间，在OGRE图形引擎中就采用了这种方式。</strong></p>\n<h3 id=\"2-编译器：\"><a href=\"#2-编译器：\" class=\"headerlink\" title=\"2.编译器：\"></a>2.编译器：</h3><p>Cg 编译器首先将 Cg 程序翻译成可被图形 API （ OpenGL 和 Direct3D ）所接受的形式， 然后应用程序使用适当的 OpenGL 和 Direct3D 命令将翻译后的 Cg 程序传递给图形处理器， OpenGL 和 Direct3D 驱动程序最后把它翻译成图形处理器所需要的硬件可执行格式。<strong>NVIDIA 提供的 Cg 编译器为 cgc.exe</strong>。</p>\n<ul>\n<li>下载<a href=\"https://developer.nvidia.com/cg-toolkit-download\" target=\"_blank\" rel=\"external\">Cg Toolkit</a>；</li>\n<li>安装之后，在安装目录的Cg\\bin中就有cgc.exe；</li>\n<li>打开命令行窗口，输入 <code>cgc -h</code> ，假如不报错则说明安装成功。</li>\n</ul>\n<h3 id=\"3-Cg指令：\"><a href=\"#3-Cg指令：\" class=\"headerlink\" title=\"3.Cg指令：\"></a>3.Cg指令：</h3><p><strong>编译指令</strong></p>\n<pre><code>cgc [options] file\n</code></pre><ul>\n<li><code>[options]</code> 表示可选配置项;</li>\n<li><code>file</code> 表示 Cg 程序文件名。</li>\n</ul>\n<p>例如，比较典型的编译方式：</p>\n<pre><code>cgc -profile glslv -entry main_v test.cg\n</code></pre><ul>\n<li><code>-profile</code> 是profile配置项名；</li>\n<li><code>glslv</code> 是当前所使用的profile名称；</li>\n<li><code>-entry</code> 着色程序的入口函数名称配置项；</li>\n<li><code>main_v</code> 是顶点着色程序的入口函数名；</li>\n<li><code>test.cg</code> 是当前的着色程序文件名（必须带后缀名）,Cg源码文件需以<strong>.cg</strong>为后缀名；</li>\n</ul>\n<p>将Cg语言所写的着色程序转换为使用<strong>GLSL</strong>或<strong>HLSL</strong>所编写的程序：</p>\n<pre><code>cgc –profile glslv –o direct.glsl –entry main_v test.cg\n</code></pre><p>表示编译文件 test.cg 中的顶点着色程序， 入口函数名为 main_v ， 并将顶点着色程序转换为 glsl 程序，然后保存成文件 direct.glsl 。</p>\n<p><strong>备注</strong>：GPU编程，是无法跟踪调试着色程序的，一个着色程序，语法错误可以通过编译器发现，但是代码的逻辑错误只能认真查找。</p>\n<blockquote>\n<p>关于Cg的更详细的介绍可以参考这篇博客，利用OpenGL、C++和Cg进行Cg的测试：<a href=\"http://blog.csdn.net/xiajun07061225/article/details/6937272\" target=\"_blank\" rel=\"external\">【GPU编程】开始Cg之旅，编译自己的第一个Cg程序</a></p>\n</blockquote>\n<h3 id=\"4-Cg-Profiles\"><a href=\"#4-Cg-Profiles\" class=\"headerlink\" title=\"4.Cg Profiles:\"></a>4.<strong>Cg Profiles:</strong></h3><p>Cg 程序的编译不但依赖于宿主程序所使用的三维编程接口，而且依赖于图形硬件环境，因为图形硬件自身的限制，不一定支持某种 Cg 语句。<br><strong>被特定的图形硬件环境或 AIP 所支持的 Cg 语言子集，被称为Cg Profiles</strong> 。</p>\n<p>profile分为：<strong>顶点程序的profile</strong>和<strong>片段程序的profile</strong>，所以编译顶点着色程序时必须选用当前图形硬件支持的顶点profile ，同理，编译片段着色程序时必须选用当前图形硬件支持的片段profile 。</p>\n<p>顶点 profile 和片段 profile 又基于 OpenGL 和 DirectX 的不同版本或扩展，划分为各种版本，当前 Cg compiler 所支持的 profiles 有：</p>\n<pre><code>OpenGL ARB vertex programs\n        Runtime profile: CG_PROFILE_ARBVP1\n        Compiler option: _profile arbvp1\nOpenGL ARB fragment programs\n        Runtime profile: CG_PROFILE_ARBFP1\n        Compiler option: _profile arbfp1\n......\n</code></pre>","excerpt":"<p>学习一门新的语言，有几个基本需要掌握的：数据类型（基本数据类型和结构类型），基本语法（表达式和控制语句等），编译和运行方式，这一点在CPU编程语言和GPU编程语言中是相似的，Cg作为一门GPU图形学语言也是如此。<br>","more":"</p>\n<h2 id=\"Cg的数据类型：\"><a href=\"#Cg的数据类型：\" class=\"headerlink\" title=\"Cg的数据类型：\"></a>Cg的数据类型：</h2><h3 id=\"1-基本数据类型\"><a href=\"#1-基本数据类型\" class=\"headerlink\" title=\"1.基本数据类型\"></a>1.基本数据类型</h3><p>Cg支持7种基本的数据类型，分别是：</p>\n<ul>\n<li><strong>float</strong>， 32 位浮点数据，一个符号位。浮点数据类型被所有的 profile 支持</li>\n<li><strong>half</strong>，16 为浮点数据</li>\n<li><strong>int</strong>，32 位整形数据，有些 profile 会将 int 类型作为 float 类型使用</li>\n<li><strong>fixed</strong>，12 位定点数，被所有的 fragment profiles 所支持</li>\n<li><strong>bool</strong>，布尔数据，通常用于 if 和条件操作符（ ?: ） ，布尔数据类型被所有的profiles 支持</li>\n<li><strong>simpler*</strong>， 纹理对象的句柄（ the handle to a texture object ） ，分为 6 类：<br>sampler, sampler1D, sampler2D, sampler3D, samplerCUBE, 和 samplerRECT 。DirectX profiles 不支持 samplerRECT 类型， 除此之外这些类型被所有的 pixelprofiles 和 NV40 vertex program profile 所支持（ CgUsersManual 30 页） 。由此可见，在不远的未来，顶点程序也将广泛支持纹理操作</li>\n<li><strong>string</strong>，字符类型，该类型不被当前存在的 profile 所支持，实际上也没有必要在 Cg 程序中用到字符类型，但是你可以通过 Cg runtime API 声明该类型变量，并赋值；因此，该类型变量可以保存 Cg 文件的信息。</li>\n</ul>\n<blockquote>\n<p>前6种类型为常用类型，<strong>string</strong>类型几乎不使用。</p>\n</blockquote>\n<h3 id=\"2-其他内置数据类型：\"><a href=\"#2-其他内置数据类型：\" class=\"headerlink\" title=\"2.其他内置数据类型：\"></a>2.其他内置数据类型：</h3><ul>\n<li><strong>向量</strong></li>\n</ul>\n<p>Cg还提供了内置的向量数据类型 (built-in vector data types) ，内置的向量数据类型基于基础数据类型。 例如： float4， 表示 float 类型的 4 元向量； bool4， 表示 bool类型 4 元向量。<br>（注意： <strong>向量最长不能超过 4 元</strong>， 即在 Cg 程序中可以声明 float1 、 float2 、 float3 、float4 类型的数组变量，但是不能声明超过 4 元的向量。）<br>向量初始化方式一般为：</p>\n<pre><code>float4 array = float4(1.0, 2.0, 3.0, 4.0);\n</code></pre><p>较长的向量还可以通过较短的向量进行构建：</p>\n<pre><code>float2 a = float2(1.0, 1.0);  \nfloat4 b = float4(a, 0.0, 0.0);  \n</code></pre><ul>\n<li><strong>矩阵</strong></li>\n</ul>\n<p>Cg还提供矩阵数据类型，不过<strong>最大的维数不能超过4X4阶</strong>，例如：</p>\n<pre><code>float1x1 matrix1;//等价于float matirx1; x是字符，并不是乘号！  \nfloat2x3 matrix2;//表示 2*3 阶矩阵，包含6个float类型数据  \nfloat4x2 matrix3;//表示 4*2 阶矩阵，包含8个float类型数据  \nfloat4x4 matrix4;//表示 4*4 阶矩阵，这是最大的维数  \n</code></pre><p>矩阵初始化：</p>\n<pre><code>float2x3 matrix5 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};  \n</code></pre><ul>\n<li><strong>数组</strong></li>\n</ul>\n<p><strong>数组数据类型在Cg中的作用：作为函数的形参，用于大量数据的传递</strong>，例如：顶点参数数组、光照参数数据等。</p>\n<p>一维数组：</p>\n<pre><code>float a[10];//声明了一个数组，包含 10 个 float 类型数据  \nfloat a[4] = {1.0, 2.0, 3.0, 4.0}; //初始化一个数组  \nint length = a.length;//获取数组长度  \n</code></pre><p>多维数组：</p>\n<pre><code>float b[2][3] = {{0.0, 0.0, 0.0},{1.0, 1.0, 1.0}};  \nint length1 = b.length; // length1 值为 2  \nint length2 = b[0].length; // length2 值为 3  \n</code></pre><p>注：在Cg中，向量、矩阵与数组是完全不同的，向量和矩阵是内置的数据类型，而数组则是一种数据结构。</p>\n<ul>\n<li><strong>类型转换</strong></li>\n</ul>\n<p>Cg 中的类型转换和 C 语言中的类型转换很类似。 C 语言中类型转换可以是<strong>强制类型转换</strong>，也可以是<strong>隐式转换</strong>，如果是后者，则数据类型从低精度向高精度转换。在 Cg 语言中也是如此：</p>\n<pre><code>float a = 1.0;  \nhalf b = 2.0;  \nfloat c = a+b; //等价于 float c = a + (float)b;  \n</code></pre><p>当有类型变量和无类型常量数据进行运算时，该常量数据不做类型转换，例如：</p>\n<pre><code>float a = 1.0;  \nfloat b = a + 2.0;//2.0为无类型常量数据，编译时作为float 类型\n</code></pre><p>Cg 语言中对于常量数据可以加上类型后缀，表示该数据的类型，例如：</p>\n<pre><code>float a = 1.0;  \nfloat b = a + 2.0h;//2.0h为half类型常量数据，运算是需要做类型转换\n</code></pre><p>常量的类型后缀有3种：</p>\n<ul>\n<li>f：表示float</li>\n<li>h：表示half</li>\n<li>x：表示fixed</li>\n</ul>\n<hr>\n<h2 id=\"Cg的语法：\"><a href=\"#Cg的语法：\" class=\"headerlink\" title=\"Cg的语法：\"></a>Cg的语法：</h2><p>Cg的关系操作符、逻辑操作符、位移操作符都与C语言有相似之处，需要特别注意的是<strong>Swizzle操作符</strong>，例如：</p>\n<pre><code>float4(a, b, c, d).xyz     //等价于 float3(a, b, c)\nfloat4(a, b, c, d).xyy     //等价于 float3(a, b, b)\nfloat4(a, b, c, d).wzyx //等价于 float4(d, c, b, a)\nfloat4(a, b, c, d).w     //等价于 float d\n</code></pre><hr>\n<h2 id=\"Cg的编译：\"><a href=\"#Cg的编译：\" class=\"headerlink\" title=\"Cg的编译：\"></a>Cg的编译：</h2><h3 id=\"1-编译方式：\"><a href=\"#1-编译方式：\" class=\"headerlink\" title=\"1.编译方式：\"></a>1.编译方式：</h3><ul>\n<li><strong>编译程序</strong>：</li>\n</ul>\n<p>计算机只能理解和执行由 0 、 1 序列（电压序列）构成的机器语言，所以汇编语言和高级语言程序都需要进行翻译才能被计算机所理解， 担负这一任务的程序称为语言处理程序，通常也被称为编译程序。</p>\n<ul>\n<li><strong>静态编译</strong>：</li>\n</ul>\n<p>一旦编译后，除非改变程序代码，否则不需要重新编译，这种方式称为静态编译（ static compilation ） 。静态编译最重要的特征是：<strong>一旦编译为可执行文件，在可执行文件运行期间不再需要源码信息</strong>。</p>\n<ul>\n<li><strong>动态编译</strong>：</li>\n</ul>\n<p>编译程序和源码都要参与到程序的运行过程中，就像脚本语言（Lua、JavaScrpit等），源码嵌套到调用的宿主语言程序中，运行时进行编译。</p>\n<p><strong>Cg通常采用动态编译的方式（Cg也支持静态编译方式），即在宿主程序运行时，利用Cg运行库（Cg Runtimer Library）动态编译Cg代码。使用动态编译的方式，可以将Cg程序当做一个脚本，随时修改随时运行，节省时间，在OGRE图形引擎中就采用了这种方式。</strong></p>\n<h3 id=\"2-编译器：\"><a href=\"#2-编译器：\" class=\"headerlink\" title=\"2.编译器：\"></a>2.编译器：</h3><p>Cg 编译器首先将 Cg 程序翻译成可被图形 API （ OpenGL 和 Direct3D ）所接受的形式， 然后应用程序使用适当的 OpenGL 和 Direct3D 命令将翻译后的 Cg 程序传递给图形处理器， OpenGL 和 Direct3D 驱动程序最后把它翻译成图形处理器所需要的硬件可执行格式。<strong>NVIDIA 提供的 Cg 编译器为 cgc.exe</strong>。</p>\n<ul>\n<li>下载<a href=\"https://developer.nvidia.com/cg-toolkit-download\">Cg Toolkit</a>；</li>\n<li>安装之后，在安装目录的Cg\\bin中就有cgc.exe；</li>\n<li>打开命令行窗口，输入 <code>cgc -h</code> ，假如不报错则说明安装成功。</li>\n</ul>\n<h3 id=\"3-Cg指令：\"><a href=\"#3-Cg指令：\" class=\"headerlink\" title=\"3.Cg指令：\"></a>3.Cg指令：</h3><p><strong>编译指令</strong></p>\n<pre><code>cgc [options] file\n</code></pre><ul>\n<li><code>[options]</code> 表示可选配置项;</li>\n<li><code>file</code> 表示 Cg 程序文件名。</li>\n</ul>\n<p>例如，比较典型的编译方式：</p>\n<pre><code>cgc -profile glslv -entry main_v test.cg\n</code></pre><ul>\n<li><code>-profile</code> 是profile配置项名；</li>\n<li><code>glslv</code> 是当前所使用的profile名称；</li>\n<li><code>-entry</code> 着色程序的入口函数名称配置项；</li>\n<li><code>main_v</code> 是顶点着色程序的入口函数名；</li>\n<li><code>test.cg</code> 是当前的着色程序文件名（必须带后缀名）,Cg源码文件需以<strong>.cg</strong>为后缀名；</li>\n</ul>\n<p>将Cg语言所写的着色程序转换为使用<strong>GLSL</strong>或<strong>HLSL</strong>所编写的程序：</p>\n<pre><code>cgc –profile glslv –o direct.glsl –entry main_v test.cg\n</code></pre><p>表示编译文件 test.cg 中的顶点着色程序， 入口函数名为 main_v ， 并将顶点着色程序转换为 glsl 程序，然后保存成文件 direct.glsl 。</p>\n<p><strong>备注</strong>：GPU编程，是无法跟踪调试着色程序的，一个着色程序，语法错误可以通过编译器发现，但是代码的逻辑错误只能认真查找。</p>\n<blockquote>\n<p>关于Cg的更详细的介绍可以参考这篇博客，利用OpenGL、C++和Cg进行Cg的测试：<a href=\"http://blog.csdn.net/xiajun07061225/article/details/6937272\">【GPU编程】开始Cg之旅，编译自己的第一个Cg程序</a></p>\n</blockquote>\n<h3 id=\"4-Cg-Profiles\"><a href=\"#4-Cg-Profiles\" class=\"headerlink\" title=\"4.Cg Profiles:\"></a>4.<strong>Cg Profiles:</strong></h3><p>Cg 程序的编译不但依赖于宿主程序所使用的三维编程接口，而且依赖于图形硬件环境，因为图形硬件自身的限制，不一定支持某种 Cg 语句。<br><strong>被特定的图形硬件环境或 AIP 所支持的 Cg 语言子集，被称为Cg Profiles</strong> 。</p>\n<p>profile分为：<strong>顶点程序的profile</strong>和<strong>片段程序的profile</strong>，所以编译顶点着色程序时必须选用当前图形硬件支持的顶点profile ，同理，编译片段着色程序时必须选用当前图形硬件支持的片段profile 。</p>\n<p>顶点 profile 和片段 profile 又基于 OpenGL 和 DirectX 的不同版本或扩展，划分为各种版本，当前 Cg compiler 所支持的 profiles 有：</p>\n<pre><code>OpenGL ARB vertex programs\n        Runtime profile: CG_PROFILE_ARBVP1\n        Compiler option: _profile arbvp1\nOpenGL ARB fragment programs\n        Runtime profile: CG_PROFILE_ARBFP1\n        Compiler option: _profile arbfp1\n......\n</code></pre>"},{"title":"Unity3D —— Socket通信","date":"2016-09-19T01:41:16.000Z","_content":"### 前言：\n在开始编写代码之前，我们首先需要明确：联网方式、联网步骤、数据收发以及协议数据格式\n\n当然在设计时也应该减低代码的耦合性，尽量使得网络层可以在其他地方进行复用，这就需要我们进行接口式的开发。我们这里使用的通信模式是Socket强连接的通信方式，并且使用C#作为编程语言，其实与.NET的Socket通信是一致的。\n\n### 一、设计思想：\n为了方便测试，我直接使用C#写的一个控制台应用，作为服务器，等待客户端的连接，然后使用Unity建立Socket客户端去连接服务器，进行简单的数据通信。这么设计的原因是都基于.net进行开发，也方便理解。\n\n<!--more-->\n\n### 二、实现步骤：\n对于网络通信有所了解的都应该知道，数据在网络传输的格式必须以字节流的形式进行，那么免不了要对字节流进行写入和读出操作，为了方便后面的操作，我们有必要封装一个读写字节流的操作类，在这里我定义了一个字节流的操作类ByteBuffer类，用于将各个类型数据写入流中，也可从字节流中读取各种类型的数据：\n```C#\nusing System.IO;  \nusing System.Text;  \nusing System;  \n  \nnamespace Net {  \n    public class ByteBuffer {  \n        MemoryStream stream = null;  \n        BinaryWriter writer = null;  \n        BinaryReader reader = null;  \n  \n        public ByteBuffer() {  \n            stream = new MemoryStream();  \n            writer = new BinaryWriter(stream);  \n        }  \n  \n        public ByteBuffer(byte[] data) {  \n            if (data != null) {  \n                stream = new MemoryStream(data);  \n                reader = new BinaryReader(stream);  \n            } else {  \n                stream = new MemoryStream();  \n                writer = new BinaryWriter(stream);  \n            }  \n        }  \n  \n        public void Close() {  \n            if (writer != null) writer.Close();  \n            if (reader != null) reader.Close();  \n  \n            stream.Close();  \n            writer = null;  \n            reader = null;  \n            stream = null;  \n        }  \n  \n        public void WriteByte(byte v) {  \n            writer.Write(v);  \n        }  \n  \n        public void WriteInt(int v) {  \n            writer.Write((int)v);  \n        }  \n  \n        public void WriteShort(ushort v) {  \n            writer.Write((ushort)v);  \n        }  \n  \n        public void WriteLong(long v) {  \n            writer.Write((long)v);  \n        }  \n  \n        public void WriteFloat(float v) {  \n            byte[] temp = BitConverter.GetBytes(v);  \n            Array.Reverse(temp);  \n            writer.Write(BitConverter.ToSingle(temp, 0));  \n        }  \n  \n        public void WriteDouble(double v) {  \n            byte[] temp = BitConverter.GetBytes(v);  \n            Array.Reverse(temp);  \n            writer.Write(BitConverter.ToDouble(temp, 0));  \n        }  \n  \n        public void WriteString(string v) {  \n            byte[] bytes = Encoding.UTF8.GetBytes(v);  \n            writer.Write((ushort)bytes.Length);  \n            writer.Write(bytes);  \n        }  \n  \n        public void WriteBytes(byte[] v) {  \n            writer.Write((int)v.Length);  \n            writer.Write(v);  \n        }  \n  \n        public byte ReadByte() {  \n            return reader.ReadByte();  \n        }  \n  \n        public int ReadInt() {  \n            return (int)reader.ReadInt32();  \n        }  \n  \n        public ushort ReadShort() {  \n            return (ushort)reader.ReadInt16();  \n        }  \n  \n        public long ReadLong() {  \n            return (long)reader.ReadInt64();  \n        }  \n  \n        public float ReadFloat() {  \n            byte[] temp = BitConverter.GetBytes(reader.ReadSingle());  \n            Array.Reverse(temp);  \n            return BitConverter.ToSingle(temp, 0);  \n        }  \n  \n        public double ReadDouble() {  \n            byte[] temp = BitConverter.GetBytes(reader.ReadDouble());  \n            Array.Reverse(temp);  \n            return BitConverter.ToDouble(temp, 0);  \n        }  \n  \n        public string ReadString() {  \n            ushort len = ReadShort();  \n            byte[] buffer = new byte[len];  \n            buffer = reader.ReadBytes(len);  \n            return Encoding.UTF8.GetString(buffer);  \n        }  \n  \n        public byte[] ReadBytes() {  \n            int len = ReadInt();  \n            return reader.ReadBytes(len);  \n        }  \n  \n        public byte[] ToBytes() {  \n            writer.Flush();  \n            return stream.ToArray();  \n        }  \n  \n        public void Flush() {  \n            writer.Flush();  \n        }  \n    }  \n}  \n```\n使用此操作类进行读写数据的操作范例如下：\n\n- 读取数据：\n```C#\n//result是字节数组byte[],从中读取两个int类型的数据  \n ByteBuffer buff = new ByteBuffer(result);  \n int len = buff.ReadShort();  \n int protoId = buff.ReadShort();  \n```\n- 写入数据：\n```C#\n//result是字节数组byte[],从写入两个不同类型的数据  \nByteBuffer buff = new ByteBuffer();  \nint protoId = ProtoDic.GetProtoIdByProtoType(0);  \nbuff.WriteShort((ushort)protoId);  \nbuff.WriteBytes(ms.ToArray());  \nbyte[] result = buff.ToBytes();  \n```\n\n#### 1.服务器创建：\n在VS中新建一个C#控制台应用，新建项目完成后将上面定义的ByteBuffer.cs类导入工程中，然后开始在入口类Program中开始创建Socket服务器的逻辑。\n\n- 先引入必要的命名空间：\n```C#\nusing System.Net;  \nusing System.Net.Sockets;  \nusing System.Threading;  \n```\n基本的步骤如下：\n\n- 创建一个服务器Socket对象，并绑定服务器IP地址和端口号；\n```C#\nprivate const int port = 8088;  \nprivate static string IpStr = \"127.0.0.1\";  \nprivate static Socket serverSocket;  \n  \nstatic void Main(string[] args)  \n{  \n    IPAddress ip = IPAddress.Parse(IpStr);  \n    IPEndPoint ip_end_point = new IPEndPoint(ip, port);  \n    //创建服务器Socket对象，并设置相关属性  \n    serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  \n    //绑定ip和端口  \n    serverSocket.Bind(ip_end_point);  \n    //设置最长的连接请求队列长度  \n    serverSocket.Listen(10);  \n    Console.WriteLine(\"启动监听{0}成功\", serverSocket.LocalEndPoint.ToString());  \n}  \n```\n完成上述代码之后，已经能正常启动一个服务器Socket，但是还没有处理连接监听逻辑和数据接收，所以运行应用会出现一闪就关掉的情况。\n\n- 启动一个线程，并在线程中监听客户端的连接，为每个连接创建一个Socket对象；\n\n- 创建接受数据和发送数据的方法，完整的代码如下：\n```C#\nusing System;  \nusing System.Collections.Generic;  \nusing System.Linq;  \nusing System.Net.Sockets;  \nusing System.Text;  \nusing System.Threading.Tasks;  \nusing System.Net;  \nusing System.Threading;  \nusing Net;  \nusing System.IO;  \n  \nnamespace ConsoleApplication1  \n{  \n    class Program  \n    {  \n        private static byte[] result = new byte[1024];  \n        private const int port = 8088;  \n        private static string IpStr = \"127.0.0.1\";  \n        private static Socket serverSocket;  \n  \n        static void Main(string[] args)  \n        {  \n            IPAddress ip = IPAddress.Parse(IpStr);  \n            IPEndPoint ip_end_point = new IPEndPoint(ip, port);  \n            //创建服务器Socket对象，并设置相关属性  \n            serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  \n            //绑定ip和端口  \n            serverSocket.Bind(ip_end_point);  \n            //设置最长的连接请求队列长度  \n            serverSocket.Listen(10);  \n            Console.WriteLine(\"启动监听{0}成功\", serverSocket.LocalEndPoint.ToString());  \n            //在新线程中监听客户端的连接  \n            Thread thread = new Thread(ClientConnectListen);  \n            thread.Start();  \n            Console.ReadLine();  \n        }  \n  \n        /// <summary>  \n        /// 客户端连接请求监听  \n        /// </summary>  \n        private static void ClientConnectListen()  \n        {  \n            while (true)  \n            {  \n                //为新的客户端连接创建一个Socket对象  \n                Socket clientSocket = serverSocket.Accept();  \n                Console.WriteLine(\"客户端{0}成功连接\", clientSocket.RemoteEndPoint.ToString());  \n                //向连接的客户端发送连接成功的数据  \n                ByteBuffer buffer = new ByteBuffer();  \n                buffer.WriteString(\"Connected Server\");  \n                clientSocket.Send(WriteMessage(buffer.ToBytes()));  \n                //每个客户端连接创建一个线程来接受该客户端发送的消息  \n                Thread thread = new Thread(RecieveMessage);  \n                thread.Start(clientSocket);  \n            }  \n        }  \n  \n        /// <summary>  \n        /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  \n        /// </summary>  \n        /// <param name=\"message\"></param>  \n        /// <returns></returns>  \n        private static byte[] WriteMessage(byte[] message)  \n        {  \n            MemoryStream ms = null;  \n            using (ms = new MemoryStream())  \n            {  \n                ms.Position = 0;  \n                BinaryWriter writer = new BinaryWriter(ms);  \n                ushort msglen = (ushort)message.Length;  \n                writer.Write(msglen);  \n                writer.Write(message);  \n                writer.Flush();  \n                return ms.ToArray();  \n            }  \n        }  \n  \n        /// <summary>  \n        /// 接收指定客户端Socket的消息  \n        /// </summary>  \n        /// <param name=\"clientSocket\"></param>  \n        private static void RecieveMessage(object clientSocket)  \n        {  \n            Socket mClientSocket = (Socket)clientSocket;  \n            while (true)  \n            {  \n                try  \n                {  \n                    int receiveNumber = mClientSocket.Receive(result);  \n                    Console.WriteLine(\"接收客户端{0}消息， 长度为{1}\", mClientSocket.RemoteEndPoint.ToString(), receiveNumber);  \n                    ByteBuffer buff = new ByteBuffer(result);  \n                    //数据长度  \n                    int len = buff.ReadShort();  \n                    //数据内容  \n                    string data = buff.ReadString();  \n                    Console.WriteLine(\"数据内容：{0}\", data);  \n                }  \n                catch (Exception ex)  \n                {  \n                    Console.WriteLine(ex.Message);  \n                    mClientSocket.Shutdown(SocketShutdown.Both);  \n                    mClientSocket.Close();  \n                    break;  \n                }  \n            }  \n        }  \n    }  \n}  \n```\n#### 2.客户端创建：\n客户端连接服务器的逻辑相对简单一些，跟服务器一样，先把ByteBuffer类导入到工程中，基本步骤如下：\n\n- 创建一个Socket对象，这个对象在客户端是唯一的，可以理解为单例模式；\n- 使用上面创建Socket连接指定服务器IP和端口号；\n- 接收服务器数据和发送数据给服务器。\n\n先创建一个ClientSocket类用于管理Socket的一些方法：连接服务器、接受数据和发送数据等：\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing System.Net;  \nusing System.Net.Sockets;  \nusing System.IO;  \n  \nnamespace Net  \n{  \n    public class ClientSocket  \n    {  \n        private static byte[] result = new byte[1024];  \n        private static Socket clientSocket;  \n        //是否已连接的标识  \n        public bool IsConnected = false;  \n  \n        public ClientSocket(){  \n            clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  \n        }  \n  \n        /// <summary>  \n        /// 连接指定IP和端口的服务器  \n        /// </summary>  \n        /// <param name=\"ip\"></param>  \n        /// <param name=\"port\"></param>  \n        public void ConnectServer(string ip,int port)  \n        {  \n            IPAddress mIp = IPAddress.Parse(ip);  \n            IPEndPoint ip_end_point = new IPEndPoint(mIp, port);  \n  \n            try {  \n                clientSocket.Connect(ip_end_point);  \n                IsConnected = true;  \n                Debug.Log(\"连接服务器成功\");  \n            }  \n            catch  \n            {  \n                IsConnected = false;  \n                Debug.Log(\"连接服务器失败\");  \n                return;  \n            }  \n            //服务器下发数据长度  \n            int receiveLength = clientSocket.Receive(result);  \n            ByteBuffer buffer = new ByteBuffer(result);  \n            int len = buffer.ReadShort();  \n            string data = buffer.ReadString();  \n            Debug.Log(\"服务器返回数据：\" + data);  \n        }  \n  \n        /// <summary>  \n        /// 发送数据给服务器  \n        /// </summary>  \n        public void SendMessage(string data)  \n        {  \n            if (IsConnected == false)  \n                return;  \n            try  \n            {  \n                ByteBuffer buffer = new ByteBuffer();  \n                buffer.WriteString(data);  \n                clientSocket.Send(WriteMessage(buffer.ToBytes()));  \n            }  \n            catch  \n            {  \n                IsConnected = false;  \n                clientSocket.Shutdown(SocketShutdown.Both);  \n                clientSocket.Close();  \n            }  \n        }  \n  \n        /// <summary>  \n        /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  \n        /// </summary>  \n        /// <param name=\"message\"></param>  \n        /// <returns></returns>  \n        private static byte[] WriteMessage(byte[] message)  \n        {  \n            MemoryStream ms = null;  \n            using (ms = new MemoryStream())  \n            {  \n                ms.Position = 0;  \n                BinaryWriter writer = new BinaryWriter(ms);  \n                ushort msglen = (ushort)message.Length;  \n                writer.Write(msglen);  \n                writer.Write(message);  \n                writer.Flush();  \n                return ms.ToArray();  \n            }  \n        }  \n    }  \n}  \n```\n\n### 三、样例测试：\n#### 1.客户端测试：\n在Unity中写一个测试脚本TestSocket.cs，并将此脚本绑到当前场景的相机上：\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing Net;  \n  \npublic class TestSocket : MonoBehaviour {  \n  \n    // Use this for initialization  \n    void Start () {  \n        ClientSocket mSocket = new ClientSocket();  \n        mSocket.ConnectServer(\"127.0.0.1\", 8088);  \n        mSocket.SendMessage(\"服务器傻逼！\");  \n    }  \n      \n    // Update is called once per frame  \n    void Update () {  \n      \n    }  \n}  \n```\n#### 2.启动服务器：\n在Visual Studio中点击运行按钮，启动服务器：\n![](http://img.blog.csdn.net/20160825164018638)\n启动正常的话，会弹出一个窗口如下图所示：\n![](http://img.blog.csdn.net/20160825164121342)\n\n#### 3.开始连接：\n在Unity中运行当前场景，查看输出日志，假如连接成功，输出如下：\n![](http://img.blog.csdn.net/20160825164333224)\n查看服务器窗口，发现双向通信都正常：\n![](http://img.blog.csdn.net/20160825164551251)\n\n### 四、总结：\n这里测试案例其实很简单，协议没有进行如何优化，单纯地发送字符串数据而已，假如针对复杂的数据的话，需要创建完整打包和解包协议数据的机制，而且必要时还需要对数据进行加密操作。","source":"_posts/Unity3D-Socket通信.md","raw":"---\ntitle: Unity3D —— Socket通信\ndate: 2016-09-19 09:41:16\ntags: Socket,C#\ncategories: Unity\n---\n### 前言：\n在开始编写代码之前，我们首先需要明确：联网方式、联网步骤、数据收发以及协议数据格式\n\n当然在设计时也应该减低代码的耦合性，尽量使得网络层可以在其他地方进行复用，这就需要我们进行接口式的开发。我们这里使用的通信模式是Socket强连接的通信方式，并且使用C#作为编程语言，其实与.NET的Socket通信是一致的。\n\n### 一、设计思想：\n为了方便测试，我直接使用C#写的一个控制台应用，作为服务器，等待客户端的连接，然后使用Unity建立Socket客户端去连接服务器，进行简单的数据通信。这么设计的原因是都基于.net进行开发，也方便理解。\n\n<!--more-->\n\n### 二、实现步骤：\n对于网络通信有所了解的都应该知道，数据在网络传输的格式必须以字节流的形式进行，那么免不了要对字节流进行写入和读出操作，为了方便后面的操作，我们有必要封装一个读写字节流的操作类，在这里我定义了一个字节流的操作类ByteBuffer类，用于将各个类型数据写入流中，也可从字节流中读取各种类型的数据：\n```C#\nusing System.IO;  \nusing System.Text;  \nusing System;  \n  \nnamespace Net {  \n    public class ByteBuffer {  \n        MemoryStream stream = null;  \n        BinaryWriter writer = null;  \n        BinaryReader reader = null;  \n  \n        public ByteBuffer() {  \n            stream = new MemoryStream();  \n            writer = new BinaryWriter(stream);  \n        }  \n  \n        public ByteBuffer(byte[] data) {  \n            if (data != null) {  \n                stream = new MemoryStream(data);  \n                reader = new BinaryReader(stream);  \n            } else {  \n                stream = new MemoryStream();  \n                writer = new BinaryWriter(stream);  \n            }  \n        }  \n  \n        public void Close() {  \n            if (writer != null) writer.Close();  \n            if (reader != null) reader.Close();  \n  \n            stream.Close();  \n            writer = null;  \n            reader = null;  \n            stream = null;  \n        }  \n  \n        public void WriteByte(byte v) {  \n            writer.Write(v);  \n        }  \n  \n        public void WriteInt(int v) {  \n            writer.Write((int)v);  \n        }  \n  \n        public void WriteShort(ushort v) {  \n            writer.Write((ushort)v);  \n        }  \n  \n        public void WriteLong(long v) {  \n            writer.Write((long)v);  \n        }  \n  \n        public void WriteFloat(float v) {  \n            byte[] temp = BitConverter.GetBytes(v);  \n            Array.Reverse(temp);  \n            writer.Write(BitConverter.ToSingle(temp, 0));  \n        }  \n  \n        public void WriteDouble(double v) {  \n            byte[] temp = BitConverter.GetBytes(v);  \n            Array.Reverse(temp);  \n            writer.Write(BitConverter.ToDouble(temp, 0));  \n        }  \n  \n        public void WriteString(string v) {  \n            byte[] bytes = Encoding.UTF8.GetBytes(v);  \n            writer.Write((ushort)bytes.Length);  \n            writer.Write(bytes);  \n        }  \n  \n        public void WriteBytes(byte[] v) {  \n            writer.Write((int)v.Length);  \n            writer.Write(v);  \n        }  \n  \n        public byte ReadByte() {  \n            return reader.ReadByte();  \n        }  \n  \n        public int ReadInt() {  \n            return (int)reader.ReadInt32();  \n        }  \n  \n        public ushort ReadShort() {  \n            return (ushort)reader.ReadInt16();  \n        }  \n  \n        public long ReadLong() {  \n            return (long)reader.ReadInt64();  \n        }  \n  \n        public float ReadFloat() {  \n            byte[] temp = BitConverter.GetBytes(reader.ReadSingle());  \n            Array.Reverse(temp);  \n            return BitConverter.ToSingle(temp, 0);  \n        }  \n  \n        public double ReadDouble() {  \n            byte[] temp = BitConverter.GetBytes(reader.ReadDouble());  \n            Array.Reverse(temp);  \n            return BitConverter.ToDouble(temp, 0);  \n        }  \n  \n        public string ReadString() {  \n            ushort len = ReadShort();  \n            byte[] buffer = new byte[len];  \n            buffer = reader.ReadBytes(len);  \n            return Encoding.UTF8.GetString(buffer);  \n        }  \n  \n        public byte[] ReadBytes() {  \n            int len = ReadInt();  \n            return reader.ReadBytes(len);  \n        }  \n  \n        public byte[] ToBytes() {  \n            writer.Flush();  \n            return stream.ToArray();  \n        }  \n  \n        public void Flush() {  \n            writer.Flush();  \n        }  \n    }  \n}  \n```\n使用此操作类进行读写数据的操作范例如下：\n\n- 读取数据：\n```C#\n//result是字节数组byte[],从中读取两个int类型的数据  \n ByteBuffer buff = new ByteBuffer(result);  \n int len = buff.ReadShort();  \n int protoId = buff.ReadShort();  \n```\n- 写入数据：\n```C#\n//result是字节数组byte[],从写入两个不同类型的数据  \nByteBuffer buff = new ByteBuffer();  \nint protoId = ProtoDic.GetProtoIdByProtoType(0);  \nbuff.WriteShort((ushort)protoId);  \nbuff.WriteBytes(ms.ToArray());  \nbyte[] result = buff.ToBytes();  \n```\n\n#### 1.服务器创建：\n在VS中新建一个C#控制台应用，新建项目完成后将上面定义的ByteBuffer.cs类导入工程中，然后开始在入口类Program中开始创建Socket服务器的逻辑。\n\n- 先引入必要的命名空间：\n```C#\nusing System.Net;  \nusing System.Net.Sockets;  \nusing System.Threading;  \n```\n基本的步骤如下：\n\n- 创建一个服务器Socket对象，并绑定服务器IP地址和端口号；\n```C#\nprivate const int port = 8088;  \nprivate static string IpStr = \"127.0.0.1\";  \nprivate static Socket serverSocket;  \n  \nstatic void Main(string[] args)  \n{  \n    IPAddress ip = IPAddress.Parse(IpStr);  \n    IPEndPoint ip_end_point = new IPEndPoint(ip, port);  \n    //创建服务器Socket对象，并设置相关属性  \n    serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  \n    //绑定ip和端口  \n    serverSocket.Bind(ip_end_point);  \n    //设置最长的连接请求队列长度  \n    serverSocket.Listen(10);  \n    Console.WriteLine(\"启动监听{0}成功\", serverSocket.LocalEndPoint.ToString());  \n}  \n```\n完成上述代码之后，已经能正常启动一个服务器Socket，但是还没有处理连接监听逻辑和数据接收，所以运行应用会出现一闪就关掉的情况。\n\n- 启动一个线程，并在线程中监听客户端的连接，为每个连接创建一个Socket对象；\n\n- 创建接受数据和发送数据的方法，完整的代码如下：\n```C#\nusing System;  \nusing System.Collections.Generic;  \nusing System.Linq;  \nusing System.Net.Sockets;  \nusing System.Text;  \nusing System.Threading.Tasks;  \nusing System.Net;  \nusing System.Threading;  \nusing Net;  \nusing System.IO;  \n  \nnamespace ConsoleApplication1  \n{  \n    class Program  \n    {  \n        private static byte[] result = new byte[1024];  \n        private const int port = 8088;  \n        private static string IpStr = \"127.0.0.1\";  \n        private static Socket serverSocket;  \n  \n        static void Main(string[] args)  \n        {  \n            IPAddress ip = IPAddress.Parse(IpStr);  \n            IPEndPoint ip_end_point = new IPEndPoint(ip, port);  \n            //创建服务器Socket对象，并设置相关属性  \n            serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  \n            //绑定ip和端口  \n            serverSocket.Bind(ip_end_point);  \n            //设置最长的连接请求队列长度  \n            serverSocket.Listen(10);  \n            Console.WriteLine(\"启动监听{0}成功\", serverSocket.LocalEndPoint.ToString());  \n            //在新线程中监听客户端的连接  \n            Thread thread = new Thread(ClientConnectListen);  \n            thread.Start();  \n            Console.ReadLine();  \n        }  \n  \n        /// <summary>  \n        /// 客户端连接请求监听  \n        /// </summary>  \n        private static void ClientConnectListen()  \n        {  \n            while (true)  \n            {  \n                //为新的客户端连接创建一个Socket对象  \n                Socket clientSocket = serverSocket.Accept();  \n                Console.WriteLine(\"客户端{0}成功连接\", clientSocket.RemoteEndPoint.ToString());  \n                //向连接的客户端发送连接成功的数据  \n                ByteBuffer buffer = new ByteBuffer();  \n                buffer.WriteString(\"Connected Server\");  \n                clientSocket.Send(WriteMessage(buffer.ToBytes()));  \n                //每个客户端连接创建一个线程来接受该客户端发送的消息  \n                Thread thread = new Thread(RecieveMessage);  \n                thread.Start(clientSocket);  \n            }  \n        }  \n  \n        /// <summary>  \n        /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  \n        /// </summary>  \n        /// <param name=\"message\"></param>  \n        /// <returns></returns>  \n        private static byte[] WriteMessage(byte[] message)  \n        {  \n            MemoryStream ms = null;  \n            using (ms = new MemoryStream())  \n            {  \n                ms.Position = 0;  \n                BinaryWriter writer = new BinaryWriter(ms);  \n                ushort msglen = (ushort)message.Length;  \n                writer.Write(msglen);  \n                writer.Write(message);  \n                writer.Flush();  \n                return ms.ToArray();  \n            }  \n        }  \n  \n        /// <summary>  \n        /// 接收指定客户端Socket的消息  \n        /// </summary>  \n        /// <param name=\"clientSocket\"></param>  \n        private static void RecieveMessage(object clientSocket)  \n        {  \n            Socket mClientSocket = (Socket)clientSocket;  \n            while (true)  \n            {  \n                try  \n                {  \n                    int receiveNumber = mClientSocket.Receive(result);  \n                    Console.WriteLine(\"接收客户端{0}消息， 长度为{1}\", mClientSocket.RemoteEndPoint.ToString(), receiveNumber);  \n                    ByteBuffer buff = new ByteBuffer(result);  \n                    //数据长度  \n                    int len = buff.ReadShort();  \n                    //数据内容  \n                    string data = buff.ReadString();  \n                    Console.WriteLine(\"数据内容：{0}\", data);  \n                }  \n                catch (Exception ex)  \n                {  \n                    Console.WriteLine(ex.Message);  \n                    mClientSocket.Shutdown(SocketShutdown.Both);  \n                    mClientSocket.Close();  \n                    break;  \n                }  \n            }  \n        }  \n    }  \n}  \n```\n#### 2.客户端创建：\n客户端连接服务器的逻辑相对简单一些，跟服务器一样，先把ByteBuffer类导入到工程中，基本步骤如下：\n\n- 创建一个Socket对象，这个对象在客户端是唯一的，可以理解为单例模式；\n- 使用上面创建Socket连接指定服务器IP和端口号；\n- 接收服务器数据和发送数据给服务器。\n\n先创建一个ClientSocket类用于管理Socket的一些方法：连接服务器、接受数据和发送数据等：\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing System.Net;  \nusing System.Net.Sockets;  \nusing System.IO;  \n  \nnamespace Net  \n{  \n    public class ClientSocket  \n    {  \n        private static byte[] result = new byte[1024];  \n        private static Socket clientSocket;  \n        //是否已连接的标识  \n        public bool IsConnected = false;  \n  \n        public ClientSocket(){  \n            clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  \n        }  \n  \n        /// <summary>  \n        /// 连接指定IP和端口的服务器  \n        /// </summary>  \n        /// <param name=\"ip\"></param>  \n        /// <param name=\"port\"></param>  \n        public void ConnectServer(string ip,int port)  \n        {  \n            IPAddress mIp = IPAddress.Parse(ip);  \n            IPEndPoint ip_end_point = new IPEndPoint(mIp, port);  \n  \n            try {  \n                clientSocket.Connect(ip_end_point);  \n                IsConnected = true;  \n                Debug.Log(\"连接服务器成功\");  \n            }  \n            catch  \n            {  \n                IsConnected = false;  \n                Debug.Log(\"连接服务器失败\");  \n                return;  \n            }  \n            //服务器下发数据长度  \n            int receiveLength = clientSocket.Receive(result);  \n            ByteBuffer buffer = new ByteBuffer(result);  \n            int len = buffer.ReadShort();  \n            string data = buffer.ReadString();  \n            Debug.Log(\"服务器返回数据：\" + data);  \n        }  \n  \n        /// <summary>  \n        /// 发送数据给服务器  \n        /// </summary>  \n        public void SendMessage(string data)  \n        {  \n            if (IsConnected == false)  \n                return;  \n            try  \n            {  \n                ByteBuffer buffer = new ByteBuffer();  \n                buffer.WriteString(data);  \n                clientSocket.Send(WriteMessage(buffer.ToBytes()));  \n            }  \n            catch  \n            {  \n                IsConnected = false;  \n                clientSocket.Shutdown(SocketShutdown.Both);  \n                clientSocket.Close();  \n            }  \n        }  \n  \n        /// <summary>  \n        /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  \n        /// </summary>  \n        /// <param name=\"message\"></param>  \n        /// <returns></returns>  \n        private static byte[] WriteMessage(byte[] message)  \n        {  \n            MemoryStream ms = null;  \n            using (ms = new MemoryStream())  \n            {  \n                ms.Position = 0;  \n                BinaryWriter writer = new BinaryWriter(ms);  \n                ushort msglen = (ushort)message.Length;  \n                writer.Write(msglen);  \n                writer.Write(message);  \n                writer.Flush();  \n                return ms.ToArray();  \n            }  \n        }  \n    }  \n}  \n```\n\n### 三、样例测试：\n#### 1.客户端测试：\n在Unity中写一个测试脚本TestSocket.cs，并将此脚本绑到当前场景的相机上：\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing Net;  \n  \npublic class TestSocket : MonoBehaviour {  \n  \n    // Use this for initialization  \n    void Start () {  \n        ClientSocket mSocket = new ClientSocket();  \n        mSocket.ConnectServer(\"127.0.0.1\", 8088);  \n        mSocket.SendMessage(\"服务器傻逼！\");  \n    }  \n      \n    // Update is called once per frame  \n    void Update () {  \n      \n    }  \n}  \n```\n#### 2.启动服务器：\n在Visual Studio中点击运行按钮，启动服务器：\n![](http://img.blog.csdn.net/20160825164018638)\n启动正常的话，会弹出一个窗口如下图所示：\n![](http://img.blog.csdn.net/20160825164121342)\n\n#### 3.开始连接：\n在Unity中运行当前场景，查看输出日志，假如连接成功，输出如下：\n![](http://img.blog.csdn.net/20160825164333224)\n查看服务器窗口，发现双向通信都正常：\n![](http://img.blog.csdn.net/20160825164551251)\n\n### 四、总结：\n这里测试案例其实很简单，协议没有进行如何优化，单纯地发送字符串数据而已，假如针对复杂的数据的话，需要创建完整打包和解包协议数据的机制，而且必要时还需要对数据进行加密操作。","slug":"Unity3D-Socket通信","published":1,"updated":"2017-06-24T02:13:49.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfkt00139gfj1x5a4vgw","content":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>在开始编写代码之前，我们首先需要明确：联网方式、联网步骤、数据收发以及协议数据格式</p>\n<p>当然在设计时也应该减低代码的耦合性，尽量使得网络层可以在其他地方进行复用，这就需要我们进行接口式的开发。我们这里使用的通信模式是Socket强连接的通信方式，并且使用C#作为编程语言，其实与.NET的Socket通信是一致的。</p>\n<h3 id=\"一、设计思想：\"><a href=\"#一、设计思想：\" class=\"headerlink\" title=\"一、设计思想：\"></a>一、设计思想：</h3><p>为了方便测试，我直接使用C#写的一个控制台应用，作为服务器，等待客户端的连接，然后使用Unity建立Socket客户端去连接服务器，进行简单的数据通信。这么设计的原因是都基于.net进行开发，也方便理解。</p>\n<a id=\"more\"></a>\n<h3 id=\"二、实现步骤：\"><a href=\"#二、实现步骤：\" class=\"headerlink\" title=\"二、实现步骤：\"></a>二、实现步骤：</h3><p>对于网络通信有所了解的都应该知道，数据在网络传输的格式必须以字节流的形式进行，那么免不了要对字节流进行写入和读出操作，为了方便后面的操作，我们有必要封装一个读写字节流的操作类，在这里我定义了一个字节流的操作类ByteBuffer类，用于将各个类型数据写入流中，也可从字节流中读取各种类型的数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div></pre></td><td class=\"code\"><pre><div class=\"line\">using System.IO;  </div><div class=\"line\">using System.Text;  </div><div class=\"line\">using System;  </div><div class=\"line\">  </div><div class=\"line\">namespace Net &#123;  </div><div class=\"line\">    public class ByteBuffer &#123;  </div><div class=\"line\">        MemoryStream stream = null;  </div><div class=\"line\">        BinaryWriter writer = null;  </div><div class=\"line\">        BinaryReader reader = null;  </div><div class=\"line\">  </div><div class=\"line\">        public ByteBuffer() &#123;  </div><div class=\"line\">            stream = new MemoryStream();  </div><div class=\"line\">            writer = new BinaryWriter(stream);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public ByteBuffer(byte[] data) &#123;  </div><div class=\"line\">            if (data != null) &#123;  </div><div class=\"line\">                stream = new MemoryStream(data);  </div><div class=\"line\">                reader = new BinaryReader(stream);  </div><div class=\"line\">            &#125; else &#123;  </div><div class=\"line\">                stream = new MemoryStream();  </div><div class=\"line\">                writer = new BinaryWriter(stream);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void Close() &#123;  </div><div class=\"line\">            if (writer != null) writer.Close();  </div><div class=\"line\">            if (reader != null) reader.Close();  </div><div class=\"line\">  </div><div class=\"line\">            stream.Close();  </div><div class=\"line\">            writer = null;  </div><div class=\"line\">            reader = null;  </div><div class=\"line\">            stream = null;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteByte(byte v) &#123;  </div><div class=\"line\">            writer.Write(v);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteInt(int v) &#123;  </div><div class=\"line\">            writer.Write((int)v);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteShort(ushort v) &#123;  </div><div class=\"line\">            writer.Write((ushort)v);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteLong(long v) &#123;  </div><div class=\"line\">            writer.Write((long)v);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteFloat(float v) &#123;  </div><div class=\"line\">            byte[] temp = BitConverter.GetBytes(v);  </div><div class=\"line\">            Array.Reverse(temp);  </div><div class=\"line\">            writer.Write(BitConverter.ToSingle(temp, 0));  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteDouble(double v) &#123;  </div><div class=\"line\">            byte[] temp = BitConverter.GetBytes(v);  </div><div class=\"line\">            Array.Reverse(temp);  </div><div class=\"line\">            writer.Write(BitConverter.ToDouble(temp, 0));  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteString(string v) &#123;  </div><div class=\"line\">            byte[] bytes = Encoding.UTF8.GetBytes(v);  </div><div class=\"line\">            writer.Write((ushort)bytes.Length);  </div><div class=\"line\">            writer.Write(bytes);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteBytes(byte[] v) &#123;  </div><div class=\"line\">            writer.Write((int)v.Length);  </div><div class=\"line\">            writer.Write(v);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public byte ReadByte() &#123;  </div><div class=\"line\">            return reader.ReadByte();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public int ReadInt() &#123;  </div><div class=\"line\">            return (int)reader.ReadInt32();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public ushort ReadShort() &#123;  </div><div class=\"line\">            return (ushort)reader.ReadInt16();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public long ReadLong() &#123;  </div><div class=\"line\">            return (long)reader.ReadInt64();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public float ReadFloat() &#123;  </div><div class=\"line\">            byte[] temp = BitConverter.GetBytes(reader.ReadSingle());  </div><div class=\"line\">            Array.Reverse(temp);  </div><div class=\"line\">            return BitConverter.ToSingle(temp, 0);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public double ReadDouble() &#123;  </div><div class=\"line\">            byte[] temp = BitConverter.GetBytes(reader.ReadDouble());  </div><div class=\"line\">            Array.Reverse(temp);  </div><div class=\"line\">            return BitConverter.ToDouble(temp, 0);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public string ReadString() &#123;  </div><div class=\"line\">            ushort len = ReadShort();  </div><div class=\"line\">            byte[] buffer = new byte[len];  </div><div class=\"line\">            buffer = reader.ReadBytes(len);  </div><div class=\"line\">            return Encoding.UTF8.GetString(buffer);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public byte[] ReadBytes() &#123;  </div><div class=\"line\">            int len = ReadInt();  </div><div class=\"line\">            return reader.ReadBytes(len);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public byte[] ToBytes() &#123;  </div><div class=\"line\">            writer.Flush();  </div><div class=\"line\">            return stream.ToArray();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void Flush() &#123;  </div><div class=\"line\">            writer.Flush();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用此操作类进行读写数据的操作范例如下：</p>\n<ul>\n<li><p>读取数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//result是字节数组byte[],从中读取两个int类型的数据  </div><div class=\"line\"> ByteBuffer buff = new ByteBuffer(result);  </div><div class=\"line\"> int len = buff.ReadShort();  </div><div class=\"line\"> int protoId = buff.ReadShort();</div></pre></td></tr></table></figure>\n</li>\n<li><p>写入数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//result是字节数组byte[],从写入两个不同类型的数据  </div><div class=\"line\">ByteBuffer buff = new ByteBuffer();  </div><div class=\"line\">int protoId = ProtoDic.GetProtoIdByProtoType(0);  </div><div class=\"line\">buff.WriteShort((ushort)protoId);  </div><div class=\"line\">buff.WriteBytes(ms.ToArray());  </div><div class=\"line\">byte[] result = buff.ToBytes();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"1-服务器创建：\"><a href=\"#1-服务器创建：\" class=\"headerlink\" title=\"1.服务器创建：\"></a>1.服务器创建：</h4><p>在VS中新建一个C#控制台应用，新建项目完成后将上面定义的ByteBuffer.cs类导入工程中，然后开始在入口类Program中开始创建Socket服务器的逻辑。</p>\n<ul>\n<li>先引入必要的命名空间：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">using System.Net;  </div><div class=\"line\">using System.Net.Sockets;  </div><div class=\"line\">using System.Threading;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>基本的步骤如下：</p>\n<ul>\n<li>创建一个服务器Socket对象，并绑定服务器IP地址和端口号；<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">private const int port = 8088;  </div><div class=\"line\">private static string IpStr = &quot;127.0.0.1&quot;;  </div><div class=\"line\">private static Socket serverSocket;  </div><div class=\"line\">  </div><div class=\"line\">static void Main(string[] args)  </div><div class=\"line\">&#123;  </div><div class=\"line\">    IPAddress ip = IPAddress.Parse(IpStr);  </div><div class=\"line\">    IPEndPoint ip_end_point = new IPEndPoint(ip, port);  </div><div class=\"line\">    //创建服务器Socket对象，并设置相关属性  </div><div class=\"line\">    serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  </div><div class=\"line\">    //绑定ip和端口  </div><div class=\"line\">    serverSocket.Bind(ip_end_point);  </div><div class=\"line\">    //设置最长的连接请求队列长度  </div><div class=\"line\">    serverSocket.Listen(10);  </div><div class=\"line\">    Console.WriteLine(&quot;启动监听&#123;0&#125;成功&quot;, serverSocket.LocalEndPoint.ToString());  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>完成上述代码之后，已经能正常启动一个服务器Socket，但是还没有处理连接监听逻辑和数据接收，所以运行应用会出现一闪就关掉的情况。</p>\n<ul>\n<li><p>启动一个线程，并在线程中监听客户端的连接，为每个连接创建一个Socket对象；</p>\n</li>\n<li><p>创建接受数据和发送数据的方法，完整的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div></pre></td><td class=\"code\"><pre><div class=\"line\">using System;  </div><div class=\"line\">using System.Collections.Generic;  </div><div class=\"line\">using System.Linq;  </div><div class=\"line\">using System.Net.Sockets;  </div><div class=\"line\">using System.Text;  </div><div class=\"line\">using System.Threading.Tasks;  </div><div class=\"line\">using System.Net;  </div><div class=\"line\">using System.Threading;  </div><div class=\"line\">using Net;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">  </div><div class=\"line\">namespace ConsoleApplication1  </div><div class=\"line\">&#123;  </div><div class=\"line\">    class Program  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        private static byte[] result = new byte[1024];  </div><div class=\"line\">        private const int port = 8088;  </div><div class=\"line\">        private static string IpStr = &quot;127.0.0.1&quot;;  </div><div class=\"line\">        private static Socket serverSocket;  </div><div class=\"line\">  </div><div class=\"line\">        static void Main(string[] args)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            IPAddress ip = IPAddress.Parse(IpStr);  </div><div class=\"line\">            IPEndPoint ip_end_point = new IPEndPoint(ip, port);  </div><div class=\"line\">            //创建服务器Socket对象，并设置相关属性  </div><div class=\"line\">            serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  </div><div class=\"line\">            //绑定ip和端口  </div><div class=\"line\">            serverSocket.Bind(ip_end_point);  </div><div class=\"line\">            //设置最长的连接请求队列长度  </div><div class=\"line\">            serverSocket.Listen(10);  </div><div class=\"line\">            Console.WriteLine(&quot;启动监听&#123;0&#125;成功&quot;, serverSocket.LocalEndPoint.ToString());  </div><div class=\"line\">            //在新线程中监听客户端的连接  </div><div class=\"line\">            Thread thread = new Thread(ClientConnectListen);  </div><div class=\"line\">            thread.Start();  </div><div class=\"line\">            Console.ReadLine();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 客户端连接请求监听  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        private static void ClientConnectListen()  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            while (true)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                //为新的客户端连接创建一个Socket对象  </div><div class=\"line\">                Socket clientSocket = serverSocket.Accept();  </div><div class=\"line\">                Console.WriteLine(&quot;客户端&#123;0&#125;成功连接&quot;, clientSocket.RemoteEndPoint.ToString());  </div><div class=\"line\">                //向连接的客户端发送连接成功的数据  </div><div class=\"line\">                ByteBuffer buffer = new ByteBuffer();  </div><div class=\"line\">                buffer.WriteString(&quot;Connected Server&quot;);  </div><div class=\"line\">                clientSocket.Send(WriteMessage(buffer.ToBytes()));  </div><div class=\"line\">                //每个客户端连接创建一个线程来接受该客户端发送的消息  </div><div class=\"line\">                Thread thread = new Thread(RecieveMessage);  </div><div class=\"line\">                thread.Start(clientSocket);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">        /// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">        private static byte[] WriteMessage(byte[] message)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            MemoryStream ms = null;  </div><div class=\"line\">            using (ms = new MemoryStream())  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                ms.Position = 0;  </div><div class=\"line\">                BinaryWriter writer = new BinaryWriter(ms);  </div><div class=\"line\">                ushort msglen = (ushort)message.Length;  </div><div class=\"line\">                writer.Write(msglen);  </div><div class=\"line\">                writer.Write(message);  </div><div class=\"line\">                writer.Flush();  </div><div class=\"line\">                return ms.ToArray();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 接收指定客户端Socket的消息  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        /// &lt;param name=&quot;clientSocket&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">        private static void RecieveMessage(object clientSocket)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Socket mClientSocket = (Socket)clientSocket;  </div><div class=\"line\">            while (true)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                try  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    int receiveNumber = mClientSocket.Receive(result);  </div><div class=\"line\">                    Console.WriteLine(&quot;接收客户端&#123;0&#125;消息， 长度为&#123;1&#125;&quot;, mClientSocket.RemoteEndPoint.ToString(), receiveNumber);  </div><div class=\"line\">                    ByteBuffer buff = new ByteBuffer(result);  </div><div class=\"line\">                    //数据长度  </div><div class=\"line\">                    int len = buff.ReadShort();  </div><div class=\"line\">                    //数据内容  </div><div class=\"line\">                    string data = buff.ReadString();  </div><div class=\"line\">                    Console.WriteLine(&quot;数据内容：&#123;0&#125;&quot;, data);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                catch (Exception ex)  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    Console.WriteLine(ex.Message);  </div><div class=\"line\">                    mClientSocket.Shutdown(SocketShutdown.Both);  </div><div class=\"line\">                    mClientSocket.Close();  </div><div class=\"line\">                    break;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-客户端创建：\"><a href=\"#2-客户端创建：\" class=\"headerlink\" title=\"2.客户端创建：\"></a>2.客户端创建：</h4><p>客户端连接服务器的逻辑相对简单一些，跟服务器一样，先把ByteBuffer类导入到工程中，基本步骤如下：</p>\n<ul>\n<li>创建一个Socket对象，这个对象在客户端是唯一的，可以理解为单例模式；</li>\n<li>使用上面创建Socket连接指定服务器IP和端口号；</li>\n<li>接收服务器数据和发送数据给服务器。</li>\n</ul>\n<p>先创建一个ClientSocket类用于管理Socket的一些方法：连接服务器、接受数据和发送数据等：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using System.Net;  </div><div class=\"line\">using System.Net.Sockets;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">  </div><div class=\"line\">namespace Net  </div><div class=\"line\">&#123;  </div><div class=\"line\">    public class ClientSocket  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        private static byte[] result = new byte[1024];  </div><div class=\"line\">        private static Socket clientSocket;  </div><div class=\"line\">        //是否已连接的标识  </div><div class=\"line\">        public bool IsConnected = false;  </div><div class=\"line\">  </div><div class=\"line\">        public ClientSocket()&#123;  </div><div class=\"line\">            clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 连接指定IP和端口的服务器  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        /// &lt;param name=&quot;ip&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">        /// &lt;param name=&quot;port&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">        public void ConnectServer(string ip,int port)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            IPAddress mIp = IPAddress.Parse(ip);  </div><div class=\"line\">            IPEndPoint ip_end_point = new IPEndPoint(mIp, port);  </div><div class=\"line\">  </div><div class=\"line\">            try &#123;  </div><div class=\"line\">                clientSocket.Connect(ip_end_point);  </div><div class=\"line\">                IsConnected = true;  </div><div class=\"line\">                Debug.Log(&quot;连接服务器成功&quot;);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                IsConnected = false;  </div><div class=\"line\">                Debug.Log(&quot;连接服务器失败&quot;);  </div><div class=\"line\">                return;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            //服务器下发数据长度  </div><div class=\"line\">            int receiveLength = clientSocket.Receive(result);  </div><div class=\"line\">            ByteBuffer buffer = new ByteBuffer(result);  </div><div class=\"line\">            int len = buffer.ReadShort();  </div><div class=\"line\">            string data = buffer.ReadString();  </div><div class=\"line\">            Debug.Log(&quot;服务器返回数据：&quot; + data);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 发送数据给服务器  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        public void SendMessage(string data)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            if (IsConnected == false)  </div><div class=\"line\">                return;  </div><div class=\"line\">            try  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                ByteBuffer buffer = new ByteBuffer();  </div><div class=\"line\">                buffer.WriteString(data);  </div><div class=\"line\">                clientSocket.Send(WriteMessage(buffer.ToBytes()));  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                IsConnected = false;  </div><div class=\"line\">                clientSocket.Shutdown(SocketShutdown.Both);  </div><div class=\"line\">                clientSocket.Close();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">        /// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">        private static byte[] WriteMessage(byte[] message)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            MemoryStream ms = null;  </div><div class=\"line\">            using (ms = new MemoryStream())  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                ms.Position = 0;  </div><div class=\"line\">                BinaryWriter writer = new BinaryWriter(ms);  </div><div class=\"line\">                ushort msglen = (ushort)message.Length;  </div><div class=\"line\">                writer.Write(msglen);  </div><div class=\"line\">                writer.Write(message);  </div><div class=\"line\">                writer.Flush();  </div><div class=\"line\">                return ms.ToArray();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"三、样例测试：\"><a href=\"#三、样例测试：\" class=\"headerlink\" title=\"三、样例测试：\"></a>三、样例测试：</h3><h4 id=\"1-客户端测试：\"><a href=\"#1-客户端测试：\" class=\"headerlink\" title=\"1.客户端测试：\"></a>1.客户端测试：</h4><p>在Unity中写一个测试脚本TestSocket.cs，并将此脚本绑到当前场景的相机上：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using Net;  </div><div class=\"line\">  </div><div class=\"line\">public class TestSocket : MonoBehaviour &#123;  </div><div class=\"line\">  </div><div class=\"line\">    // Use this for initialization  </div><div class=\"line\">    void Start () &#123;  </div><div class=\"line\">        ClientSocket mSocket = new ClientSocket();  </div><div class=\"line\">        mSocket.ConnectServer(&quot;127.0.0.1&quot;, 8088);  </div><div class=\"line\">        mSocket.SendMessage(&quot;服务器傻逼！&quot;);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    // Update is called once per frame  </div><div class=\"line\">    void Update () &#123;  </div><div class=\"line\">      </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-启动服务器：\"><a href=\"#2-启动服务器：\" class=\"headerlink\" title=\"2.启动服务器：\"></a>2.启动服务器：</h4><p>在Visual Studio中点击运行按钮，启动服务器：<br><img src=\"http://img.blog.csdn.net/20160825164018638\" alt=\"\"><br>启动正常的话，会弹出一个窗口如下图所示：<br><img src=\"http://img.blog.csdn.net/20160825164121342\" alt=\"\"></p>\n<h4 id=\"3-开始连接：\"><a href=\"#3-开始连接：\" class=\"headerlink\" title=\"3.开始连接：\"></a>3.开始连接：</h4><p>在Unity中运行当前场景，查看输出日志，假如连接成功，输出如下：<br><img src=\"http://img.blog.csdn.net/20160825164333224\" alt=\"\"><br>查看服务器窗口，发现双向通信都正常：<br><img src=\"http://img.blog.csdn.net/20160825164551251\" alt=\"\"></p>\n<h3 id=\"四、总结：\"><a href=\"#四、总结：\" class=\"headerlink\" title=\"四、总结：\"></a>四、总结：</h3><p>这里测试案例其实很简单，协议没有进行如何优化，单纯地发送字符串数据而已，假如针对复杂的数据的话，需要创建完整打包和解包协议数据的机制，而且必要时还需要对数据进行加密操作。</p>\n","excerpt":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>在开始编写代码之前，我们首先需要明确：联网方式、联网步骤、数据收发以及协议数据格式</p>\n<p>当然在设计时也应该减低代码的耦合性，尽量使得网络层可以在其他地方进行复用，这就需要我们进行接口式的开发。我们这里使用的通信模式是Socket强连接的通信方式，并且使用C#作为编程语言，其实与.NET的Socket通信是一致的。</p>\n<h3 id=\"一、设计思想：\"><a href=\"#一、设计思想：\" class=\"headerlink\" title=\"一、设计思想：\"></a>一、设计思想：</h3><p>为了方便测试，我直接使用C#写的一个控制台应用，作为服务器，等待客户端的连接，然后使用Unity建立Socket客户端去连接服务器，进行简单的数据通信。这么设计的原因是都基于.net进行开发，也方便理解。</p>","more":"<h3 id=\"二、实现步骤：\"><a href=\"#二、实现步骤：\" class=\"headerlink\" title=\"二、实现步骤：\"></a>二、实现步骤：</h3><p>对于网络通信有所了解的都应该知道，数据在网络传输的格式必须以字节流的形式进行，那么免不了要对字节流进行写入和读出操作，为了方便后面的操作，我们有必要封装一个读写字节流的操作类，在这里我定义了一个字节流的操作类ByteBuffer类，用于将各个类型数据写入流中，也可从字节流中读取各种类型的数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div></pre></td><td class=\"code\"><pre><div class=\"line\">using System.IO;  </div><div class=\"line\">using System.Text;  </div><div class=\"line\">using System;  </div><div class=\"line\">  </div><div class=\"line\">namespace Net &#123;  </div><div class=\"line\">    public class ByteBuffer &#123;  </div><div class=\"line\">        MemoryStream stream = null;  </div><div class=\"line\">        BinaryWriter writer = null;  </div><div class=\"line\">        BinaryReader reader = null;  </div><div class=\"line\">  </div><div class=\"line\">        public ByteBuffer() &#123;  </div><div class=\"line\">            stream = new MemoryStream();  </div><div class=\"line\">            writer = new BinaryWriter(stream);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public ByteBuffer(byte[] data) &#123;  </div><div class=\"line\">            if (data != null) &#123;  </div><div class=\"line\">                stream = new MemoryStream(data);  </div><div class=\"line\">                reader = new BinaryReader(stream);  </div><div class=\"line\">            &#125; else &#123;  </div><div class=\"line\">                stream = new MemoryStream();  </div><div class=\"line\">                writer = new BinaryWriter(stream);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void Close() &#123;  </div><div class=\"line\">            if (writer != null) writer.Close();  </div><div class=\"line\">            if (reader != null) reader.Close();  </div><div class=\"line\">  </div><div class=\"line\">            stream.Close();  </div><div class=\"line\">            writer = null;  </div><div class=\"line\">            reader = null;  </div><div class=\"line\">            stream = null;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteByte(byte v) &#123;  </div><div class=\"line\">            writer.Write(v);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteInt(int v) &#123;  </div><div class=\"line\">            writer.Write((int)v);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteShort(ushort v) &#123;  </div><div class=\"line\">            writer.Write((ushort)v);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteLong(long v) &#123;  </div><div class=\"line\">            writer.Write((long)v);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteFloat(float v) &#123;  </div><div class=\"line\">            byte[] temp = BitConverter.GetBytes(v);  </div><div class=\"line\">            Array.Reverse(temp);  </div><div class=\"line\">            writer.Write(BitConverter.ToSingle(temp, 0));  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteDouble(double v) &#123;  </div><div class=\"line\">            byte[] temp = BitConverter.GetBytes(v);  </div><div class=\"line\">            Array.Reverse(temp);  </div><div class=\"line\">            writer.Write(BitConverter.ToDouble(temp, 0));  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteString(string v) &#123;  </div><div class=\"line\">            byte[] bytes = Encoding.UTF8.GetBytes(v);  </div><div class=\"line\">            writer.Write((ushort)bytes.Length);  </div><div class=\"line\">            writer.Write(bytes);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void WriteBytes(byte[] v) &#123;  </div><div class=\"line\">            writer.Write((int)v.Length);  </div><div class=\"line\">            writer.Write(v);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public byte ReadByte() &#123;  </div><div class=\"line\">            return reader.ReadByte();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public int ReadInt() &#123;  </div><div class=\"line\">            return (int)reader.ReadInt32();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public ushort ReadShort() &#123;  </div><div class=\"line\">            return (ushort)reader.ReadInt16();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public long ReadLong() &#123;  </div><div class=\"line\">            return (long)reader.ReadInt64();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public float ReadFloat() &#123;  </div><div class=\"line\">            byte[] temp = BitConverter.GetBytes(reader.ReadSingle());  </div><div class=\"line\">            Array.Reverse(temp);  </div><div class=\"line\">            return BitConverter.ToSingle(temp, 0);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public double ReadDouble() &#123;  </div><div class=\"line\">            byte[] temp = BitConverter.GetBytes(reader.ReadDouble());  </div><div class=\"line\">            Array.Reverse(temp);  </div><div class=\"line\">            return BitConverter.ToDouble(temp, 0);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public string ReadString() &#123;  </div><div class=\"line\">            ushort len = ReadShort();  </div><div class=\"line\">            byte[] buffer = new byte[len];  </div><div class=\"line\">            buffer = reader.ReadBytes(len);  </div><div class=\"line\">            return Encoding.UTF8.GetString(buffer);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public byte[] ReadBytes() &#123;  </div><div class=\"line\">            int len = ReadInt();  </div><div class=\"line\">            return reader.ReadBytes(len);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public byte[] ToBytes() &#123;  </div><div class=\"line\">            writer.Flush();  </div><div class=\"line\">            return stream.ToArray();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        public void Flush() &#123;  </div><div class=\"line\">            writer.Flush();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用此操作类进行读写数据的操作范例如下：</p>\n<ul>\n<li><p>读取数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//result是字节数组byte[],从中读取两个int类型的数据  </div><div class=\"line\"> ByteBuffer buff = new ByteBuffer(result);  </div><div class=\"line\"> int len = buff.ReadShort();  </div><div class=\"line\"> int protoId = buff.ReadShort();</div></pre></td></tr></table></figure>\n</li>\n<li><p>写入数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//result是字节数组byte[],从写入两个不同类型的数据  </div><div class=\"line\">ByteBuffer buff = new ByteBuffer();  </div><div class=\"line\">int protoId = ProtoDic.GetProtoIdByProtoType(0);  </div><div class=\"line\">buff.WriteShort((ushort)protoId);  </div><div class=\"line\">buff.WriteBytes(ms.ToArray());  </div><div class=\"line\">byte[] result = buff.ToBytes();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"1-服务器创建：\"><a href=\"#1-服务器创建：\" class=\"headerlink\" title=\"1.服务器创建：\"></a>1.服务器创建：</h4><p>在VS中新建一个C#控制台应用，新建项目完成后将上面定义的ByteBuffer.cs类导入工程中，然后开始在入口类Program中开始创建Socket服务器的逻辑。</p>\n<ul>\n<li>先引入必要的命名空间：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">using System.Net;  </div><div class=\"line\">using System.Net.Sockets;  </div><div class=\"line\">using System.Threading;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>基本的步骤如下：</p>\n<ul>\n<li>创建一个服务器Socket对象，并绑定服务器IP地址和端口号；<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">private const int port = 8088;  </div><div class=\"line\">private static string IpStr = &quot;127.0.0.1&quot;;  </div><div class=\"line\">private static Socket serverSocket;  </div><div class=\"line\">  </div><div class=\"line\">static void Main(string[] args)  </div><div class=\"line\">&#123;  </div><div class=\"line\">    IPAddress ip = IPAddress.Parse(IpStr);  </div><div class=\"line\">    IPEndPoint ip_end_point = new IPEndPoint(ip, port);  </div><div class=\"line\">    //创建服务器Socket对象，并设置相关属性  </div><div class=\"line\">    serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  </div><div class=\"line\">    //绑定ip和端口  </div><div class=\"line\">    serverSocket.Bind(ip_end_point);  </div><div class=\"line\">    //设置最长的连接请求队列长度  </div><div class=\"line\">    serverSocket.Listen(10);  </div><div class=\"line\">    Console.WriteLine(&quot;启动监听&#123;0&#125;成功&quot;, serverSocket.LocalEndPoint.ToString());  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>完成上述代码之后，已经能正常启动一个服务器Socket，但是还没有处理连接监听逻辑和数据接收，所以运行应用会出现一闪就关掉的情况。</p>\n<ul>\n<li><p>启动一个线程，并在线程中监听客户端的连接，为每个连接创建一个Socket对象；</p>\n</li>\n<li><p>创建接受数据和发送数据的方法，完整的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div></pre></td><td class=\"code\"><pre><div class=\"line\">using System;  </div><div class=\"line\">using System.Collections.Generic;  </div><div class=\"line\">using System.Linq;  </div><div class=\"line\">using System.Net.Sockets;  </div><div class=\"line\">using System.Text;  </div><div class=\"line\">using System.Threading.Tasks;  </div><div class=\"line\">using System.Net;  </div><div class=\"line\">using System.Threading;  </div><div class=\"line\">using Net;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">  </div><div class=\"line\">namespace ConsoleApplication1  </div><div class=\"line\">&#123;  </div><div class=\"line\">    class Program  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        private static byte[] result = new byte[1024];  </div><div class=\"line\">        private const int port = 8088;  </div><div class=\"line\">        private static string IpStr = &quot;127.0.0.1&quot;;  </div><div class=\"line\">        private static Socket serverSocket;  </div><div class=\"line\">  </div><div class=\"line\">        static void Main(string[] args)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            IPAddress ip = IPAddress.Parse(IpStr);  </div><div class=\"line\">            IPEndPoint ip_end_point = new IPEndPoint(ip, port);  </div><div class=\"line\">            //创建服务器Socket对象，并设置相关属性  </div><div class=\"line\">            serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  </div><div class=\"line\">            //绑定ip和端口  </div><div class=\"line\">            serverSocket.Bind(ip_end_point);  </div><div class=\"line\">            //设置最长的连接请求队列长度  </div><div class=\"line\">            serverSocket.Listen(10);  </div><div class=\"line\">            Console.WriteLine(&quot;启动监听&#123;0&#125;成功&quot;, serverSocket.LocalEndPoint.ToString());  </div><div class=\"line\">            //在新线程中监听客户端的连接  </div><div class=\"line\">            Thread thread = new Thread(ClientConnectListen);  </div><div class=\"line\">            thread.Start();  </div><div class=\"line\">            Console.ReadLine();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 客户端连接请求监听  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        private static void ClientConnectListen()  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            while (true)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                //为新的客户端连接创建一个Socket对象  </div><div class=\"line\">                Socket clientSocket = serverSocket.Accept();  </div><div class=\"line\">                Console.WriteLine(&quot;客户端&#123;0&#125;成功连接&quot;, clientSocket.RemoteEndPoint.ToString());  </div><div class=\"line\">                //向连接的客户端发送连接成功的数据  </div><div class=\"line\">                ByteBuffer buffer = new ByteBuffer();  </div><div class=\"line\">                buffer.WriteString(&quot;Connected Server&quot;);  </div><div class=\"line\">                clientSocket.Send(WriteMessage(buffer.ToBytes()));  </div><div class=\"line\">                //每个客户端连接创建一个线程来接受该客户端发送的消息  </div><div class=\"line\">                Thread thread = new Thread(RecieveMessage);  </div><div class=\"line\">                thread.Start(clientSocket);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">        /// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">        private static byte[] WriteMessage(byte[] message)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            MemoryStream ms = null;  </div><div class=\"line\">            using (ms = new MemoryStream())  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                ms.Position = 0;  </div><div class=\"line\">                BinaryWriter writer = new BinaryWriter(ms);  </div><div class=\"line\">                ushort msglen = (ushort)message.Length;  </div><div class=\"line\">                writer.Write(msglen);  </div><div class=\"line\">                writer.Write(message);  </div><div class=\"line\">                writer.Flush();  </div><div class=\"line\">                return ms.ToArray();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 接收指定客户端Socket的消息  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        /// &lt;param name=&quot;clientSocket&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">        private static void RecieveMessage(object clientSocket)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Socket mClientSocket = (Socket)clientSocket;  </div><div class=\"line\">            while (true)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                try  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    int receiveNumber = mClientSocket.Receive(result);  </div><div class=\"line\">                    Console.WriteLine(&quot;接收客户端&#123;0&#125;消息， 长度为&#123;1&#125;&quot;, mClientSocket.RemoteEndPoint.ToString(), receiveNumber);  </div><div class=\"line\">                    ByteBuffer buff = new ByteBuffer(result);  </div><div class=\"line\">                    //数据长度  </div><div class=\"line\">                    int len = buff.ReadShort();  </div><div class=\"line\">                    //数据内容  </div><div class=\"line\">                    string data = buff.ReadString();  </div><div class=\"line\">                    Console.WriteLine(&quot;数据内容：&#123;0&#125;&quot;, data);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                catch (Exception ex)  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    Console.WriteLine(ex.Message);  </div><div class=\"line\">                    mClientSocket.Shutdown(SocketShutdown.Both);  </div><div class=\"line\">                    mClientSocket.Close();  </div><div class=\"line\">                    break;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-客户端创建：\"><a href=\"#2-客户端创建：\" class=\"headerlink\" title=\"2.客户端创建：\"></a>2.客户端创建：</h4><p>客户端连接服务器的逻辑相对简单一些，跟服务器一样，先把ByteBuffer类导入到工程中，基本步骤如下：</p>\n<ul>\n<li>创建一个Socket对象，这个对象在客户端是唯一的，可以理解为单例模式；</li>\n<li>使用上面创建Socket连接指定服务器IP和端口号；</li>\n<li>接收服务器数据和发送数据给服务器。</li>\n</ul>\n<p>先创建一个ClientSocket类用于管理Socket的一些方法：连接服务器、接受数据和发送数据等：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using System.Net;  </div><div class=\"line\">using System.Net.Sockets;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">  </div><div class=\"line\">namespace Net  </div><div class=\"line\">&#123;  </div><div class=\"line\">    public class ClientSocket  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        private static byte[] result = new byte[1024];  </div><div class=\"line\">        private static Socket clientSocket;  </div><div class=\"line\">        //是否已连接的标识  </div><div class=\"line\">        public bool IsConnected = false;  </div><div class=\"line\">  </div><div class=\"line\">        public ClientSocket()&#123;  </div><div class=\"line\">            clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 连接指定IP和端口的服务器  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        /// &lt;param name=&quot;ip&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">        /// &lt;param name=&quot;port&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">        public void ConnectServer(string ip,int port)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            IPAddress mIp = IPAddress.Parse(ip);  </div><div class=\"line\">            IPEndPoint ip_end_point = new IPEndPoint(mIp, port);  </div><div class=\"line\">  </div><div class=\"line\">            try &#123;  </div><div class=\"line\">                clientSocket.Connect(ip_end_point);  </div><div class=\"line\">                IsConnected = true;  </div><div class=\"line\">                Debug.Log(&quot;连接服务器成功&quot;);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                IsConnected = false;  </div><div class=\"line\">                Debug.Log(&quot;连接服务器失败&quot;);  </div><div class=\"line\">                return;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            //服务器下发数据长度  </div><div class=\"line\">            int receiveLength = clientSocket.Receive(result);  </div><div class=\"line\">            ByteBuffer buffer = new ByteBuffer(result);  </div><div class=\"line\">            int len = buffer.ReadShort();  </div><div class=\"line\">            string data = buffer.ReadString();  </div><div class=\"line\">            Debug.Log(&quot;服务器返回数据：&quot; + data);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 发送数据给服务器  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        public void SendMessage(string data)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            if (IsConnected == false)  </div><div class=\"line\">                return;  </div><div class=\"line\">            try  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                ByteBuffer buffer = new ByteBuffer();  </div><div class=\"line\">                buffer.WriteString(data);  </div><div class=\"line\">                clientSocket.Send(WriteMessage(buffer.ToBytes()));  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                IsConnected = false;  </div><div class=\"line\">                clientSocket.Shutdown(SocketShutdown.Both);  </div><div class=\"line\">                clientSocket.Close();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        /// &lt;summary&gt;  </div><div class=\"line\">        /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class=\"line\">        /// &lt;/summary&gt;  </div><div class=\"line\">        /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">        /// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">        private static byte[] WriteMessage(byte[] message)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            MemoryStream ms = null;  </div><div class=\"line\">            using (ms = new MemoryStream())  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                ms.Position = 0;  </div><div class=\"line\">                BinaryWriter writer = new BinaryWriter(ms);  </div><div class=\"line\">                ushort msglen = (ushort)message.Length;  </div><div class=\"line\">                writer.Write(msglen);  </div><div class=\"line\">                writer.Write(message);  </div><div class=\"line\">                writer.Flush();  </div><div class=\"line\">                return ms.ToArray();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"三、样例测试：\"><a href=\"#三、样例测试：\" class=\"headerlink\" title=\"三、样例测试：\"></a>三、样例测试：</h3><h4 id=\"1-客户端测试：\"><a href=\"#1-客户端测试：\" class=\"headerlink\" title=\"1.客户端测试：\"></a>1.客户端测试：</h4><p>在Unity中写一个测试脚本TestSocket.cs，并将此脚本绑到当前场景的相机上：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using Net;  </div><div class=\"line\">  </div><div class=\"line\">public class TestSocket : MonoBehaviour &#123;  </div><div class=\"line\">  </div><div class=\"line\">    // Use this for initialization  </div><div class=\"line\">    void Start () &#123;  </div><div class=\"line\">        ClientSocket mSocket = new ClientSocket();  </div><div class=\"line\">        mSocket.ConnectServer(&quot;127.0.0.1&quot;, 8088);  </div><div class=\"line\">        mSocket.SendMessage(&quot;服务器傻逼！&quot;);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    // Update is called once per frame  </div><div class=\"line\">    void Update () &#123;  </div><div class=\"line\">      </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-启动服务器：\"><a href=\"#2-启动服务器：\" class=\"headerlink\" title=\"2.启动服务器：\"></a>2.启动服务器：</h4><p>在Visual Studio中点击运行按钮，启动服务器：<br><img src=\"http://img.blog.csdn.net/20160825164018638\" alt=\"\"><br>启动正常的话，会弹出一个窗口如下图所示：<br><img src=\"http://img.blog.csdn.net/20160825164121342\" alt=\"\"></p>\n<h4 id=\"3-开始连接：\"><a href=\"#3-开始连接：\" class=\"headerlink\" title=\"3.开始连接：\"></a>3.开始连接：</h4><p>在Unity中运行当前场景，查看输出日志，假如连接成功，输出如下：<br><img src=\"http://img.blog.csdn.net/20160825164333224\" alt=\"\"><br>查看服务器窗口，发现双向通信都正常：<br><img src=\"http://img.blog.csdn.net/20160825164551251\" alt=\"\"></p>\n<h3 id=\"四、总结：\"><a href=\"#四、总结：\" class=\"headerlink\" title=\"四、总结：\"></a>四、总结：</h3><p>这里测试案例其实很简单，协议没有进行如何优化，单纯地发送字符串数据而已，假如针对复杂的数据的话，需要创建完整打包和解包协议数据的机制，而且必要时还需要对数据进行加密操作。</p>"},{"title":"Unity3D —— protobuf导excel表格数据","date":"2016-09-18T12:21:47.000Z","_content":"\n### 前言：\n\n之前使用``NPOI插件``编写的导表工具，其实就是直接将数据进行**序列化**，解析时还需要进行**反序列化**，步骤比较繁复，最近看到Google的一个开源的项目``protobuf``，不仅可以用于进行excel表格数据的导出，还能直接用于网络通信协议的定制。\n\n### 一、protobuf简介：\n\nprotobuf是由google公司发布的一个开源的项目，是一款方便而又通用的数据传输协议。所以我们在Unity中也可以借助protobuf来进行数据存储和网络协议两方面的开发，这里先说说数据存储部分的操作，也就是：**将.xls表格数据通过protobuf进行序列化，并在Unity中使用。**\n\n<!--more-->\n\n#### 1.下载资源：\n- [python2.7安装和配置](http://blog.csdn.net/linshuhe1/article/details/52056864)\n- [protobuf-2.5.0.zip](http://pan.baidu.com/s/1kVk5LhP)\n- [protobuf-net](https://github.com/mgravell/protobuf-net)\n\n#### 2.流程图：\n![](http://img.blog.csdn.net/20160818164221144)\n从上图可看出基本的操作步骤：\n\n- .xls表格文件，先通过``xls_deploy_tool.py``生成对应的.data文件和.proto文件，其中.data文件就是表格数据序列化后的结果，而.proto文件则是用于生成反序列化时使用的解析类的中间状态；\n- 解析类.proto经过``protoc.exe``转换成.desc文件，用于后面通过protobuf-net等工具转化为特定的语言，这里我们需要得到的是C#解析类，即.cs类；\n- 在Unity中导入``protobuf-net.dll``库，在C#代码中调用上述生成的.cs解析类来解析.data中的数据。\n\n### 二、导表环境配置：\n#### 1.Python相关配置：\n由于从.xls文件生成.data和.proto，Python需要依赖``Proto库``和``xlrd库``，安装配置步骤：\n        \n- **setuptools**：这是Python的组件安装管理器，需要在安装protobuff组件前进行安装，到[setuptools官网](https://pypi.python.org/pypi/setuptools#downloads)下载插件的安装包，解压到指定目录，然后使用命令行进入安装包目录，执行指令：\n```bash\npython setup.py install；\n```\n\n- **Protobuff**：首先，我们将之前下载好的**源码包protobuf-2.5.0.zip**和**编译包protoc-2.5.0-win32.zip**压缩包解压到指定目录，路径最好不要包含中文；\n   - 这里我解压protobuf-2.5.0.zip到的位置是“E:\\Unity_Workplace\\protobuf_250”；\n   - 然后复制protoc-2.5.0-win32.zip解压得到的**protoc.exe**到protobuf_250\\src目录下；\n   - 在protobuf-2.5.0\\python\\google\\protobuf下创建一个文件夹命名为**compiler**（安装完成后会在此目录下生成两个文件__init__.py和plugin_pb2.py）；\n   - 使用命令行进入到解压后的目录下面的**Python目录**，执行：\n```bash \npython setup.py install；\n```\n        \n- **xlrd(xls reader)**：这其实是读取xls表格数据的一个工具插件，到[xlrd官网](https://pypi.python.org/pypi/xlrd)下载xrld的安装包，解压安装包然后使用命令行进入安装包目录，执行指令：\n```bash \npython setup.py install。\n```\n\n#### 2.导表外部工具：\n- **xls_deploy_tool.py**：这个工具其实是github上的一个开源的符合protobuff标准的根据excel自动生成匹配的PB的定义（``.proto文件``）并将数据序列化后生成二进制数据或者文本数据（``.data文件``）的一个工具，github下载地址：[xls_deploy_tool.py](https://github.com/jameyli/tnt/tree/master/python)。\n\n- **protoc.exe和protogen.exe**：通过上面的工具，我们得到了两个文件：存储数据的.data文件和用于解析数据的.proto文件，但是我们在真正使用解析类来进行数据文件的解析时，必须是高级语言，当然protobuf-net提供很多种高级语言的支持。就像我们在Unity中我们使用的是C#语言，这需要两个工具来实现，一个是protobuf-2.5.0中的``protoc.exe``将.proto文件转换为“FileDescriptorSet”中间格式；另一个是使用protobuf-net中的``protogen.exe``，将中间格式的文件转换为最终状态，即高级语言的解析类.cs文件。\n\n- 可以到github上下载protobuf-net的源码：[protobuf-net](https://github.com/linshuhe/protobuf-net)，下载后解压到本地，然后进入到解压后protobuf-net-master\\protobuf-net目录下，通过Visual Studio打开protobuf-net.csproj：\n![](http://img.blog.csdn.net/20160822105531605) ![](http://img.blog.csdn.net/20160822105539356)\n\n- 编译完成后在当前目录下面的bin\\Release目录下，生成了编译后的文件，其中我们需要的是protobuf-net.dll：\n![](http://img.blog.csdn.net/20160822112150454)\n\n- 将protobuf-net.dll复制到protobuf-net-master\\ProtoGen目录下，用Visual Studio打开ProtoGen.csproj，参照上面步骤编译ProtoGen项目，得到protobuf-net-master\\ProtoGen\\bin\\Release目录下面的protogen.exe及一些额外的文件，但在真正使用时此目录下面的所有文件都是必须的：\n![](http://img.blog.csdn.net/20160822112506834)\n\n### 三、样例：\n#### 1.建立表格.xls：\n当然使用此工具进行导表的表格需要符合指定的格式，根据xls_deploy_tool.py的备注内容：\n```bash\n# 说明:  \n#   excel 的前四行用于结构定义, 其余则为数据，按第一行区分, 分别解释：  \n#       required 必有属性  \n#       optional 可选属性  \n#           第二行: 属性类型  \n#           第三行：属性名  \n#           第四行：注释  \n#           数据行：属性值  \n#       repeated 表明下一个属性是repeated,即数组  \n#           第二行: repeat的最大次数, excel中会重复列出该属性  \n#           2011-11-29 做了修改 第二行如果是类型定义的话，则表明该列是repeated  \n#           但是目前只支持整形  \n#           第三行：无用  \n#           第四行：注释  \n#           数据行：实际的重复次数  \n#       required_struct 必选结构属性  \n#       optional_struct 可选结构属性  \n#           第二行：结构元素个数  \n#           第三行：结构名  \n#           第四行：在上层结构中的属性名  \n#           数据行：不用填  \n  \n#    1  | required/optional | repeated  | required_struct/optional_struct   |  \n#       | ------------------| ---------:| ---------------------------------:|  \n#    2  | 属性类型          |           | 结构元素个数                      |  \n#    3  | 属性名            |           | 结构类型名                        |  \n#    4  | 注释说明          |           | 在上层结构中的属性名              |  \n#    5  | 属性值            |           |                                   |\n```\n当然可以参考github上下载到的样例表格，下载[tnt](https://github.com/jameyli/tnt/)项目，然后复制其中python目录下面的内容，其中xls文件中就有一个goods_info.xls的样例表格：\n![](http://img.blog.csdn.net/20160821230930642)\n\n#### 2.xls_deploy_tool.py转换得到.data和.proto：\n进行导表的操作只需用在命令行中的一句指令即可完成：\n```bash\npython xls_deploy_tool.py sheet_name xls_path  \n```\n其中包含两个参数：sheet_name是.xls中要进行导表的表格页名，xls_path是要进行导表的.xls文件的路径。创建一个测试工程Test_protobuf，将1中的两个文件和protoc.exe放入其中：\n![](http://img.blog.csdn.net/20160821231242376)\n在命令行定位到该目录下，然后运行指令：\n```bash\ncall python xls_deploy_tool.py GOODS_INFO xls/goods_info.xls  \n```\n运行结束后，该目录下多出了几个文件，但我们真正需要的只有两个文件，即.data数据文件和.proto解析类：\n![](http://img.blog.csdn.net/20160821231633799)\n![](http://img.blog.csdn.net/20160821231921863)\n\n#### 3.得到最终解析类：\n``protoc.exe``得到中间格式文件，假设后缀为.protodesc，使用指令：\n```bash\nprotoc 输入文件路径(.proto文件) --descriptor_set_out=输出文件路径（.protodesc）  \n```\n在步骤2中的测试工程基础上继续执行指令：\n```bash\nprotoc tnt_deploy_goods_info.proto --descriptor_set_out=goods_info.protodesc  \n```\n运行此步之后，在项目中又多出了一个与.proto对应的.protodesc文件：\n![](http://img.blog.csdn.net/20160821232254537)  \nprotogen.exe得到.cs解析类，使用指令：\n```bash\nprotogen -i:输入文件路径（.protodesc） -o:输出文件路径（.cs）  \n```\n将之前生成protogen.exe时protobuf-net-master\\ProtoGen\\bin\\Release目录下面的所有文件复制到当前工程中，用一个文件夹ProtoGen来存放，假如不想执行这么繁琐的过程，也可以直接使用我编译好的ProtoGen文件目录压缩包：[ProtoGen.zip](http://download.csdn.net/detail/linshuhe1/9609654)，在当前项目的根目录下执行以下指令：\n```bash\ncall ProtoGen\\protogen -i:goods_info.protodesc -o:goods_info.cs  \n```\n执行结果，在当前目录下生成了解析类的最终状态goods_info.cs：\n![](http://img.blog.csdn.net/20160822114317374)\n\n当然，以上三步可以直接用批处理来完成，直接在当前项目根目录下新建一个文件，命名为generator.bat，内容为：\n```bash\ncall python xls_deploy_tool.py GOODS_INFO xls/goods_info.xls  \ncall protoc tnt_deploy_goods_info.proto --descriptor_set_out=goods_info.protodesc  \ncall ProtoGen\\protogen -i:goods_info.protodesc -o:goods_info.cs  \npause  \n```\n直接双击此文件即可完成以上所有操作生成最终的``.data``和``.cs``文件。\n![](http://img.blog.csdn.net/20160822114656222)  \n\n#### 4.Unity导入库文件：\n\n将几个文件添加到Unity工程中，将.data文件放在Assets\\StreamingAssets\\DataConfig目录下，将protobuf-net.dll和goods_info.cs放在Assets目录下：\n![](http://img.blog.csdn.net/20160822145729118)\n![](http://img.blog.csdn.net/20160822145805294)\n创建一个Test.cs测试脚本，在脚本中``using Protobuf``用于导入protobuf-net.dll中的库，然后使用``using tnt_deploy``导入导表生成的.cs表格数据解析类，脚本具体代码内容为：\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing ProtoBuf;  \nusing System.IO;  \nusing tnt_deploy;  \n  \npublic class Test : MonoBehaviour {  \n    void Start () {  \n        GOODS_INFO_ARRAY goods_infos = ReadOneDataConfig<GOODS_INFO_ARRAY>(\"goods_info\");  \n        Debug.Log(\"goods_id==================\" + goods_infos.items[0].goods_id);  \n    }  \n  \n    private T ReadOneDataConfig<T>(string FileName)  \n    {  \n        FileStream fileStream;  \n        fileStream = GetDataFileStream(FileName);  \n        if (null != fileStream)  \n        {  \n            T t = Serializer.Deserialize<T>(fileStream);  \n            fileStream.Close();  \n            return t;  \n        }  \n  \n        return default(T);  \n    }  \n    private FileStream GetDataFileStream(string fileName)  \n    {  \n        string filePath = GetDataConfigPath(fileName);  \n        if (File.Exists(filePath))  \n        {  \n            FileStream fileStream = new FileStream(filePath, FileMode.Open);  \n            return fileStream;  \n        }  \n  \n        return null;  \n    }  \n    private string GetDataConfigPath(string fileName)  \n    {  \n        return Application.streamingAssetsPath + \"/DataConfig/\" + fileName + \".data\";  \n    }  \n}  \n```\n在Unity中新建一个场景，将Test.cs挂载在Main Camera主相机上，运行场景，看到打印结果，说明解析表格数据成功：\n![](http://img.blog.csdn.net/20160822145928497) \n\n#### 5.平台兼容问题：\n\n由于直接把protobuf-net.dll放到项目中时，在iOS中会出现**JIT错误**（ExecutionEngineException: Attempting to JIT compile method）。原因是因为iOS不允许JIT（Just In Time），只允许AOT（Ahead Of Time）。\n\n#### 解决方法：\n\n直接把protprotobuf-net-master\\protobuf-net目录下面的全部源码复制到Unity项目的目录下面，但是由于protobuf-net的编译过程是**unsafe编译**，所以Unity会出现编译报错：\n![](http://img.blog.csdn.net/20160822151338719)\n需要**在Assets目录下添加一个smsc.rsp文件**，其内容很简单，只有一行“-unsafe”，添加完成后关闭Unity然后重新打开Unity，一切就正常了。\n\n### 四、总结：\n虽然导表环境的配置过程比较繁琐，但是配置完成之后的工作效率却很高，而且proto具有突出的通用性，可以应用于各种语言环境。","source":"_posts/Unity3D-protobuf导excel表格数据.md","raw":"---\ntitle: Unity3D —— protobuf导excel表格数据\ndate: 2016-09-18 20:21:47\ntags: protobuf,Unity\ncategories: Unity\n---\n\n### 前言：\n\n之前使用``NPOI插件``编写的导表工具，其实就是直接将数据进行**序列化**，解析时还需要进行**反序列化**，步骤比较繁复，最近看到Google的一个开源的项目``protobuf``，不仅可以用于进行excel表格数据的导出，还能直接用于网络通信协议的定制。\n\n### 一、protobuf简介：\n\nprotobuf是由google公司发布的一个开源的项目，是一款方便而又通用的数据传输协议。所以我们在Unity中也可以借助protobuf来进行数据存储和网络协议两方面的开发，这里先说说数据存储部分的操作，也就是：**将.xls表格数据通过protobuf进行序列化，并在Unity中使用。**\n\n<!--more-->\n\n#### 1.下载资源：\n- [python2.7安装和配置](http://blog.csdn.net/linshuhe1/article/details/52056864)\n- [protobuf-2.5.0.zip](http://pan.baidu.com/s/1kVk5LhP)\n- [protobuf-net](https://github.com/mgravell/protobuf-net)\n\n#### 2.流程图：\n![](http://img.blog.csdn.net/20160818164221144)\n从上图可看出基本的操作步骤：\n\n- .xls表格文件，先通过``xls_deploy_tool.py``生成对应的.data文件和.proto文件，其中.data文件就是表格数据序列化后的结果，而.proto文件则是用于生成反序列化时使用的解析类的中间状态；\n- 解析类.proto经过``protoc.exe``转换成.desc文件，用于后面通过protobuf-net等工具转化为特定的语言，这里我们需要得到的是C#解析类，即.cs类；\n- 在Unity中导入``protobuf-net.dll``库，在C#代码中调用上述生成的.cs解析类来解析.data中的数据。\n\n### 二、导表环境配置：\n#### 1.Python相关配置：\n由于从.xls文件生成.data和.proto，Python需要依赖``Proto库``和``xlrd库``，安装配置步骤：\n        \n- **setuptools**：这是Python的组件安装管理器，需要在安装protobuff组件前进行安装，到[setuptools官网](https://pypi.python.org/pypi/setuptools#downloads)下载插件的安装包，解压到指定目录，然后使用命令行进入安装包目录，执行指令：\n```bash\npython setup.py install；\n```\n\n- **Protobuff**：首先，我们将之前下载好的**源码包protobuf-2.5.0.zip**和**编译包protoc-2.5.0-win32.zip**压缩包解压到指定目录，路径最好不要包含中文；\n   - 这里我解压protobuf-2.5.0.zip到的位置是“E:\\Unity_Workplace\\protobuf_250”；\n   - 然后复制protoc-2.5.0-win32.zip解压得到的**protoc.exe**到protobuf_250\\src目录下；\n   - 在protobuf-2.5.0\\python\\google\\protobuf下创建一个文件夹命名为**compiler**（安装完成后会在此目录下生成两个文件__init__.py和plugin_pb2.py）；\n   - 使用命令行进入到解压后的目录下面的**Python目录**，执行：\n```bash \npython setup.py install；\n```\n        \n- **xlrd(xls reader)**：这其实是读取xls表格数据的一个工具插件，到[xlrd官网](https://pypi.python.org/pypi/xlrd)下载xrld的安装包，解压安装包然后使用命令行进入安装包目录，执行指令：\n```bash \npython setup.py install。\n```\n\n#### 2.导表外部工具：\n- **xls_deploy_tool.py**：这个工具其实是github上的一个开源的符合protobuff标准的根据excel自动生成匹配的PB的定义（``.proto文件``）并将数据序列化后生成二进制数据或者文本数据（``.data文件``）的一个工具，github下载地址：[xls_deploy_tool.py](https://github.com/jameyli/tnt/tree/master/python)。\n\n- **protoc.exe和protogen.exe**：通过上面的工具，我们得到了两个文件：存储数据的.data文件和用于解析数据的.proto文件，但是我们在真正使用解析类来进行数据文件的解析时，必须是高级语言，当然protobuf-net提供很多种高级语言的支持。就像我们在Unity中我们使用的是C#语言，这需要两个工具来实现，一个是protobuf-2.5.0中的``protoc.exe``将.proto文件转换为“FileDescriptorSet”中间格式；另一个是使用protobuf-net中的``protogen.exe``，将中间格式的文件转换为最终状态，即高级语言的解析类.cs文件。\n\n- 可以到github上下载protobuf-net的源码：[protobuf-net](https://github.com/linshuhe/protobuf-net)，下载后解压到本地，然后进入到解压后protobuf-net-master\\protobuf-net目录下，通过Visual Studio打开protobuf-net.csproj：\n![](http://img.blog.csdn.net/20160822105531605) ![](http://img.blog.csdn.net/20160822105539356)\n\n- 编译完成后在当前目录下面的bin\\Release目录下，生成了编译后的文件，其中我们需要的是protobuf-net.dll：\n![](http://img.blog.csdn.net/20160822112150454)\n\n- 将protobuf-net.dll复制到protobuf-net-master\\ProtoGen目录下，用Visual Studio打开ProtoGen.csproj，参照上面步骤编译ProtoGen项目，得到protobuf-net-master\\ProtoGen\\bin\\Release目录下面的protogen.exe及一些额外的文件，但在真正使用时此目录下面的所有文件都是必须的：\n![](http://img.blog.csdn.net/20160822112506834)\n\n### 三、样例：\n#### 1.建立表格.xls：\n当然使用此工具进行导表的表格需要符合指定的格式，根据xls_deploy_tool.py的备注内容：\n```bash\n# 说明:  \n#   excel 的前四行用于结构定义, 其余则为数据，按第一行区分, 分别解释：  \n#       required 必有属性  \n#       optional 可选属性  \n#           第二行: 属性类型  \n#           第三行：属性名  \n#           第四行：注释  \n#           数据行：属性值  \n#       repeated 表明下一个属性是repeated,即数组  \n#           第二行: repeat的最大次数, excel中会重复列出该属性  \n#           2011-11-29 做了修改 第二行如果是类型定义的话，则表明该列是repeated  \n#           但是目前只支持整形  \n#           第三行：无用  \n#           第四行：注释  \n#           数据行：实际的重复次数  \n#       required_struct 必选结构属性  \n#       optional_struct 可选结构属性  \n#           第二行：结构元素个数  \n#           第三行：结构名  \n#           第四行：在上层结构中的属性名  \n#           数据行：不用填  \n  \n#    1  | required/optional | repeated  | required_struct/optional_struct   |  \n#       | ------------------| ---------:| ---------------------------------:|  \n#    2  | 属性类型          |           | 结构元素个数                      |  \n#    3  | 属性名            |           | 结构类型名                        |  \n#    4  | 注释说明          |           | 在上层结构中的属性名              |  \n#    5  | 属性值            |           |                                   |\n```\n当然可以参考github上下载到的样例表格，下载[tnt](https://github.com/jameyli/tnt/)项目，然后复制其中python目录下面的内容，其中xls文件中就有一个goods_info.xls的样例表格：\n![](http://img.blog.csdn.net/20160821230930642)\n\n#### 2.xls_deploy_tool.py转换得到.data和.proto：\n进行导表的操作只需用在命令行中的一句指令即可完成：\n```bash\npython xls_deploy_tool.py sheet_name xls_path  \n```\n其中包含两个参数：sheet_name是.xls中要进行导表的表格页名，xls_path是要进行导表的.xls文件的路径。创建一个测试工程Test_protobuf，将1中的两个文件和protoc.exe放入其中：\n![](http://img.blog.csdn.net/20160821231242376)\n在命令行定位到该目录下，然后运行指令：\n```bash\ncall python xls_deploy_tool.py GOODS_INFO xls/goods_info.xls  \n```\n运行结束后，该目录下多出了几个文件，但我们真正需要的只有两个文件，即.data数据文件和.proto解析类：\n![](http://img.blog.csdn.net/20160821231633799)\n![](http://img.blog.csdn.net/20160821231921863)\n\n#### 3.得到最终解析类：\n``protoc.exe``得到中间格式文件，假设后缀为.protodesc，使用指令：\n```bash\nprotoc 输入文件路径(.proto文件) --descriptor_set_out=输出文件路径（.protodesc）  \n```\n在步骤2中的测试工程基础上继续执行指令：\n```bash\nprotoc tnt_deploy_goods_info.proto --descriptor_set_out=goods_info.protodesc  \n```\n运行此步之后，在项目中又多出了一个与.proto对应的.protodesc文件：\n![](http://img.blog.csdn.net/20160821232254537)  \nprotogen.exe得到.cs解析类，使用指令：\n```bash\nprotogen -i:输入文件路径（.protodesc） -o:输出文件路径（.cs）  \n```\n将之前生成protogen.exe时protobuf-net-master\\ProtoGen\\bin\\Release目录下面的所有文件复制到当前工程中，用一个文件夹ProtoGen来存放，假如不想执行这么繁琐的过程，也可以直接使用我编译好的ProtoGen文件目录压缩包：[ProtoGen.zip](http://download.csdn.net/detail/linshuhe1/9609654)，在当前项目的根目录下执行以下指令：\n```bash\ncall ProtoGen\\protogen -i:goods_info.protodesc -o:goods_info.cs  \n```\n执行结果，在当前目录下生成了解析类的最终状态goods_info.cs：\n![](http://img.blog.csdn.net/20160822114317374)\n\n当然，以上三步可以直接用批处理来完成，直接在当前项目根目录下新建一个文件，命名为generator.bat，内容为：\n```bash\ncall python xls_deploy_tool.py GOODS_INFO xls/goods_info.xls  \ncall protoc tnt_deploy_goods_info.proto --descriptor_set_out=goods_info.protodesc  \ncall ProtoGen\\protogen -i:goods_info.protodesc -o:goods_info.cs  \npause  \n```\n直接双击此文件即可完成以上所有操作生成最终的``.data``和``.cs``文件。\n![](http://img.blog.csdn.net/20160822114656222)  \n\n#### 4.Unity导入库文件：\n\n将几个文件添加到Unity工程中，将.data文件放在Assets\\StreamingAssets\\DataConfig目录下，将protobuf-net.dll和goods_info.cs放在Assets目录下：\n![](http://img.blog.csdn.net/20160822145729118)\n![](http://img.blog.csdn.net/20160822145805294)\n创建一个Test.cs测试脚本，在脚本中``using Protobuf``用于导入protobuf-net.dll中的库，然后使用``using tnt_deploy``导入导表生成的.cs表格数据解析类，脚本具体代码内容为：\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing ProtoBuf;  \nusing System.IO;  \nusing tnt_deploy;  \n  \npublic class Test : MonoBehaviour {  \n    void Start () {  \n        GOODS_INFO_ARRAY goods_infos = ReadOneDataConfig<GOODS_INFO_ARRAY>(\"goods_info\");  \n        Debug.Log(\"goods_id==================\" + goods_infos.items[0].goods_id);  \n    }  \n  \n    private T ReadOneDataConfig<T>(string FileName)  \n    {  \n        FileStream fileStream;  \n        fileStream = GetDataFileStream(FileName);  \n        if (null != fileStream)  \n        {  \n            T t = Serializer.Deserialize<T>(fileStream);  \n            fileStream.Close();  \n            return t;  \n        }  \n  \n        return default(T);  \n    }  \n    private FileStream GetDataFileStream(string fileName)  \n    {  \n        string filePath = GetDataConfigPath(fileName);  \n        if (File.Exists(filePath))  \n        {  \n            FileStream fileStream = new FileStream(filePath, FileMode.Open);  \n            return fileStream;  \n        }  \n  \n        return null;  \n    }  \n    private string GetDataConfigPath(string fileName)  \n    {  \n        return Application.streamingAssetsPath + \"/DataConfig/\" + fileName + \".data\";  \n    }  \n}  \n```\n在Unity中新建一个场景，将Test.cs挂载在Main Camera主相机上，运行场景，看到打印结果，说明解析表格数据成功：\n![](http://img.blog.csdn.net/20160822145928497) \n\n#### 5.平台兼容问题：\n\n由于直接把protobuf-net.dll放到项目中时，在iOS中会出现**JIT错误**（ExecutionEngineException: Attempting to JIT compile method）。原因是因为iOS不允许JIT（Just In Time），只允许AOT（Ahead Of Time）。\n\n#### 解决方法：\n\n直接把protprotobuf-net-master\\protobuf-net目录下面的全部源码复制到Unity项目的目录下面，但是由于protobuf-net的编译过程是**unsafe编译**，所以Unity会出现编译报错：\n![](http://img.blog.csdn.net/20160822151338719)\n需要**在Assets目录下添加一个smsc.rsp文件**，其内容很简单，只有一行“-unsafe”，添加完成后关闭Unity然后重新打开Unity，一切就正常了。\n\n### 四、总结：\n虽然导表环境的配置过程比较繁琐，但是配置完成之后的工作效率却很高，而且proto具有突出的通用性，可以应用于各种语言环境。","slug":"Unity3D-protobuf导excel表格数据","published":1,"updated":"2017-06-24T02:13:49.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfkw00159gfjf42ervea","content":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>之前使用<code>NPOI插件</code>编写的导表工具，其实就是直接将数据进行<strong>序列化</strong>，解析时还需要进行<strong>反序列化</strong>，步骤比较繁复，最近看到Google的一个开源的项目<code>protobuf</code>，不仅可以用于进行excel表格数据的导出，还能直接用于网络通信协议的定制。</p>\n<h3 id=\"一、protobuf简介：\"><a href=\"#一、protobuf简介：\" class=\"headerlink\" title=\"一、protobuf简介：\"></a>一、protobuf简介：</h3><p>protobuf是由google公司发布的一个开源的项目，是一款方便而又通用的数据传输协议。所以我们在Unity中也可以借助protobuf来进行数据存储和网络协议两方面的开发，这里先说说数据存储部分的操作，也就是：<strong>将.xls表格数据通过protobuf进行序列化，并在Unity中使用。</strong></p>\n<a id=\"more\"></a>\n<h4 id=\"1-下载资源：\"><a href=\"#1-下载资源：\" class=\"headerlink\" title=\"1.下载资源：\"></a>1.下载资源：</h4><ul>\n<li><a href=\"http://blog.csdn.net/linshuhe1/article/details/52056864\" target=\"_blank\" rel=\"external\">python2.7安装和配置</a></li>\n<li><a href=\"http://pan.baidu.com/s/1kVk5LhP\" target=\"_blank\" rel=\"external\">protobuf-2.5.0.zip</a></li>\n<li><a href=\"https://github.com/mgravell/protobuf-net\" target=\"_blank\" rel=\"external\">protobuf-net</a></li>\n</ul>\n<h4 id=\"2-流程图：\"><a href=\"#2-流程图：\" class=\"headerlink\" title=\"2.流程图：\"></a>2.流程图：</h4><p><img src=\"http://img.blog.csdn.net/20160818164221144\" alt=\"\"><br>从上图可看出基本的操作步骤：</p>\n<ul>\n<li>.xls表格文件，先通过<code>xls_deploy_tool.py</code>生成对应的.data文件和.proto文件，其中.data文件就是表格数据序列化后的结果，而.proto文件则是用于生成反序列化时使用的解析类的中间状态；</li>\n<li>解析类.proto经过<code>protoc.exe</code>转换成.desc文件，用于后面通过protobuf-net等工具转化为特定的语言，这里我们需要得到的是C#解析类，即.cs类；</li>\n<li>在Unity中导入<code>protobuf-net.dll</code>库，在C#代码中调用上述生成的.cs解析类来解析.data中的数据。</li>\n</ul>\n<h3 id=\"二、导表环境配置：\"><a href=\"#二、导表环境配置：\" class=\"headerlink\" title=\"二、导表环境配置：\"></a>二、导表环境配置：</h3><h4 id=\"1-Python相关配置：\"><a href=\"#1-Python相关配置：\" class=\"headerlink\" title=\"1.Python相关配置：\"></a>1.Python相关配置：</h4><p>由于从.xls文件生成.data和.proto，Python需要依赖<code>Proto库</code>和<code>xlrd库</code>，安装配置步骤：</p>\n<ul>\n<li><p><strong>setuptools</strong>：这是Python的组件安装管理器，需要在安装protobuff组件前进行安装，到<a href=\"https://pypi.python.org/pypi/setuptools#downloads\" target=\"_blank\" rel=\"external\">setuptools官网</a>下载插件的安装包，解压到指定目录，然后使用命令行进入安装包目录，执行指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python setup.py install；</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Protobuff</strong>：首先，我们将之前下载好的<strong>源码包protobuf-2.5.0.zip</strong>和<strong>编译包protoc-2.5.0-win32.zip</strong>压缩包解压到指定目录，路径最好不要包含中文；</p>\n<ul>\n<li>这里我解压protobuf-2.5.0.zip到的位置是“E:\\Unity_Workplace\\protobuf_250”；</li>\n<li>然后复制protoc-2.5.0-win32.zip解压得到的<strong>protoc.exe</strong>到protobuf_250\\src目录下；</li>\n<li>在protobuf-2.5.0\\python\\google\\protobuf下创建一个文件夹命名为<strong>compiler</strong>（安装完成后会在此目录下生成两个文件<strong>init</strong>.py和plugin_pb2.py）；</li>\n<li>使用命令行进入到解压后的目录下面的<strong>Python目录</strong>，执行：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python setup.py install；</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>xlrd(xls reader)</strong>：这其实是读取xls表格数据的一个工具插件，到<a href=\"https://pypi.python.org/pypi/xlrd\" target=\"_blank\" rel=\"external\">xlrd官网</a>下载xrld的安装包，解压安装包然后使用命令行进入安装包目录，执行指令：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python setup.py install。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-导表外部工具：\"><a href=\"#2-导表外部工具：\" class=\"headerlink\" title=\"2.导表外部工具：\"></a>2.导表外部工具：</h4><ul>\n<li><p><strong>xls_deploy_tool.py</strong>：这个工具其实是github上的一个开源的符合protobuff标准的根据excel自动生成匹配的PB的定义（<code>.proto文件</code>）并将数据序列化后生成二进制数据或者文本数据（<code>.data文件</code>）的一个工具，github下载地址：<a href=\"https://github.com/jameyli/tnt/tree/master/python\" target=\"_blank\" rel=\"external\">xls_deploy_tool.py</a>。</p>\n</li>\n<li><p><strong>protoc.exe和protogen.exe</strong>：通过上面的工具，我们得到了两个文件：存储数据的.data文件和用于解析数据的.proto文件，但是我们在真正使用解析类来进行数据文件的解析时，必须是高级语言，当然protobuf-net提供很多种高级语言的支持。就像我们在Unity中我们使用的是C#语言，这需要两个工具来实现，一个是protobuf-2.5.0中的<code>protoc.exe</code>将.proto文件转换为“FileDescriptorSet”中间格式；另一个是使用protobuf-net中的<code>protogen.exe</code>，将中间格式的文件转换为最终状态，即高级语言的解析类.cs文件。</p>\n</li>\n<li><p>可以到github上下载protobuf-net的源码：<a href=\"https://github.com/linshuhe/protobuf-net\" target=\"_blank\" rel=\"external\">protobuf-net</a>，下载后解压到本地，然后进入到解压后protobuf-net-master\\protobuf-net目录下，通过Visual Studio打开protobuf-net.csproj：<br><img src=\"http://img.blog.csdn.net/20160822105531605\" alt=\"\"> <img src=\"http://img.blog.csdn.net/20160822105539356\" alt=\"\"></p>\n</li>\n<li><p>编译完成后在当前目录下面的bin\\Release目录下，生成了编译后的文件，其中我们需要的是protobuf-net.dll：<br><img src=\"http://img.blog.csdn.net/20160822112150454\" alt=\"\"></p>\n</li>\n<li><p>将protobuf-net.dll复制到protobuf-net-master\\ProtoGen目录下，用Visual Studio打开ProtoGen.csproj，参照上面步骤编译ProtoGen项目，得到protobuf-net-master\\ProtoGen\\bin\\Release目录下面的protogen.exe及一些额外的文件，但在真正使用时此目录下面的所有文件都是必须的：<br><img src=\"http://img.blog.csdn.net/20160822112506834\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"三、样例：\"><a href=\"#三、样例：\" class=\"headerlink\" title=\"三、样例：\"></a>三、样例：</h3><h4 id=\"1-建立表格-xls：\"><a href=\"#1-建立表格-xls：\" class=\"headerlink\" title=\"1.建立表格.xls：\"></a>1.建立表格.xls：</h4><p>当然使用此工具进行导表的表格需要符合指定的格式，根据xls_deploy_tool.py的备注内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 说明:  </span></div><div class=\"line\"><span class=\"comment\">#   excel 的前四行用于结构定义, 其余则为数据，按第一行区分, 分别解释：  </span></div><div class=\"line\"><span class=\"comment\">#       required 必有属性  </span></div><div class=\"line\"><span class=\"comment\">#       optional 可选属性  </span></div><div class=\"line\"><span class=\"comment\">#           第二行: 属性类型  </span></div><div class=\"line\"><span class=\"comment\">#           第三行：属性名  </span></div><div class=\"line\"><span class=\"comment\">#           第四行：注释  </span></div><div class=\"line\"><span class=\"comment\">#           数据行：属性值  </span></div><div class=\"line\"><span class=\"comment\">#       repeated 表明下一个属性是repeated,即数组  </span></div><div class=\"line\"><span class=\"comment\">#           第二行: repeat的最大次数, excel中会重复列出该属性  </span></div><div class=\"line\"><span class=\"comment\">#           2011-11-29 做了修改 第二行如果是类型定义的话，则表明该列是repeated  </span></div><div class=\"line\"><span class=\"comment\">#           但是目前只支持整形  </span></div><div class=\"line\"><span class=\"comment\">#           第三行：无用  </span></div><div class=\"line\"><span class=\"comment\">#           第四行：注释  </span></div><div class=\"line\"><span class=\"comment\">#           数据行：实际的重复次数  </span></div><div class=\"line\"><span class=\"comment\">#       required_struct 必选结构属性  </span></div><div class=\"line\"><span class=\"comment\">#       optional_struct 可选结构属性  </span></div><div class=\"line\"><span class=\"comment\">#           第二行：结构元素个数  </span></div><div class=\"line\"><span class=\"comment\">#           第三行：结构名  </span></div><div class=\"line\"><span class=\"comment\">#           第四行：在上层结构中的属性名  </span></div><div class=\"line\"><span class=\"comment\">#           数据行：不用填  </span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">#    1  | required/optional | repeated  | required_struct/optional_struct   |  </span></div><div class=\"line\"><span class=\"comment\">#       | ------------------| ---------:| ---------------------------------:|  </span></div><div class=\"line\"><span class=\"comment\">#    2  | 属性类型          |           | 结构元素个数                      |  </span></div><div class=\"line\"><span class=\"comment\">#    3  | 属性名            |           | 结构类型名                        |  </span></div><div class=\"line\"><span class=\"comment\">#    4  | 注释说明          |           | 在上层结构中的属性名              |  </span></div><div class=\"line\"><span class=\"comment\">#    5  | 属性值            |           |                                   |</span></div></pre></td></tr></table></figure></p>\n<p>当然可以参考github上下载到的样例表格，下载<a href=\"https://github.com/jameyli/tnt/\" target=\"_blank\" rel=\"external\">tnt</a>项目，然后复制其中python目录下面的内容，其中xls文件中就有一个goods_info.xls的样例表格：<br><img src=\"http://img.blog.csdn.net/20160821230930642\" alt=\"\"></p>\n<h4 id=\"2-xls-deploy-tool-py转换得到-data和-proto：\"><a href=\"#2-xls-deploy-tool-py转换得到-data和-proto：\" class=\"headerlink\" title=\"2.xls_deploy_tool.py转换得到.data和.proto：\"></a>2.xls_deploy_tool.py转换得到.data和.proto：</h4><p>进行导表的操作只需用在命令行中的一句指令即可完成：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python xls_deploy_tool.py sheet_name xls_path</div></pre></td></tr></table></figure></p>\n<p>其中包含两个参数：sheet_name是.xls中要进行导表的表格页名，xls_path是要进行导表的.xls文件的路径。创建一个测试工程Test_protobuf，将1中的两个文件和protoc.exe放入其中：<br><img src=\"http://img.blog.csdn.net/20160821231242376\" alt=\"\"><br>在命令行定位到该目录下，然后运行指令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">call python xls_deploy_tool.py GOODS_INFO xls/goods_info.xls</div></pre></td></tr></table></figure></p>\n<p>运行结束后，该目录下多出了几个文件，但我们真正需要的只有两个文件，即.data数据文件和.proto解析类：<br><img src=\"http://img.blog.csdn.net/20160821231633799\" alt=\"\"><br><img src=\"http://img.blog.csdn.net/20160821231921863\" alt=\"\"></p>\n<h4 id=\"3-得到最终解析类：\"><a href=\"#3-得到最终解析类：\" class=\"headerlink\" title=\"3.得到最终解析类：\"></a>3.得到最终解析类：</h4><p><code>protoc.exe</code>得到中间格式文件，假设后缀为.protodesc，使用指令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protoc 输入文件路径(.proto文件) --descriptor_set_out=输出文件路径（.protodesc）</div></pre></td></tr></table></figure></p>\n<p>在步骤2中的测试工程基础上继续执行指令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protoc tnt_deploy_goods_info.proto --descriptor_set_out=goods_info.protodesc</div></pre></td></tr></table></figure></p>\n<p>运行此步之后，在项目中又多出了一个与.proto对应的.protodesc文件：<br><img src=\"http://img.blog.csdn.net/20160821232254537\" alt=\"\"><br>protogen.exe得到.cs解析类，使用指令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protogen -i:输入文件路径（.protodesc） -o:输出文件路径（.cs）</div></pre></td></tr></table></figure></p>\n<p>将之前生成protogen.exe时protobuf-net-master\\ProtoGen\\bin\\Release目录下面的所有文件复制到当前工程中，用一个文件夹ProtoGen来存放，假如不想执行这么繁琐的过程，也可以直接使用我编译好的ProtoGen文件目录压缩包：<a href=\"http://download.csdn.net/detail/linshuhe1/9609654\" target=\"_blank\" rel=\"external\">ProtoGen.zip</a>，在当前项目的根目录下执行以下指令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">call ProtoGen\\protogen -i:goods_info.protodesc -o:goods_info.cs</div></pre></td></tr></table></figure></p>\n<p>执行结果，在当前目录下生成了解析类的最终状态goods_info.cs：<br><img src=\"http://img.blog.csdn.net/20160822114317374\" alt=\"\"></p>\n<p>当然，以上三步可以直接用批处理来完成，直接在当前项目根目录下新建一个文件，命名为generator.bat，内容为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">call python xls_deploy_tool.py GOODS_INFO xls/goods_info.xls  </div><div class=\"line\">call protoc tnt_deploy_goods_info.proto --descriptor_set_out=goods_info.protodesc  </div><div class=\"line\">call ProtoGen\\protogen -i:goods_info.protodesc -o:goods_info.cs  </div><div class=\"line\">pause</div></pre></td></tr></table></figure></p>\n<p>直接双击此文件即可完成以上所有操作生成最终的<code>.data</code>和<code>.cs</code>文件。<br><img src=\"http://img.blog.csdn.net/20160822114656222\" alt=\"\">  </p>\n<h4 id=\"4-Unity导入库文件：\"><a href=\"#4-Unity导入库文件：\" class=\"headerlink\" title=\"4.Unity导入库文件：\"></a>4.Unity导入库文件：</h4><p>将几个文件添加到Unity工程中，将.data文件放在Assets\\StreamingAssets\\DataConfig目录下，将protobuf-net.dll和goods_info.cs放在Assets目录下：<br><img src=\"http://img.blog.csdn.net/20160822145729118\" alt=\"\"><br><img src=\"http://img.blog.csdn.net/20160822145805294\" alt=\"\"><br>创建一个Test.cs测试脚本，在脚本中<code>using Protobuf</code>用于导入protobuf-net.dll中的库，然后使用<code>using tnt_deploy</code>导入导表生成的.cs表格数据解析类，脚本具体代码内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using ProtoBuf;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">using tnt_deploy;  </div><div class=\"line\">  </div><div class=\"line\">public class Test : MonoBehaviour &#123;  </div><div class=\"line\">    void Start () &#123;  </div><div class=\"line\">        GOODS_INFO_ARRAY goods_infos = ReadOneDataConfig&lt;GOODS_INFO_ARRAY&gt;(&quot;goods_info&quot;);  </div><div class=\"line\">        Debug.Log(&quot;goods_id==================&quot; + goods_infos.items[0].goods_id);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    private T ReadOneDataConfig&lt;T&gt;(string FileName)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        FileStream fileStream;  </div><div class=\"line\">        fileStream = GetDataFileStream(FileName);  </div><div class=\"line\">        if (null != fileStream)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            T t = Serializer.Deserialize&lt;T&gt;(fileStream);  </div><div class=\"line\">            fileStream.Close();  </div><div class=\"line\">            return t;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        return default(T);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    private FileStream GetDataFileStream(string fileName)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        string filePath = GetDataConfigPath(fileName);  </div><div class=\"line\">        if (File.Exists(filePath))  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            FileStream fileStream = new FileStream(filePath, FileMode.Open);  </div><div class=\"line\">            return fileStream;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        return null;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    private string GetDataConfigPath(string fileName)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        return Application.streamingAssetsPath + &quot;/DataConfig/&quot; + fileName + &quot;.data&quot;;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在Unity中新建一个场景，将Test.cs挂载在Main Camera主相机上，运行场景，看到打印结果，说明解析表格数据成功：<br><img src=\"http://img.blog.csdn.net/20160822145928497\" alt=\"\"> </p>\n<h4 id=\"5-平台兼容问题：\"><a href=\"#5-平台兼容问题：\" class=\"headerlink\" title=\"5.平台兼容问题：\"></a>5.平台兼容问题：</h4><p>由于直接把protobuf-net.dll放到项目中时，在iOS中会出现<strong>JIT错误</strong>（ExecutionEngineException: Attempting to JIT compile method）。原因是因为iOS不允许JIT（Just In Time），只允许AOT（Ahead Of Time）。</p>\n<h4 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h4><p>直接把protprotobuf-net-master\\protobuf-net目录下面的全部源码复制到Unity项目的目录下面，但是由于protobuf-net的编译过程是<strong>unsafe编译</strong>，所以Unity会出现编译报错：<br><img src=\"http://img.blog.csdn.net/20160822151338719\" alt=\"\"><br>需要<strong>在Assets目录下添加一个smsc.rsp文件</strong>，其内容很简单，只有一行“-unsafe”，添加完成后关闭Unity然后重新打开Unity，一切就正常了。</p>\n<h3 id=\"四、总结：\"><a href=\"#四、总结：\" class=\"headerlink\" title=\"四、总结：\"></a>四、总结：</h3><p>虽然导表环境的配置过程比较繁琐，但是配置完成之后的工作效率却很高，而且proto具有突出的通用性，可以应用于各种语言环境。</p>\n","excerpt":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>之前使用<code>NPOI插件</code>编写的导表工具，其实就是直接将数据进行<strong>序列化</strong>，解析时还需要进行<strong>反序列化</strong>，步骤比较繁复，最近看到Google的一个开源的项目<code>protobuf</code>，不仅可以用于进行excel表格数据的导出，还能直接用于网络通信协议的定制。</p>\n<h3 id=\"一、protobuf简介：\"><a href=\"#一、protobuf简介：\" class=\"headerlink\" title=\"一、protobuf简介：\"></a>一、protobuf简介：</h3><p>protobuf是由google公司发布的一个开源的项目，是一款方便而又通用的数据传输协议。所以我们在Unity中也可以借助protobuf来进行数据存储和网络协议两方面的开发，这里先说说数据存储部分的操作，也就是：<strong>将.xls表格数据通过protobuf进行序列化，并在Unity中使用。</strong></p>","more":"<h4 id=\"1-下载资源：\"><a href=\"#1-下载资源：\" class=\"headerlink\" title=\"1.下载资源：\"></a>1.下载资源：</h4><ul>\n<li><a href=\"http://blog.csdn.net/linshuhe1/article/details/52056864\">python2.7安装和配置</a></li>\n<li><a href=\"http://pan.baidu.com/s/1kVk5LhP\">protobuf-2.5.0.zip</a></li>\n<li><a href=\"https://github.com/mgravell/protobuf-net\">protobuf-net</a></li>\n</ul>\n<h4 id=\"2-流程图：\"><a href=\"#2-流程图：\" class=\"headerlink\" title=\"2.流程图：\"></a>2.流程图：</h4><p><img src=\"http://img.blog.csdn.net/20160818164221144\" alt=\"\"><br>从上图可看出基本的操作步骤：</p>\n<ul>\n<li>.xls表格文件，先通过<code>xls_deploy_tool.py</code>生成对应的.data文件和.proto文件，其中.data文件就是表格数据序列化后的结果，而.proto文件则是用于生成反序列化时使用的解析类的中间状态；</li>\n<li>解析类.proto经过<code>protoc.exe</code>转换成.desc文件，用于后面通过protobuf-net等工具转化为特定的语言，这里我们需要得到的是C#解析类，即.cs类；</li>\n<li>在Unity中导入<code>protobuf-net.dll</code>库，在C#代码中调用上述生成的.cs解析类来解析.data中的数据。</li>\n</ul>\n<h3 id=\"二、导表环境配置：\"><a href=\"#二、导表环境配置：\" class=\"headerlink\" title=\"二、导表环境配置：\"></a>二、导表环境配置：</h3><h4 id=\"1-Python相关配置：\"><a href=\"#1-Python相关配置：\" class=\"headerlink\" title=\"1.Python相关配置：\"></a>1.Python相关配置：</h4><p>由于从.xls文件生成.data和.proto，Python需要依赖<code>Proto库</code>和<code>xlrd库</code>，安装配置步骤：</p>\n<ul>\n<li><p><strong>setuptools</strong>：这是Python的组件安装管理器，需要在安装protobuff组件前进行安装，到<a href=\"https://pypi.python.org/pypi/setuptools#downloads\">setuptools官网</a>下载插件的安装包，解压到指定目录，然后使用命令行进入安装包目录，执行指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python setup.py install；</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Protobuff</strong>：首先，我们将之前下载好的<strong>源码包protobuf-2.5.0.zip</strong>和<strong>编译包protoc-2.5.0-win32.zip</strong>压缩包解压到指定目录，路径最好不要包含中文；</p>\n<ul>\n<li>这里我解压protobuf-2.5.0.zip到的位置是“E:\\Unity_Workplace\\protobuf_250”；</li>\n<li>然后复制protoc-2.5.0-win32.zip解压得到的<strong>protoc.exe</strong>到protobuf_250\\src目录下；</li>\n<li>在protobuf-2.5.0\\python\\google\\protobuf下创建一个文件夹命名为<strong>compiler</strong>（安装完成后会在此目录下生成两个文件<strong>init</strong>.py和plugin_pb2.py）；</li>\n<li>使用命令行进入到解压后的目录下面的<strong>Python目录</strong>，执行：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python setup.py install；</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>xlrd(xls reader)</strong>：这其实是读取xls表格数据的一个工具插件，到<a href=\"https://pypi.python.org/pypi/xlrd\">xlrd官网</a>下载xrld的安装包，解压安装包然后使用命令行进入安装包目录，执行指令：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python setup.py install。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-导表外部工具：\"><a href=\"#2-导表外部工具：\" class=\"headerlink\" title=\"2.导表外部工具：\"></a>2.导表外部工具：</h4><ul>\n<li><p><strong>xls_deploy_tool.py</strong>：这个工具其实是github上的一个开源的符合protobuff标准的根据excel自动生成匹配的PB的定义（<code>.proto文件</code>）并将数据序列化后生成二进制数据或者文本数据（<code>.data文件</code>）的一个工具，github下载地址：<a href=\"https://github.com/jameyli/tnt/tree/master/python\">xls_deploy_tool.py</a>。</p>\n</li>\n<li><p><strong>protoc.exe和protogen.exe</strong>：通过上面的工具，我们得到了两个文件：存储数据的.data文件和用于解析数据的.proto文件，但是我们在真正使用解析类来进行数据文件的解析时，必须是高级语言，当然protobuf-net提供很多种高级语言的支持。就像我们在Unity中我们使用的是C#语言，这需要两个工具来实现，一个是protobuf-2.5.0中的<code>protoc.exe</code>将.proto文件转换为“FileDescriptorSet”中间格式；另一个是使用protobuf-net中的<code>protogen.exe</code>，将中间格式的文件转换为最终状态，即高级语言的解析类.cs文件。</p>\n</li>\n<li><p>可以到github上下载protobuf-net的源码：<a href=\"https://github.com/linshuhe/protobuf-net\">protobuf-net</a>，下载后解压到本地，然后进入到解压后protobuf-net-master\\protobuf-net目录下，通过Visual Studio打开protobuf-net.csproj：<br><img src=\"http://img.blog.csdn.net/20160822105531605\" alt=\"\"> <img src=\"http://img.blog.csdn.net/20160822105539356\" alt=\"\"></p>\n</li>\n<li><p>编译完成后在当前目录下面的bin\\Release目录下，生成了编译后的文件，其中我们需要的是protobuf-net.dll：<br><img src=\"http://img.blog.csdn.net/20160822112150454\" alt=\"\"></p>\n</li>\n<li><p>将protobuf-net.dll复制到protobuf-net-master\\ProtoGen目录下，用Visual Studio打开ProtoGen.csproj，参照上面步骤编译ProtoGen项目，得到protobuf-net-master\\ProtoGen\\bin\\Release目录下面的protogen.exe及一些额外的文件，但在真正使用时此目录下面的所有文件都是必须的：<br><img src=\"http://img.blog.csdn.net/20160822112506834\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"三、样例：\"><a href=\"#三、样例：\" class=\"headerlink\" title=\"三、样例：\"></a>三、样例：</h3><h4 id=\"1-建立表格-xls：\"><a href=\"#1-建立表格-xls：\" class=\"headerlink\" title=\"1.建立表格.xls：\"></a>1.建立表格.xls：</h4><p>当然使用此工具进行导表的表格需要符合指定的格式，根据xls_deploy_tool.py的备注内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 说明:  </span></div><div class=\"line\"><span class=\"comment\">#   excel 的前四行用于结构定义, 其余则为数据，按第一行区分, 分别解释：  </span></div><div class=\"line\"><span class=\"comment\">#       required 必有属性  </span></div><div class=\"line\"><span class=\"comment\">#       optional 可选属性  </span></div><div class=\"line\"><span class=\"comment\">#           第二行: 属性类型  </span></div><div class=\"line\"><span class=\"comment\">#           第三行：属性名  </span></div><div class=\"line\"><span class=\"comment\">#           第四行：注释  </span></div><div class=\"line\"><span class=\"comment\">#           数据行：属性值  </span></div><div class=\"line\"><span class=\"comment\">#       repeated 表明下一个属性是repeated,即数组  </span></div><div class=\"line\"><span class=\"comment\">#           第二行: repeat的最大次数, excel中会重复列出该属性  </span></div><div class=\"line\"><span class=\"comment\">#           2011-11-29 做了修改 第二行如果是类型定义的话，则表明该列是repeated  </span></div><div class=\"line\"><span class=\"comment\">#           但是目前只支持整形  </span></div><div class=\"line\"><span class=\"comment\">#           第三行：无用  </span></div><div class=\"line\"><span class=\"comment\">#           第四行：注释  </span></div><div class=\"line\"><span class=\"comment\">#           数据行：实际的重复次数  </span></div><div class=\"line\"><span class=\"comment\">#       required_struct 必选结构属性  </span></div><div class=\"line\"><span class=\"comment\">#       optional_struct 可选结构属性  </span></div><div class=\"line\"><span class=\"comment\">#           第二行：结构元素个数  </span></div><div class=\"line\"><span class=\"comment\">#           第三行：结构名  </span></div><div class=\"line\"><span class=\"comment\">#           第四行：在上层结构中的属性名  </span></div><div class=\"line\"><span class=\"comment\">#           数据行：不用填  </span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">#    1  | required/optional | repeated  | required_struct/optional_struct   |  </span></div><div class=\"line\"><span class=\"comment\">#       | ------------------| ---------:| ---------------------------------:|  </span></div><div class=\"line\"><span class=\"comment\">#    2  | 属性类型          |           | 结构元素个数                      |  </span></div><div class=\"line\"><span class=\"comment\">#    3  | 属性名            |           | 结构类型名                        |  </span></div><div class=\"line\"><span class=\"comment\">#    4  | 注释说明          |           | 在上层结构中的属性名              |  </span></div><div class=\"line\"><span class=\"comment\">#    5  | 属性值            |           |                                   |</span></div></pre></td></tr></table></figure></p>\n<p>当然可以参考github上下载到的样例表格，下载<a href=\"https://github.com/jameyli/tnt/\">tnt</a>项目，然后复制其中python目录下面的内容，其中xls文件中就有一个goods_info.xls的样例表格：<br><img src=\"http://img.blog.csdn.net/20160821230930642\" alt=\"\"></p>\n<h4 id=\"2-xls-deploy-tool-py转换得到-data和-proto：\"><a href=\"#2-xls-deploy-tool-py转换得到-data和-proto：\" class=\"headerlink\" title=\"2.xls_deploy_tool.py转换得到.data和.proto：\"></a>2.xls_deploy_tool.py转换得到.data和.proto：</h4><p>进行导表的操作只需用在命令行中的一句指令即可完成：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python xls_deploy_tool.py sheet_name xls_path</div></pre></td></tr></table></figure></p>\n<p>其中包含两个参数：sheet_name是.xls中要进行导表的表格页名，xls_path是要进行导表的.xls文件的路径。创建一个测试工程Test_protobuf，将1中的两个文件和protoc.exe放入其中：<br><img src=\"http://img.blog.csdn.net/20160821231242376\" alt=\"\"><br>在命令行定位到该目录下，然后运行指令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">call python xls_deploy_tool.py GOODS_INFO xls/goods_info.xls</div></pre></td></tr></table></figure></p>\n<p>运行结束后，该目录下多出了几个文件，但我们真正需要的只有两个文件，即.data数据文件和.proto解析类：<br><img src=\"http://img.blog.csdn.net/20160821231633799\" alt=\"\"><br><img src=\"http://img.blog.csdn.net/20160821231921863\" alt=\"\"></p>\n<h4 id=\"3-得到最终解析类：\"><a href=\"#3-得到最终解析类：\" class=\"headerlink\" title=\"3.得到最终解析类：\"></a>3.得到最终解析类：</h4><p><code>protoc.exe</code>得到中间格式文件，假设后缀为.protodesc，使用指令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protoc 输入文件路径(.proto文件) --descriptor_set_out=输出文件路径（.protodesc）</div></pre></td></tr></table></figure></p>\n<p>在步骤2中的测试工程基础上继续执行指令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protoc tnt_deploy_goods_info.proto --descriptor_set_out=goods_info.protodesc</div></pre></td></tr></table></figure></p>\n<p>运行此步之后，在项目中又多出了一个与.proto对应的.protodesc文件：<br><img src=\"http://img.blog.csdn.net/20160821232254537\" alt=\"\"><br>protogen.exe得到.cs解析类，使用指令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protogen -i:输入文件路径（.protodesc） -o:输出文件路径（.cs）</div></pre></td></tr></table></figure></p>\n<p>将之前生成protogen.exe时protobuf-net-master\\ProtoGen\\bin\\Release目录下面的所有文件复制到当前工程中，用一个文件夹ProtoGen来存放，假如不想执行这么繁琐的过程，也可以直接使用我编译好的ProtoGen文件目录压缩包：<a href=\"http://download.csdn.net/detail/linshuhe1/9609654\">ProtoGen.zip</a>，在当前项目的根目录下执行以下指令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">call ProtoGen\\protogen -i:goods_info.protodesc -o:goods_info.cs</div></pre></td></tr></table></figure></p>\n<p>执行结果，在当前目录下生成了解析类的最终状态goods_info.cs：<br><img src=\"http://img.blog.csdn.net/20160822114317374\" alt=\"\"></p>\n<p>当然，以上三步可以直接用批处理来完成，直接在当前项目根目录下新建一个文件，命名为generator.bat，内容为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">call python xls_deploy_tool.py GOODS_INFO xls/goods_info.xls  </div><div class=\"line\">call protoc tnt_deploy_goods_info.proto --descriptor_set_out=goods_info.protodesc  </div><div class=\"line\">call ProtoGen\\protogen -i:goods_info.protodesc -o:goods_info.cs  </div><div class=\"line\">pause</div></pre></td></tr></table></figure></p>\n<p>直接双击此文件即可完成以上所有操作生成最终的<code>.data</code>和<code>.cs</code>文件。<br><img src=\"http://img.blog.csdn.net/20160822114656222\" alt=\"\">  </p>\n<h4 id=\"4-Unity导入库文件：\"><a href=\"#4-Unity导入库文件：\" class=\"headerlink\" title=\"4.Unity导入库文件：\"></a>4.Unity导入库文件：</h4><p>将几个文件添加到Unity工程中，将.data文件放在Assets\\StreamingAssets\\DataConfig目录下，将protobuf-net.dll和goods_info.cs放在Assets目录下：<br><img src=\"http://img.blog.csdn.net/20160822145729118\" alt=\"\"><br><img src=\"http://img.blog.csdn.net/20160822145805294\" alt=\"\"><br>创建一个Test.cs测试脚本，在脚本中<code>using Protobuf</code>用于导入protobuf-net.dll中的库，然后使用<code>using tnt_deploy</code>导入导表生成的.cs表格数据解析类，脚本具体代码内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using ProtoBuf;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">using tnt_deploy;  </div><div class=\"line\">  </div><div class=\"line\">public class Test : MonoBehaviour &#123;  </div><div class=\"line\">    void Start () &#123;  </div><div class=\"line\">        GOODS_INFO_ARRAY goods_infos = ReadOneDataConfig&lt;GOODS_INFO_ARRAY&gt;(&quot;goods_info&quot;);  </div><div class=\"line\">        Debug.Log(&quot;goods_id==================&quot; + goods_infos.items[0].goods_id);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    private T ReadOneDataConfig&lt;T&gt;(string FileName)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        FileStream fileStream;  </div><div class=\"line\">        fileStream = GetDataFileStream(FileName);  </div><div class=\"line\">        if (null != fileStream)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            T t = Serializer.Deserialize&lt;T&gt;(fileStream);  </div><div class=\"line\">            fileStream.Close();  </div><div class=\"line\">            return t;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        return default(T);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    private FileStream GetDataFileStream(string fileName)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        string filePath = GetDataConfigPath(fileName);  </div><div class=\"line\">        if (File.Exists(filePath))  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            FileStream fileStream = new FileStream(filePath, FileMode.Open);  </div><div class=\"line\">            return fileStream;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        return null;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    private string GetDataConfigPath(string fileName)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        return Application.streamingAssetsPath + &quot;/DataConfig/&quot; + fileName + &quot;.data&quot;;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在Unity中新建一个场景，将Test.cs挂载在Main Camera主相机上，运行场景，看到打印结果，说明解析表格数据成功：<br><img src=\"http://img.blog.csdn.net/20160822145928497\" alt=\"\"> </p>\n<h4 id=\"5-平台兼容问题：\"><a href=\"#5-平台兼容问题：\" class=\"headerlink\" title=\"5.平台兼容问题：\"></a>5.平台兼容问题：</h4><p>由于直接把protobuf-net.dll放到项目中时，在iOS中会出现<strong>JIT错误</strong>（ExecutionEngineException: Attempting to JIT compile method）。原因是因为iOS不允许JIT（Just In Time），只允许AOT（Ahead Of Time）。</p>\n<h4 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h4><p>直接把protprotobuf-net-master\\protobuf-net目录下面的全部源码复制到Unity项目的目录下面，但是由于protobuf-net的编译过程是<strong>unsafe编译</strong>，所以Unity会出现编译报错：<br><img src=\"http://img.blog.csdn.net/20160822151338719\" alt=\"\"><br>需要<strong>在Assets目录下添加一个smsc.rsp文件</strong>，其内容很简单，只有一行“-unsafe”，添加完成后关闭Unity然后重新打开Unity，一切就正常了。</p>\n<h3 id=\"四、总结：\"><a href=\"#四、总结：\" class=\"headerlink\" title=\"四、总结：\"></a>四、总结：</h3><p>虽然导表环境的配置过程比较繁琐，但是配置完成之后的工作效率却很高，而且proto具有突出的通用性，可以应用于各种语言环境。</p>"},{"title":"Unity3D —— protobuf网络框架","date":"2016-09-19T01:56:03.000Z","_content":"### 前言：\nprotobuf是google的一个开源项目，主要的用途是：\n\n- 数据存储（序列化和反序列化），这个功能类似xml和json等；\n- 制作网络通信协议；\n\n### 一、资源下载：\n\n- github源码地址：[protobuf-net](https://github.com/mgravell/protobuf-net)\n- google项目源码下载地址（**访问需翻墙**）：[protobuf-net](https://code.google.com/p/protobuf-net/)\n\n<!--more-->\n\n### 二、数据存储：\nC#语言方式的导表和解析过程，在之前的篇章中已经有详细的阐述：[Unity —— protobuf 导excel表格数据](http://blog.csdn.net/linshuhe1/article/details/52062969)，建议在看后续的操作之前先看一下这篇文档，因为后面设计到得一些操作与导表中是一致的，而且在理解了导表过程之后，能够快速地理解协议数据**序列化**和**反序列化**的过程。\n\n### 三、网络协议：\n#### 1.设计思想：\n有两个必要的数据：**协议号**和**协议类型**，将这两个数据分别存储起来\n\n- 当客户端向服务器发送数据时，会根据协议类型加上协议号，然后使用protobuf序列化之后再发送给服务器；\n- 当服务器发送数据给客户端时，根据协议号，用protobuf根据协议类型反序列化数据，并调用相应回调方法。\n\n由于数据在传输过程中，都是以数据流的形式存在的，而进行解析时无法单从protobuf数据中得知使用哪个解析类进行数据反序列化，这就要求我们在传输protobuf数据的同时，携带一个协议号，通过协议号和协议类型（解析类）之间的对应关系来确定进行数据反序列化的解析类。\n![](http://img.blog.csdn.net/20160824100320406)    \n此处协议号的作用就是用来确定用于解析数据的解析类，所以也可能称之为**协议类型名**，可以是``string``和``int``类型的数据。\n\n#### 2.特点分析：\n使用protobuf作为网络通信的数据载体，具有几个优点：\n\n- 通过序列化之后**数据量比较小**；\n- 而且**以key-value的方式存储数据**，这对于消息的版本兼容比较强；\n- 此外，由于protobuf提供的多语言支持，所以使用protobuf作为数据载体定制的网络协议**具有很强的跨语言特性**。\n\n### 四、样例实现：\n#### 1.协议定义：\n在之前导表的时候，我们得到了.proto的解析类，这是protobuf提供的一种特殊的脚本，具有格式简单、可读性强和方便拓展的特点，所以接下来我们就是**使用proto脚本来定义我们的协议**。例如：\n```C#\n// 物品  \nmessage Item  \n{  \n    required int32 Type     = 1;    //游戏物品大类  \n    optional int32 SubType  = 2;    //游戏物品小类  \n    required int32 num      = 3;    //游戏物品数量  \n}  \n  \n// 物品列表  \nmessage ItemList  \n{  \n    repeated Item item  = 1;    //物品列表  \n}  \n```\n上述例子中，Item相当于定义了一个数据结构或者是类，而ItemList是一个列表，列表中的每个元素都是一个Item对象。注意结构关键词：\n\n- ``required``：必有的属性\n- ``optional``：可选属性\n- ``repeated``：数组\n\n其实protobuf在这里只是提供了一个数据载体，通过在.proto中定义数据结构之后，需要使用与导表时一样的操作，步骤为：\n\n- 使用**protoc.exe**将.proto文件转化为.protodesc中间格式；\n- 使用**protogen.exe**将中间格式为.protodesc生成指定的高级语言类，我们在Unity中使用的是C#,所以结果是.cs类\n\n经过上述步骤之后，我们得到了协议类型对应的C#反序列化类，当我们收到服务器数据时，**根据协议号找到协议类型**，从而使用对应的反序列化的类对数据进行反序列化，得到最终的服务器数据内容。\n\n在这里，我们以登录为例，首先要清楚登录需要几个数据，正常情况下至少包含两个数据，即账号和密码，都是字符串类型，即定义cs_login.proto协议脚本，内容如下：\n```C#\npackage cs;  \n  \nmessage CSLoginInfo  \n{  \n    required string UserName = 1;//账号  \n    required string Password = 2;//密码  \n}  \n  \n//发送登录请求  \nmessage CSLoginReq  \n{  \n    required CSLoginInfo LoginInfo = 1;   \n}  \n//登录请求回包数据  \nmessage CSLoginRes  \n{  \n    required uint32 result_code = 1;   \n}  \n```\n``package``关键字后面的名称为.proto转为.cs之后的命名空间namespace的值，用message可以定义类，这里定义了一个CSLoginInfo的数据类，该类包含了账号和密码两个字符串类型的属性。然后定义了两个消息结构：\n\n- CSLoginReq登录请求消息，携带的数据是一个CSLoginInfo类型的对象数据；\n- CSLoginRes登录请求服务器返回的数据类型，返回结果是一个uint32无符号的整型数据，即结果码。\n\n上面定义的是协议类型，除此之外我们还需要为每一个协议类型定义一个协议号，这里可以用一个枚举脚本cs_enum.proto来保存，脚本内容为：\n```C#\npackage cs;  \n  \nenum EnmCmdID  \n{  \n    CS_LOGIN_REQ = 10001;//登录请求协议号  \n    CS_LOGIN_RES = 10002;//登录请求回包协议号  \n}  \n```\n使用protoc.exe和protogen.exe将这两个protobuf脚本得到C#类，具体步骤参考导表使用的操作，这里我直接给出自动化导表使用的批处理文件general_all.bat内容，具体文件目录可以根据自己放置情况进行调整：\n```bash\n::---------------------------------------------------  \n::第二步：把proto翻译成protodesc  \n::---------------------------------------------------  \ncall proto2cs\\protoc protos\\cs_login.proto --descriptor_set_out=cs_login.protodesc  \ncall proto2cs\\protoc protos\\cs_enum.proto --descriptor_set_out=cs_enum.protodesc  \n::---------------------------------------------------  \n::第二步：把protodesc翻译成cs  \n::---------------------------------------------------  \ncall proto2cs\\ProtoGen\\protogen -i:cs_login.protodesc -o:cs_login.cs  \ncall proto2cs\\ProtoGen\\protogen -i:cs_enum.protodesc -o:cs_enum.cs  \n::---------------------------------------------------  \n::第二步：把protodesc文件删除  \n::---------------------------------------------------  \ndel *.protodesc  \n  \npause  \n```\n转换结束后，我们的得到了两个.cs文件分别是：cs_enum.cs和cs_login.cs，将其放入到我们的Unity项目中，以便于接下来序列化和反序列化数据的使用。\n\n#### 2.协议数据构建：\n直接在项目代码中通过``using cs``引入协议解析类的命名空间，然后创建消息对象，并对对象的属性进行赋值，即可得到协议数据对象，例如登录请求对象的创建如下：\n```C#\nCSLoginInfo mLoginInfo = new CSLoginInfo();  \nmLoginInfo.UserName = \"linshuhe\";  \nmLoginInfo.Password = \"123456\";  \nCSLoginReq mReq = new CSLoginReq();  \nmReq.LoginInfo = mLoginInfo;  \n```\n从上述代码，可以得到登录请求对象mReq，里面包含了一个CSLoginInfo对象mLoginInfo，再次枚举对象中找到与此协议类型对应的协议号，即：``EnmCmdID.CS_LOGIN_REQ``\n\n#### 3.数据的序列化和反序列化：\n数据发送的时候必须以数据流的形式进行，所以这里我们需要考虑如何**将要发送的protobuf对象数据进行序列化，转化为byte[]字节数组**，这就需要借助ProtoBuf库为我们提供的``Serializer``类的``Serialize``方法来完成，而反序列化则需借助``Deserialize``方法，将这两个方法封装到PackCodec类中：\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing System.IO;  \nusing System;  \nusing ProtoBuf;  \n  \n/// <summary>  \n/// 网络协议数据打包和解包类  \n/// </summary>  \npublic class PackCodec{  \n    /// <summary>  \n    /// 序列化  \n    /// </summary>  \n    /// <typeparam name=\"T\"></typeparam>  \n    /// <param name=\"msg\"></param>  \n    /// <returns></returns>  \n    static public byte[] Serialize<T>(T msg)  \n    {  \n        byte[] result = null;  \n        if (msg != null)  \n        {  \n            using (var stream = new MemoryStream())  \n            {  \n                Serializer.Serialize<T>(stream, msg);  \n                result = stream.ToArray();  \n            }  \n        }  \n        return result;  \n    }  \n  \n    /// <summary>  \n    /// 反序列化  \n    /// </summary>  \n    /// <typeparam name=\"T\"></typeparam>  \n    /// <param name=\"message\"></param>  \n    /// <returns></returns>  \n    static public T Deserialize<T>(byte[] message)  \n    {  \n        T result = default(T);  \n        if (message != null)  \n        {  \n            using (var stream = new MemoryStream(message))  \n            {  \n                result = Serializer.Deserialize<T>(stream);  \n            }  \n        }  \n        return result;  \n    }  \n}  \n```\n使用方法很简单，直接传入一个数据对象即可得到字节数组：\n```C#\nbyte[] buf = PackCodec.Serialize(mReq);  \n```\n为了检验打包和解包是否匹配，我们可以直接做一次本地测试：将打包后的数据直接解包，看看数据是否与原来的一致：\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing System;  \nusing cs;  \nusing ProtoBuf;  \nusing System.IO;  \n  \npublic class TestProtoNet : MonoBehaviour {  \n  \n    // Use this for initialization  \n    void Start () {  \n        CSLoginInfo mLoginInfo = new CSLoginInfo();  \n        mLoginInfo.UserName = \"linshuhe\";  \n        mLoginInfo.Password = \"123456\";  \n        CSLoginReq mReq = new CSLoginReq();  \n        mReq.LoginInfo = mLoginInfo;  \n  \n        byte[] pbdata = PackCodec.Serialize(mReq);  \n        CSLoginReq pReq = PackCodec.Deserialize<CSLoginReq>(pbdata);  \n        Debug.Log(\"UserName = \" + pReq.LoginInfo.UserName + \", Password = \" + pReq.LoginInfo.Password);  \n    }  \n  \n    // Update is called once per frame  \n    void Update () {  \n      \n    }  \n} \n``` \n将此脚本绑到场景中的相机上，运行得到以下结果，则说明打包和解包完全匹配：\n![](http://img.blog.csdn.net/20160825100033496)    \n\n#### 4.数据发送和接收：\n这里我们使用的网络通信方式是Socket的强联网方式，关于如何在Unity中使用Socket进行通信，可以参考我之前的文章：[Unity —— Socket通信(C#)](http://blog.csdn.net/linshuhe1/article/details/51386559)，Unity客户端需要复制此项目的**ClientSocket.cs**和**ByteBuffer.cs**两个类到当前项目中。\n\n此外，服务器可以参照之前的方式搭建，唯一不同的是RecieveMessage(object clientSocket)方法解析数据的过程需要进行修改，因为需要使用protobuf-net.dll进行数据解包，所以需要参考客户端的做法，把protobuf-net.dll复制到服务器项目中的Protobuf_net目录下：  \n![](http://img.blog.csdn.net/20160825175754877)\n假如由于直接使用源码而不用.dll会出现不安全保存，需要在Visual Studio中设置允许不安全代码，具体步骤为：在“解决方案”中选中工程，右键“数据”，选择“生成”页签，勾选“允许不安全代码”：\n![](http://img.blog.csdn.net/20160825180841975)    \n当然，解析数据所用的解析类和协议号两个脚本cs_login.cs和cs_enum.cs也应该添加到服务器项目中，保证客户端和服务器一直，此外PackCodec.cs也需要添加到服务器代码中但是要把其中的using UnityEngine给去掉防止报错，最终服务器目录结构如下：\n![](http://img.blog.csdn.net/20160825191847662)\n\n#### 5.完整协议数据的封装：\n从之前说过的设计思路分析，我们在发送数据的时候除了要发送关键的protobuf数据之外，还需要带上两个附件的数据：协议头（用于进行通信检验）和协议号（用于确定解析类）。假设我们的是：\n\n- **协议头**：用于表示后面数据的长度，一个short类型的数据：\n```C#\n/// <summary>  \n/// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  \n/// </summary>  \n/// <param name=\"message\"></param>  \n/// <returns></returns>  \nprivate static byte[] WriteMessage(byte[] message)  \n{  \n    MemoryStream ms = null;  \n    using (ms = new MemoryStream())  \n    {  \n        ms.Position = 0;  \n        BinaryWriter writer = new BinaryWriter(ms);  \n        ushort msglen = (ushort)message.Length;  \n        writer.Write(msglen);  \n        writer.Write(message);  \n        writer.Flush();  \n        return ms.ToArray();  \n    }  \n}  \n```\n- **协议号**：用于对应解析类，这里我们使用的是int类型的数据：\n\n```C#\nprivate byte[] CreateData(int typeId,IExtensible pbuf)  \n  \nbyte[] pbdata = PackCodec.Serialize(pbuf);  \nByteBuffer buff = new ByteBuffer();  \nbuff.WriteInt(typeId);  \nbuff.WriteBytes(pbdata);  \nreturn buff.ToBytes();  \n```\n\n客户端发送登录数据时测试脚本TestProtoNet如下，测试需要将此脚本绑定到当前场景的相机上：\n\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing System;  \nusing cs;  \nusing Net;  \nusing ProtoBuf;  \nusing System.IO;  \n  \npublic class TestProtoNet : MonoBehaviour {  \n  \n    // Use this for initialization  \n    void Start () {  \n  \n  \n        CSLoginInfo mLoginInfo = new CSLoginInfo();  \n        mLoginInfo.UserName = \"linshuhe\";  \n        mLoginInfo.Password = \"123456\";  \n        CSLoginReq mReq = new CSLoginReq();  \n        mReq.LoginInfo = mLoginInfo;  \n  \n        byte[] data = CreateData((int)EnmCmdID.CS_LOGIN_REQ, mReq);  \n        ClientSocket mSocket = new ClientSocket();  \n        mSocket.ConnectServer(\"127.0.0.1\", 8088);  \n        mSocket.SendMessage(data);  \n    }  \n  \n    private byte[] CreateData(int typeId,IExtensible pbuf)  \n    {  \n        byte[] pbdata = PackCodec.Serialize(pbuf);  \n        ByteBuffer buff = new ByteBuffer();  \n        buff.WriteInt(typeId);  \n        buff.WriteBytes(pbdata);  \n        return WriteMessage(buff.ToBytes());  \n    }  \n  \n    /// <summary>  \n    /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  \n    /// </summary>  \n    /// <param name=\"message\"></param>  \n    /// <returns></returns>  \n    private static byte[] WriteMessage(byte[] message)  \n    {  \n        MemoryStream ms = null;  \n        using (ms = new MemoryStream())  \n        {  \n            ms.Position = 0;  \n            BinaryWriter writer = new BinaryWriter(ms);  \n            ushort msglen = (ushort)message.Length;  \n            writer.Write(msglen);  \n            writer.Write(message);  \n            writer.Flush();  \n            return ms.ToArray();  \n        }  \n    }  \n  \n    // Update is called once per frame  \n    void Update () {  \n      \n    }  \n} \n``` \n\n服务器接受数据解包过程参考打包数据的格式，在RecieveMessage(object clientSocket)中，解析数据的核心代码如下：\n\n```C#\nByteBuffer buff = new ByteBuffer(result);  \nint datalength = buff.ReadShort();  \nint typeId = buff.ReadInt();  \nbyte[] pbdata = buff.ReadBytes();  \n//通过协议号判断选择的解析类  \nif(typeId == (int)EnmCmdID.CS_LOGIN_REQ)  \n{  \n        CSLoginReq clientReq = PackCodec.Deserialize<CSLoginReq>(pbdata);  \n        string user_name = clientReq.LoginInfo.UserName;  \n        string pass_word = clientReq.LoginInfo.Password;  \n        Console.WriteLine(\"数据内容：UserName={0},Password={1}\", user_name, pass_word);  \n        }  \n}  \n```\n上面通过typeId来找到匹配的数据解析类，协议少的时候可以使用这种简单的使用if语句分支判断来实现，但是假如协议类型多了，则需要进一步封装查找方法，常用的方法有：定义一个Dictionary<int,Type>字典来存放协议号（int）和协议类型（Type）的对应关系。\n\n#### 6.运行结果：\n启动服务器，然后运行Unity中的客户端，得到正确的结果应该如下：\n![](http://img.blog.csdn.net/20160825192659728)\n项目服务器和客户端的完整代码可以前往此处下载：[protobuf-net网络协议的定制](http://download.csdn.net/detail/linshuhe1/9613076)","source":"_posts/Unity3D-protobuf网络框架.md","raw":"---\ntitle: Unity3D —— protobuf网络框架\ndate: 2016-09-19 09:56:03\ntags: protobuf,Unity\ncategories: Unity\n---\n### 前言：\nprotobuf是google的一个开源项目，主要的用途是：\n\n- 数据存储（序列化和反序列化），这个功能类似xml和json等；\n- 制作网络通信协议；\n\n### 一、资源下载：\n\n- github源码地址：[protobuf-net](https://github.com/mgravell/protobuf-net)\n- google项目源码下载地址（**访问需翻墙**）：[protobuf-net](https://code.google.com/p/protobuf-net/)\n\n<!--more-->\n\n### 二、数据存储：\nC#语言方式的导表和解析过程，在之前的篇章中已经有详细的阐述：[Unity —— protobuf 导excel表格数据](http://blog.csdn.net/linshuhe1/article/details/52062969)，建议在看后续的操作之前先看一下这篇文档，因为后面设计到得一些操作与导表中是一致的，而且在理解了导表过程之后，能够快速地理解协议数据**序列化**和**反序列化**的过程。\n\n### 三、网络协议：\n#### 1.设计思想：\n有两个必要的数据：**协议号**和**协议类型**，将这两个数据分别存储起来\n\n- 当客户端向服务器发送数据时，会根据协议类型加上协议号，然后使用protobuf序列化之后再发送给服务器；\n- 当服务器发送数据给客户端时，根据协议号，用protobuf根据协议类型反序列化数据，并调用相应回调方法。\n\n由于数据在传输过程中，都是以数据流的形式存在的，而进行解析时无法单从protobuf数据中得知使用哪个解析类进行数据反序列化，这就要求我们在传输protobuf数据的同时，携带一个协议号，通过协议号和协议类型（解析类）之间的对应关系来确定进行数据反序列化的解析类。\n![](http://img.blog.csdn.net/20160824100320406)    \n此处协议号的作用就是用来确定用于解析数据的解析类，所以也可能称之为**协议类型名**，可以是``string``和``int``类型的数据。\n\n#### 2.特点分析：\n使用protobuf作为网络通信的数据载体，具有几个优点：\n\n- 通过序列化之后**数据量比较小**；\n- 而且**以key-value的方式存储数据**，这对于消息的版本兼容比较强；\n- 此外，由于protobuf提供的多语言支持，所以使用protobuf作为数据载体定制的网络协议**具有很强的跨语言特性**。\n\n### 四、样例实现：\n#### 1.协议定义：\n在之前导表的时候，我们得到了.proto的解析类，这是protobuf提供的一种特殊的脚本，具有格式简单、可读性强和方便拓展的特点，所以接下来我们就是**使用proto脚本来定义我们的协议**。例如：\n```C#\n// 物品  \nmessage Item  \n{  \n    required int32 Type     = 1;    //游戏物品大类  \n    optional int32 SubType  = 2;    //游戏物品小类  \n    required int32 num      = 3;    //游戏物品数量  \n}  \n  \n// 物品列表  \nmessage ItemList  \n{  \n    repeated Item item  = 1;    //物品列表  \n}  \n```\n上述例子中，Item相当于定义了一个数据结构或者是类，而ItemList是一个列表，列表中的每个元素都是一个Item对象。注意结构关键词：\n\n- ``required``：必有的属性\n- ``optional``：可选属性\n- ``repeated``：数组\n\n其实protobuf在这里只是提供了一个数据载体，通过在.proto中定义数据结构之后，需要使用与导表时一样的操作，步骤为：\n\n- 使用**protoc.exe**将.proto文件转化为.protodesc中间格式；\n- 使用**protogen.exe**将中间格式为.protodesc生成指定的高级语言类，我们在Unity中使用的是C#,所以结果是.cs类\n\n经过上述步骤之后，我们得到了协议类型对应的C#反序列化类，当我们收到服务器数据时，**根据协议号找到协议类型**，从而使用对应的反序列化的类对数据进行反序列化，得到最终的服务器数据内容。\n\n在这里，我们以登录为例，首先要清楚登录需要几个数据，正常情况下至少包含两个数据，即账号和密码，都是字符串类型，即定义cs_login.proto协议脚本，内容如下：\n```C#\npackage cs;  \n  \nmessage CSLoginInfo  \n{  \n    required string UserName = 1;//账号  \n    required string Password = 2;//密码  \n}  \n  \n//发送登录请求  \nmessage CSLoginReq  \n{  \n    required CSLoginInfo LoginInfo = 1;   \n}  \n//登录请求回包数据  \nmessage CSLoginRes  \n{  \n    required uint32 result_code = 1;   \n}  \n```\n``package``关键字后面的名称为.proto转为.cs之后的命名空间namespace的值，用message可以定义类，这里定义了一个CSLoginInfo的数据类，该类包含了账号和密码两个字符串类型的属性。然后定义了两个消息结构：\n\n- CSLoginReq登录请求消息，携带的数据是一个CSLoginInfo类型的对象数据；\n- CSLoginRes登录请求服务器返回的数据类型，返回结果是一个uint32无符号的整型数据，即结果码。\n\n上面定义的是协议类型，除此之外我们还需要为每一个协议类型定义一个协议号，这里可以用一个枚举脚本cs_enum.proto来保存，脚本内容为：\n```C#\npackage cs;  \n  \nenum EnmCmdID  \n{  \n    CS_LOGIN_REQ = 10001;//登录请求协议号  \n    CS_LOGIN_RES = 10002;//登录请求回包协议号  \n}  \n```\n使用protoc.exe和protogen.exe将这两个protobuf脚本得到C#类，具体步骤参考导表使用的操作，这里我直接给出自动化导表使用的批处理文件general_all.bat内容，具体文件目录可以根据自己放置情况进行调整：\n```bash\n::---------------------------------------------------  \n::第二步：把proto翻译成protodesc  \n::---------------------------------------------------  \ncall proto2cs\\protoc protos\\cs_login.proto --descriptor_set_out=cs_login.protodesc  \ncall proto2cs\\protoc protos\\cs_enum.proto --descriptor_set_out=cs_enum.protodesc  \n::---------------------------------------------------  \n::第二步：把protodesc翻译成cs  \n::---------------------------------------------------  \ncall proto2cs\\ProtoGen\\protogen -i:cs_login.protodesc -o:cs_login.cs  \ncall proto2cs\\ProtoGen\\protogen -i:cs_enum.protodesc -o:cs_enum.cs  \n::---------------------------------------------------  \n::第二步：把protodesc文件删除  \n::---------------------------------------------------  \ndel *.protodesc  \n  \npause  \n```\n转换结束后，我们的得到了两个.cs文件分别是：cs_enum.cs和cs_login.cs，将其放入到我们的Unity项目中，以便于接下来序列化和反序列化数据的使用。\n\n#### 2.协议数据构建：\n直接在项目代码中通过``using cs``引入协议解析类的命名空间，然后创建消息对象，并对对象的属性进行赋值，即可得到协议数据对象，例如登录请求对象的创建如下：\n```C#\nCSLoginInfo mLoginInfo = new CSLoginInfo();  \nmLoginInfo.UserName = \"linshuhe\";  \nmLoginInfo.Password = \"123456\";  \nCSLoginReq mReq = new CSLoginReq();  \nmReq.LoginInfo = mLoginInfo;  \n```\n从上述代码，可以得到登录请求对象mReq，里面包含了一个CSLoginInfo对象mLoginInfo，再次枚举对象中找到与此协议类型对应的协议号，即：``EnmCmdID.CS_LOGIN_REQ``\n\n#### 3.数据的序列化和反序列化：\n数据发送的时候必须以数据流的形式进行，所以这里我们需要考虑如何**将要发送的protobuf对象数据进行序列化，转化为byte[]字节数组**，这就需要借助ProtoBuf库为我们提供的``Serializer``类的``Serialize``方法来完成，而反序列化则需借助``Deserialize``方法，将这两个方法封装到PackCodec类中：\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing System.IO;  \nusing System;  \nusing ProtoBuf;  \n  \n/// <summary>  \n/// 网络协议数据打包和解包类  \n/// </summary>  \npublic class PackCodec{  \n    /// <summary>  \n    /// 序列化  \n    /// </summary>  \n    /// <typeparam name=\"T\"></typeparam>  \n    /// <param name=\"msg\"></param>  \n    /// <returns></returns>  \n    static public byte[] Serialize<T>(T msg)  \n    {  \n        byte[] result = null;  \n        if (msg != null)  \n        {  \n            using (var stream = new MemoryStream())  \n            {  \n                Serializer.Serialize<T>(stream, msg);  \n                result = stream.ToArray();  \n            }  \n        }  \n        return result;  \n    }  \n  \n    /// <summary>  \n    /// 反序列化  \n    /// </summary>  \n    /// <typeparam name=\"T\"></typeparam>  \n    /// <param name=\"message\"></param>  \n    /// <returns></returns>  \n    static public T Deserialize<T>(byte[] message)  \n    {  \n        T result = default(T);  \n        if (message != null)  \n        {  \n            using (var stream = new MemoryStream(message))  \n            {  \n                result = Serializer.Deserialize<T>(stream);  \n            }  \n        }  \n        return result;  \n    }  \n}  \n```\n使用方法很简单，直接传入一个数据对象即可得到字节数组：\n```C#\nbyte[] buf = PackCodec.Serialize(mReq);  \n```\n为了检验打包和解包是否匹配，我们可以直接做一次本地测试：将打包后的数据直接解包，看看数据是否与原来的一致：\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing System;  \nusing cs;  \nusing ProtoBuf;  \nusing System.IO;  \n  \npublic class TestProtoNet : MonoBehaviour {  \n  \n    // Use this for initialization  \n    void Start () {  \n        CSLoginInfo mLoginInfo = new CSLoginInfo();  \n        mLoginInfo.UserName = \"linshuhe\";  \n        mLoginInfo.Password = \"123456\";  \n        CSLoginReq mReq = new CSLoginReq();  \n        mReq.LoginInfo = mLoginInfo;  \n  \n        byte[] pbdata = PackCodec.Serialize(mReq);  \n        CSLoginReq pReq = PackCodec.Deserialize<CSLoginReq>(pbdata);  \n        Debug.Log(\"UserName = \" + pReq.LoginInfo.UserName + \", Password = \" + pReq.LoginInfo.Password);  \n    }  \n  \n    // Update is called once per frame  \n    void Update () {  \n      \n    }  \n} \n``` \n将此脚本绑到场景中的相机上，运行得到以下结果，则说明打包和解包完全匹配：\n![](http://img.blog.csdn.net/20160825100033496)    \n\n#### 4.数据发送和接收：\n这里我们使用的网络通信方式是Socket的强联网方式，关于如何在Unity中使用Socket进行通信，可以参考我之前的文章：[Unity —— Socket通信(C#)](http://blog.csdn.net/linshuhe1/article/details/51386559)，Unity客户端需要复制此项目的**ClientSocket.cs**和**ByteBuffer.cs**两个类到当前项目中。\n\n此外，服务器可以参照之前的方式搭建，唯一不同的是RecieveMessage(object clientSocket)方法解析数据的过程需要进行修改，因为需要使用protobuf-net.dll进行数据解包，所以需要参考客户端的做法，把protobuf-net.dll复制到服务器项目中的Protobuf_net目录下：  \n![](http://img.blog.csdn.net/20160825175754877)\n假如由于直接使用源码而不用.dll会出现不安全保存，需要在Visual Studio中设置允许不安全代码，具体步骤为：在“解决方案”中选中工程，右键“数据”，选择“生成”页签，勾选“允许不安全代码”：\n![](http://img.blog.csdn.net/20160825180841975)    \n当然，解析数据所用的解析类和协议号两个脚本cs_login.cs和cs_enum.cs也应该添加到服务器项目中，保证客户端和服务器一直，此外PackCodec.cs也需要添加到服务器代码中但是要把其中的using UnityEngine给去掉防止报错，最终服务器目录结构如下：\n![](http://img.blog.csdn.net/20160825191847662)\n\n#### 5.完整协议数据的封装：\n从之前说过的设计思路分析，我们在发送数据的时候除了要发送关键的protobuf数据之外，还需要带上两个附件的数据：协议头（用于进行通信检验）和协议号（用于确定解析类）。假设我们的是：\n\n- **协议头**：用于表示后面数据的长度，一个short类型的数据：\n```C#\n/// <summary>  \n/// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  \n/// </summary>  \n/// <param name=\"message\"></param>  \n/// <returns></returns>  \nprivate static byte[] WriteMessage(byte[] message)  \n{  \n    MemoryStream ms = null;  \n    using (ms = new MemoryStream())  \n    {  \n        ms.Position = 0;  \n        BinaryWriter writer = new BinaryWriter(ms);  \n        ushort msglen = (ushort)message.Length;  \n        writer.Write(msglen);  \n        writer.Write(message);  \n        writer.Flush();  \n        return ms.ToArray();  \n    }  \n}  \n```\n- **协议号**：用于对应解析类，这里我们使用的是int类型的数据：\n\n```C#\nprivate byte[] CreateData(int typeId,IExtensible pbuf)  \n  \nbyte[] pbdata = PackCodec.Serialize(pbuf);  \nByteBuffer buff = new ByteBuffer();  \nbuff.WriteInt(typeId);  \nbuff.WriteBytes(pbdata);  \nreturn buff.ToBytes();  \n```\n\n客户端发送登录数据时测试脚本TestProtoNet如下，测试需要将此脚本绑定到当前场景的相机上：\n\n```C#\nusing UnityEngine;  \nusing System.Collections;  \nusing System;  \nusing cs;  \nusing Net;  \nusing ProtoBuf;  \nusing System.IO;  \n  \npublic class TestProtoNet : MonoBehaviour {  \n  \n    // Use this for initialization  \n    void Start () {  \n  \n  \n        CSLoginInfo mLoginInfo = new CSLoginInfo();  \n        mLoginInfo.UserName = \"linshuhe\";  \n        mLoginInfo.Password = \"123456\";  \n        CSLoginReq mReq = new CSLoginReq();  \n        mReq.LoginInfo = mLoginInfo;  \n  \n        byte[] data = CreateData((int)EnmCmdID.CS_LOGIN_REQ, mReq);  \n        ClientSocket mSocket = new ClientSocket();  \n        mSocket.ConnectServer(\"127.0.0.1\", 8088);  \n        mSocket.SendMessage(data);  \n    }  \n  \n    private byte[] CreateData(int typeId,IExtensible pbuf)  \n    {  \n        byte[] pbdata = PackCodec.Serialize(pbuf);  \n        ByteBuffer buff = new ByteBuffer();  \n        buff.WriteInt(typeId);  \n        buff.WriteBytes(pbdata);  \n        return WriteMessage(buff.ToBytes());  \n    }  \n  \n    /// <summary>  \n    /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  \n    /// </summary>  \n    /// <param name=\"message\"></param>  \n    /// <returns></returns>  \n    private static byte[] WriteMessage(byte[] message)  \n    {  \n        MemoryStream ms = null;  \n        using (ms = new MemoryStream())  \n        {  \n            ms.Position = 0;  \n            BinaryWriter writer = new BinaryWriter(ms);  \n            ushort msglen = (ushort)message.Length;  \n            writer.Write(msglen);  \n            writer.Write(message);  \n            writer.Flush();  \n            return ms.ToArray();  \n        }  \n    }  \n  \n    // Update is called once per frame  \n    void Update () {  \n      \n    }  \n} \n``` \n\n服务器接受数据解包过程参考打包数据的格式，在RecieveMessage(object clientSocket)中，解析数据的核心代码如下：\n\n```C#\nByteBuffer buff = new ByteBuffer(result);  \nint datalength = buff.ReadShort();  \nint typeId = buff.ReadInt();  \nbyte[] pbdata = buff.ReadBytes();  \n//通过协议号判断选择的解析类  \nif(typeId == (int)EnmCmdID.CS_LOGIN_REQ)  \n{  \n        CSLoginReq clientReq = PackCodec.Deserialize<CSLoginReq>(pbdata);  \n        string user_name = clientReq.LoginInfo.UserName;  \n        string pass_word = clientReq.LoginInfo.Password;  \n        Console.WriteLine(\"数据内容：UserName={0},Password={1}\", user_name, pass_word);  \n        }  \n}  \n```\n上面通过typeId来找到匹配的数据解析类，协议少的时候可以使用这种简单的使用if语句分支判断来实现，但是假如协议类型多了，则需要进一步封装查找方法，常用的方法有：定义一个Dictionary<int,Type>字典来存放协议号（int）和协议类型（Type）的对应关系。\n\n#### 6.运行结果：\n启动服务器，然后运行Unity中的客户端，得到正确的结果应该如下：\n![](http://img.blog.csdn.net/20160825192659728)\n项目服务器和客户端的完整代码可以前往此处下载：[protobuf-net网络协议的定制](http://download.csdn.net/detail/linshuhe1/9613076)","slug":"Unity3D-protobuf网络框架","published":1,"updated":"2017-06-24T02:13:49.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfkz00199gfjiquqy0t8","content":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>protobuf是google的一个开源项目，主要的用途是：</p>\n<ul>\n<li>数据存储（序列化和反序列化），这个功能类似xml和json等；</li>\n<li>制作网络通信协议；</li>\n</ul>\n<h3 id=\"一、资源下载：\"><a href=\"#一、资源下载：\" class=\"headerlink\" title=\"一、资源下载：\"></a>一、资源下载：</h3><ul>\n<li>github源码地址：<a href=\"https://github.com/mgravell/protobuf-net\" target=\"_blank\" rel=\"external\">protobuf-net</a></li>\n<li>google项目源码下载地址（<strong>访问需翻墙</strong>）：<a href=\"https://code.google.com/p/protobuf-net/\" target=\"_blank\" rel=\"external\">protobuf-net</a></li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"二、数据存储：\"><a href=\"#二、数据存储：\" class=\"headerlink\" title=\"二、数据存储：\"></a>二、数据存储：</h3><p>C#语言方式的导表和解析过程，在之前的篇章中已经有详细的阐述：<a href=\"http://blog.csdn.net/linshuhe1/article/details/52062969\" target=\"_blank\" rel=\"external\">Unity —— protobuf 导excel表格数据</a>，建议在看后续的操作之前先看一下这篇文档，因为后面设计到得一些操作与导表中是一致的，而且在理解了导表过程之后，能够快速地理解协议数据<strong>序列化</strong>和<strong>反序列化</strong>的过程。</p>\n<h3 id=\"三、网络协议：\"><a href=\"#三、网络协议：\" class=\"headerlink\" title=\"三、网络协议：\"></a>三、网络协议：</h3><h4 id=\"1-设计思想：\"><a href=\"#1-设计思想：\" class=\"headerlink\" title=\"1.设计思想：\"></a>1.设计思想：</h4><p>有两个必要的数据：<strong>协议号</strong>和<strong>协议类型</strong>，将这两个数据分别存储起来</p>\n<ul>\n<li>当客户端向服务器发送数据时，会根据协议类型加上协议号，然后使用protobuf序列化之后再发送给服务器；</li>\n<li>当服务器发送数据给客户端时，根据协议号，用protobuf根据协议类型反序列化数据，并调用相应回调方法。</li>\n</ul>\n<p>由于数据在传输过程中，都是以数据流的形式存在的，而进行解析时无法单从protobuf数据中得知使用哪个解析类进行数据反序列化，这就要求我们在传输protobuf数据的同时，携带一个协议号，通过协议号和协议类型（解析类）之间的对应关系来确定进行数据反序列化的解析类。<br><img src=\"http://img.blog.csdn.net/20160824100320406\" alt=\"\"><br>此处协议号的作用就是用来确定用于解析数据的解析类，所以也可能称之为<strong>协议类型名</strong>，可以是<code>string</code>和<code>int</code>类型的数据。</p>\n<h4 id=\"2-特点分析：\"><a href=\"#2-特点分析：\" class=\"headerlink\" title=\"2.特点分析：\"></a>2.特点分析：</h4><p>使用protobuf作为网络通信的数据载体，具有几个优点：</p>\n<ul>\n<li>通过序列化之后<strong>数据量比较小</strong>；</li>\n<li>而且<strong>以key-value的方式存储数据</strong>，这对于消息的版本兼容比较强；</li>\n<li>此外，由于protobuf提供的多语言支持，所以使用protobuf作为数据载体定制的网络协议<strong>具有很强的跨语言特性</strong>。</li>\n</ul>\n<h3 id=\"四、样例实现：\"><a href=\"#四、样例实现：\" class=\"headerlink\" title=\"四、样例实现：\"></a>四、样例实现：</h3><h4 id=\"1-协议定义：\"><a href=\"#1-协议定义：\" class=\"headerlink\" title=\"1.协议定义：\"></a>1.协议定义：</h4><p>在之前导表的时候，我们得到了.proto的解析类，这是protobuf提供的一种特殊的脚本，具有格式简单、可读性强和方便拓展的特点，所以接下来我们就是<strong>使用proto脚本来定义我们的协议</strong>。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 物品  </div><div class=\"line\">message Item  </div><div class=\"line\">&#123;  </div><div class=\"line\">    required int32 Type     = 1;    //游戏物品大类  </div><div class=\"line\">    optional int32 SubType  = 2;    //游戏物品小类  </div><div class=\"line\">    required int32 num      = 3;    //游戏物品数量  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">// 物品列表  </div><div class=\"line\">message ItemList  </div><div class=\"line\">&#123;  </div><div class=\"line\">    repeated Item item  = 1;    //物品列表  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上述例子中，Item相当于定义了一个数据结构或者是类，而ItemList是一个列表，列表中的每个元素都是一个Item对象。注意结构关键词：</p>\n<ul>\n<li><code>required</code>：必有的属性</li>\n<li><code>optional</code>：可选属性</li>\n<li><code>repeated</code>：数组</li>\n</ul>\n<p>其实protobuf在这里只是提供了一个数据载体，通过在.proto中定义数据结构之后，需要使用与导表时一样的操作，步骤为：</p>\n<ul>\n<li>使用<strong>protoc.exe</strong>将.proto文件转化为.protodesc中间格式；</li>\n<li>使用<strong>protogen.exe</strong>将中间格式为.protodesc生成指定的高级语言类，我们在Unity中使用的是C#,所以结果是.cs类</li>\n</ul>\n<p>经过上述步骤之后，我们得到了协议类型对应的C#反序列化类，当我们收到服务器数据时，<strong>根据协议号找到协议类型</strong>，从而使用对应的反序列化的类对数据进行反序列化，得到最终的服务器数据内容。</p>\n<p>在这里，我们以登录为例，首先要清楚登录需要几个数据，正常情况下至少包含两个数据，即账号和密码，都是字符串类型，即定义cs_login.proto协议脚本，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">package cs;  </div><div class=\"line\">  </div><div class=\"line\">message CSLoginInfo  </div><div class=\"line\">&#123;  </div><div class=\"line\">    required string UserName = 1;//账号  </div><div class=\"line\">    required string Password = 2;//密码  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">//发送登录请求  </div><div class=\"line\">message CSLoginReq  </div><div class=\"line\">&#123;  </div><div class=\"line\">    required CSLoginInfo LoginInfo = 1;   </div><div class=\"line\">&#125;  </div><div class=\"line\">//登录请求回包数据  </div><div class=\"line\">message CSLoginRes  </div><div class=\"line\">&#123;  </div><div class=\"line\">    required uint32 result_code = 1;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>package</code>关键字后面的名称为.proto转为.cs之后的命名空间namespace的值，用message可以定义类，这里定义了一个CSLoginInfo的数据类，该类包含了账号和密码两个字符串类型的属性。然后定义了两个消息结构：</p>\n<ul>\n<li>CSLoginReq登录请求消息，携带的数据是一个CSLoginInfo类型的对象数据；</li>\n<li>CSLoginRes登录请求服务器返回的数据类型，返回结果是一个uint32无符号的整型数据，即结果码。</li>\n</ul>\n<p>上面定义的是协议类型，除此之外我们还需要为每一个协议类型定义一个协议号，这里可以用一个枚举脚本cs_enum.proto来保存，脚本内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">package cs;  </div><div class=\"line\">  </div><div class=\"line\">enum EnmCmdID  </div><div class=\"line\">&#123;  </div><div class=\"line\">    CS_LOGIN_REQ = 10001;//登录请求协议号  </div><div class=\"line\">    CS_LOGIN_RES = 10002;//登录请求回包协议号  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用protoc.exe和protogen.exe将这两个protobuf脚本得到C#类，具体步骤参考导表使用的操作，这里我直接给出自动化导表使用的批处理文件general_all.bat内容，具体文件目录可以根据自己放置情况进行调整：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">::第二步：把proto翻译成protodesc  </div><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">call proto2cs\\protoc protos\\cs_login.proto --descriptor_set_out=cs_login.protodesc  </div><div class=\"line\">call proto2cs\\protoc protos\\cs_enum.proto --descriptor_set_out=cs_enum.protodesc  </div><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">::第二步：把protodesc翻译成cs  </div><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">call proto2cs\\ProtoGen\\protogen -i:cs_login.protodesc -o:cs_login.cs  </div><div class=\"line\">call proto2cs\\ProtoGen\\protogen -i:cs_enum.protodesc -o:cs_enum.cs  </div><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">::第二步：把protodesc文件删除  </div><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">del *.protodesc  </div><div class=\"line\">  </div><div class=\"line\">pause</div></pre></td></tr></table></figure></p>\n<p>转换结束后，我们的得到了两个.cs文件分别是：cs_enum.cs和cs_login.cs，将其放入到我们的Unity项目中，以便于接下来序列化和反序列化数据的使用。</p>\n<h4 id=\"2-协议数据构建：\"><a href=\"#2-协议数据构建：\" class=\"headerlink\" title=\"2.协议数据构建：\"></a>2.协议数据构建：</h4><p>直接在项目代码中通过<code>using cs</code>引入协议解析类的命名空间，然后创建消息对象，并对对象的属性进行赋值，即可得到协议数据对象，例如登录请求对象的创建如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">CSLoginInfo mLoginInfo = new CSLoginInfo();  </div><div class=\"line\">mLoginInfo.UserName = &quot;linshuhe&quot;;  </div><div class=\"line\">mLoginInfo.Password = &quot;123456&quot;;  </div><div class=\"line\">CSLoginReq mReq = new CSLoginReq();  </div><div class=\"line\">mReq.LoginInfo = mLoginInfo;</div></pre></td></tr></table></figure></p>\n<p>从上述代码，可以得到登录请求对象mReq，里面包含了一个CSLoginInfo对象mLoginInfo，再次枚举对象中找到与此协议类型对应的协议号，即：<code>EnmCmdID.CS_LOGIN_REQ</code></p>\n<h4 id=\"3-数据的序列化和反序列化：\"><a href=\"#3-数据的序列化和反序列化：\" class=\"headerlink\" title=\"3.数据的序列化和反序列化：\"></a>3.数据的序列化和反序列化：</h4><p>数据发送的时候必须以数据流的形式进行，所以这里我们需要考虑如何<strong>将要发送的protobuf对象数据进行序列化，转化为byte[]字节数组</strong>，这就需要借助ProtoBuf库为我们提供的<code>Serializer</code>类的<code>Serialize</code>方法来完成，而反序列化则需借助<code>Deserialize</code>方法，将这两个方法封装到PackCodec类中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">using System;  </div><div class=\"line\">using ProtoBuf;  </div><div class=\"line\">  </div><div class=\"line\">/// &lt;summary&gt;  </div><div class=\"line\">/// 网络协议数据打包和解包类  </div><div class=\"line\">/// &lt;/summary&gt;  </div><div class=\"line\">public class PackCodec&#123;  </div><div class=\"line\">    /// &lt;summary&gt;  </div><div class=\"line\">    /// 序列化  </div><div class=\"line\">    /// &lt;/summary&gt;  </div><div class=\"line\">    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;  </div><div class=\"line\">    /// &lt;param name=&quot;msg&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">    /// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">    static public byte[] Serialize&lt;T&gt;(T msg)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        byte[] result = null;  </div><div class=\"line\">        if (msg != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            using (var stream = new MemoryStream())  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                Serializer.Serialize&lt;T&gt;(stream, msg);  </div><div class=\"line\">                result = stream.ToArray();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        return result;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    /// &lt;summary&gt;  </div><div class=\"line\">    /// 反序列化  </div><div class=\"line\">    /// &lt;/summary&gt;  </div><div class=\"line\">    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;  </div><div class=\"line\">    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">    /// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">    static public T Deserialize&lt;T&gt;(byte[] message)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        T result = default(T);  </div><div class=\"line\">        if (message != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            using (var stream = new MemoryStream(message))  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                result = Serializer.Deserialize&lt;T&gt;(stream);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        return result;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用方法很简单，直接传入一个数据对象即可得到字节数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">byte[] buf = PackCodec.Serialize(mReq);</div></pre></td></tr></table></figure></p>\n<p>为了检验打包和解包是否匹配，我们可以直接做一次本地测试：将打包后的数据直接解包，看看数据是否与原来的一致：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using System;  </div><div class=\"line\">using cs;  </div><div class=\"line\">using ProtoBuf;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">  </div><div class=\"line\">public class TestProtoNet : MonoBehaviour &#123;  </div><div class=\"line\">  </div><div class=\"line\">    // Use this for initialization  </div><div class=\"line\">    void Start () &#123;  </div><div class=\"line\">        CSLoginInfo mLoginInfo = new CSLoginInfo();  </div><div class=\"line\">        mLoginInfo.UserName = &quot;linshuhe&quot;;  </div><div class=\"line\">        mLoginInfo.Password = &quot;123456&quot;;  </div><div class=\"line\">        CSLoginReq mReq = new CSLoginReq();  </div><div class=\"line\">        mReq.LoginInfo = mLoginInfo;  </div><div class=\"line\">  </div><div class=\"line\">        byte[] pbdata = PackCodec.Serialize(mReq);  </div><div class=\"line\">        CSLoginReq pReq = PackCodec.Deserialize&lt;CSLoginReq&gt;(pbdata);  </div><div class=\"line\">        Debug.Log(&quot;UserName = &quot; + pReq.LoginInfo.UserName + &quot;, Password = &quot; + pReq.LoginInfo.Password);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    // Update is called once per frame  </div><div class=\"line\">    void Update () &#123;  </div><div class=\"line\">      </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125; </div><div class=\"line\">``` </div><div class=\"line\">将此脚本绑到场景中的相机上，运行得到以下结果，则说明打包和解包完全匹配：</div><div class=\"line\">![](http://img.blog.csdn.net/20160825100033496)    </div><div class=\"line\"></div><div class=\"line\">#### 4.数据发送和接收：</div><div class=\"line\">这里我们使用的网络通信方式是Socket的强联网方式，关于如何在Unity中使用Socket进行通信，可以参考我之前的文章：[Unity —— Socket通信(C#)](http://blog.csdn.net/linshuhe1/article/details/51386559)，Unity客户端需要复制此项目的**ClientSocket.cs**和**ByteBuffer.cs**两个类到当前项目中。</div><div class=\"line\"></div><div class=\"line\">此外，服务器可以参照之前的方式搭建，唯一不同的是RecieveMessage(object clientSocket)方法解析数据的过程需要进行修改，因为需要使用protobuf-net.dll进行数据解包，所以需要参考客户端的做法，把protobuf-net.dll复制到服务器项目中的Protobuf_net目录下：  </div><div class=\"line\">![](http://img.blog.csdn.net/20160825175754877)</div><div class=\"line\">假如由于直接使用源码而不用.dll会出现不安全保存，需要在Visual Studio中设置允许不安全代码，具体步骤为：在“解决方案”中选中工程，右键“数据”，选择“生成”页签，勾选“允许不安全代码”：</div><div class=\"line\">![](http://img.blog.csdn.net/20160825180841975)    </div><div class=\"line\">当然，解析数据所用的解析类和协议号两个脚本cs_login.cs和cs_enum.cs也应该添加到服务器项目中，保证客户端和服务器一直，此外PackCodec.cs也需要添加到服务器代码中但是要把其中的using UnityEngine给去掉防止报错，最终服务器目录结构如下：</div><div class=\"line\">![](http://img.blog.csdn.net/20160825191847662)</div><div class=\"line\"></div><div class=\"line\">#### 5.完整协议数据的封装：</div><div class=\"line\">从之前说过的设计思路分析，我们在发送数据的时候除了要发送关键的protobuf数据之外，还需要带上两个附件的数据：协议头（用于进行通信检验）和协议号（用于确定解析类）。假设我们的是：</div><div class=\"line\"></div><div class=\"line\">- **协议头**：用于表示后面数据的长度，一个short类型的数据：</div><div class=\"line\">```C#</div><div class=\"line\">/// &lt;summary&gt;  </div><div class=\"line\">/// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class=\"line\">/// &lt;/summary&gt;  </div><div class=\"line\">/// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">/// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">private static byte[] WriteMessage(byte[] message)  </div><div class=\"line\">&#123;  </div><div class=\"line\">    MemoryStream ms = null;  </div><div class=\"line\">    using (ms = new MemoryStream())  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        ms.Position = 0;  </div><div class=\"line\">        BinaryWriter writer = new BinaryWriter(ms);  </div><div class=\"line\">        ushort msglen = (ushort)message.Length;  </div><div class=\"line\">        writer.Write(msglen);  </div><div class=\"line\">        writer.Write(message);  </div><div class=\"line\">        writer.Flush();  </div><div class=\"line\">        return ms.ToArray();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>协议号</strong>：用于对应解析类，这里我们使用的是int类型的数据：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private byte[] CreateData(int typeId,IExtensible pbuf)  </div><div class=\"line\">  </div><div class=\"line\">byte[] pbdata = PackCodec.Serialize(pbuf);  </div><div class=\"line\">ByteBuffer buff = new ByteBuffer();  </div><div class=\"line\">buff.WriteInt(typeId);  </div><div class=\"line\">buff.WriteBytes(pbdata);  </div><div class=\"line\">return buff.ToBytes();</div></pre></td></tr></table></figure>\n<p>客户端发送登录数据时测试脚本TestProtoNet如下，测试需要将此脚本绑定到当前场景的相机上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using System;  </div><div class=\"line\">using cs;  </div><div class=\"line\">using Net;  </div><div class=\"line\">using ProtoBuf;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">  </div><div class=\"line\">public class TestProtoNet : MonoBehaviour &#123;  </div><div class=\"line\">  </div><div class=\"line\">    // Use this for initialization  </div><div class=\"line\">    void Start () &#123;  </div><div class=\"line\">  </div><div class=\"line\">  </div><div class=\"line\">        CSLoginInfo mLoginInfo = new CSLoginInfo();  </div><div class=\"line\">        mLoginInfo.UserName = &quot;linshuhe&quot;;  </div><div class=\"line\">        mLoginInfo.Password = &quot;123456&quot;;  </div><div class=\"line\">        CSLoginReq mReq = new CSLoginReq();  </div><div class=\"line\">        mReq.LoginInfo = mLoginInfo;  </div><div class=\"line\">  </div><div class=\"line\">        byte[] data = CreateData((int)EnmCmdID.CS_LOGIN_REQ, mReq);  </div><div class=\"line\">        ClientSocket mSocket = new ClientSocket();  </div><div class=\"line\">        mSocket.ConnectServer(&quot;127.0.0.1&quot;, 8088);  </div><div class=\"line\">        mSocket.SendMessage(data);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    private byte[] CreateData(int typeId,IExtensible pbuf)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        byte[] pbdata = PackCodec.Serialize(pbuf);  </div><div class=\"line\">        ByteBuffer buff = new ByteBuffer();  </div><div class=\"line\">        buff.WriteInt(typeId);  </div><div class=\"line\">        buff.WriteBytes(pbdata);  </div><div class=\"line\">        return WriteMessage(buff.ToBytes());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    /// &lt;summary&gt;  </div><div class=\"line\">    /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class=\"line\">    /// &lt;/summary&gt;  </div><div class=\"line\">    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">    /// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">    private static byte[] WriteMessage(byte[] message)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        MemoryStream ms = null;  </div><div class=\"line\">        using (ms = new MemoryStream())  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            ms.Position = 0;  </div><div class=\"line\">            BinaryWriter writer = new BinaryWriter(ms);  </div><div class=\"line\">            ushort msglen = (ushort)message.Length;  </div><div class=\"line\">            writer.Write(msglen);  </div><div class=\"line\">            writer.Write(message);  </div><div class=\"line\">            writer.Flush();  </div><div class=\"line\">            return ms.ToArray();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    // Update is called once per frame  </div><div class=\"line\">    void Update () &#123;  </div><div class=\"line\">      </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125; </div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">服务器接受数据解包过程参考打包数据的格式，在RecieveMessage(object clientSocket)中，解析数据的核心代码如下：</div><div class=\"line\"></div><div class=\"line\">```C#</div><div class=\"line\">ByteBuffer buff = new ByteBuffer(result);  </div><div class=\"line\">int datalength = buff.ReadShort();  </div><div class=\"line\">int typeId = buff.ReadInt();  </div><div class=\"line\">byte[] pbdata = buff.ReadBytes();  </div><div class=\"line\">//通过协议号判断选择的解析类  </div><div class=\"line\">if(typeId == (int)EnmCmdID.CS_LOGIN_REQ)  </div><div class=\"line\">&#123;  </div><div class=\"line\">        CSLoginReq clientReq = PackCodec.Deserialize&lt;CSLoginReq&gt;(pbdata);  </div><div class=\"line\">        string user_name = clientReq.LoginInfo.UserName;  </div><div class=\"line\">        string pass_word = clientReq.LoginInfo.Password;  </div><div class=\"line\">        Console.WriteLine(&quot;数据内容：UserName=&#123;0&#125;,Password=&#123;1&#125;&quot;, user_name, pass_word);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面通过typeId来找到匹配的数据解析类，协议少的时候可以使用这种简单的使用if语句分支判断来实现，但是假如协议类型多了，则需要进一步封装查找方法，常用的方法有：定义一个Dictionary<int,type>字典来存放协议号（int）和协议类型（Type）的对应关系。</int,type></p>\n<h4 id=\"6-运行结果：\"><a href=\"#6-运行结果：\" class=\"headerlink\" title=\"6.运行结果：\"></a>6.运行结果：</h4><p>启动服务器，然后运行Unity中的客户端，得到正确的结果应该如下：<br><img src=\"http://img.blog.csdn.net/20160825192659728\" alt=\"\"><br>项目服务器和客户端的完整代码可以前往此处下载：<a href=\"http://download.csdn.net/detail/linshuhe1/9613076\" target=\"_blank\" rel=\"external\">protobuf-net网络协议的定制</a></p>\n","excerpt":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>protobuf是google的一个开源项目，主要的用途是：</p>\n<ul>\n<li>数据存储（序列化和反序列化），这个功能类似xml和json等；</li>\n<li>制作网络通信协议；</li>\n</ul>\n<h3 id=\"一、资源下载：\"><a href=\"#一、资源下载：\" class=\"headerlink\" title=\"一、资源下载：\"></a>一、资源下载：</h3><ul>\n<li>github源码地址：<a href=\"https://github.com/mgravell/protobuf-net\">protobuf-net</a></li>\n<li>google项目源码下载地址（<strong>访问需翻墙</strong>）：<a href=\"https://code.google.com/p/protobuf-net/\">protobuf-net</a></li>\n</ul>","more":"<h3 id=\"二、数据存储：\"><a href=\"#二、数据存储：\" class=\"headerlink\" title=\"二、数据存储：\"></a>二、数据存储：</h3><p>C#语言方式的导表和解析过程，在之前的篇章中已经有详细的阐述：<a href=\"http://blog.csdn.net/linshuhe1/article/details/52062969\">Unity —— protobuf 导excel表格数据</a>，建议在看后续的操作之前先看一下这篇文档，因为后面设计到得一些操作与导表中是一致的，而且在理解了导表过程之后，能够快速地理解协议数据<strong>序列化</strong>和<strong>反序列化</strong>的过程。</p>\n<h3 id=\"三、网络协议：\"><a href=\"#三、网络协议：\" class=\"headerlink\" title=\"三、网络协议：\"></a>三、网络协议：</h3><h4 id=\"1-设计思想：\"><a href=\"#1-设计思想：\" class=\"headerlink\" title=\"1.设计思想：\"></a>1.设计思想：</h4><p>有两个必要的数据：<strong>协议号</strong>和<strong>协议类型</strong>，将这两个数据分别存储起来</p>\n<ul>\n<li>当客户端向服务器发送数据时，会根据协议类型加上协议号，然后使用protobuf序列化之后再发送给服务器；</li>\n<li>当服务器发送数据给客户端时，根据协议号，用protobuf根据协议类型反序列化数据，并调用相应回调方法。</li>\n</ul>\n<p>由于数据在传输过程中，都是以数据流的形式存在的，而进行解析时无法单从protobuf数据中得知使用哪个解析类进行数据反序列化，这就要求我们在传输protobuf数据的同时，携带一个协议号，通过协议号和协议类型（解析类）之间的对应关系来确定进行数据反序列化的解析类。<br><img src=\"http://img.blog.csdn.net/20160824100320406\" alt=\"\"><br>此处协议号的作用就是用来确定用于解析数据的解析类，所以也可能称之为<strong>协议类型名</strong>，可以是<code>string</code>和<code>int</code>类型的数据。</p>\n<h4 id=\"2-特点分析：\"><a href=\"#2-特点分析：\" class=\"headerlink\" title=\"2.特点分析：\"></a>2.特点分析：</h4><p>使用protobuf作为网络通信的数据载体，具有几个优点：</p>\n<ul>\n<li>通过序列化之后<strong>数据量比较小</strong>；</li>\n<li>而且<strong>以key-value的方式存储数据</strong>，这对于消息的版本兼容比较强；</li>\n<li>此外，由于protobuf提供的多语言支持，所以使用protobuf作为数据载体定制的网络协议<strong>具有很强的跨语言特性</strong>。</li>\n</ul>\n<h3 id=\"四、样例实现：\"><a href=\"#四、样例实现：\" class=\"headerlink\" title=\"四、样例实现：\"></a>四、样例实现：</h3><h4 id=\"1-协议定义：\"><a href=\"#1-协议定义：\" class=\"headerlink\" title=\"1.协议定义：\"></a>1.协议定义：</h4><p>在之前导表的时候，我们得到了.proto的解析类，这是protobuf提供的一种特殊的脚本，具有格式简单、可读性强和方便拓展的特点，所以接下来我们就是<strong>使用proto脚本来定义我们的协议</strong>。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 物品  </div><div class=\"line\">message Item  </div><div class=\"line\">&#123;  </div><div class=\"line\">    required int32 Type     = 1;    //游戏物品大类  </div><div class=\"line\">    optional int32 SubType  = 2;    //游戏物品小类  </div><div class=\"line\">    required int32 num      = 3;    //游戏物品数量  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">// 物品列表  </div><div class=\"line\">message ItemList  </div><div class=\"line\">&#123;  </div><div class=\"line\">    repeated Item item  = 1;    //物品列表  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上述例子中，Item相当于定义了一个数据结构或者是类，而ItemList是一个列表，列表中的每个元素都是一个Item对象。注意结构关键词：</p>\n<ul>\n<li><code>required</code>：必有的属性</li>\n<li><code>optional</code>：可选属性</li>\n<li><code>repeated</code>：数组</li>\n</ul>\n<p>其实protobuf在这里只是提供了一个数据载体，通过在.proto中定义数据结构之后，需要使用与导表时一样的操作，步骤为：</p>\n<ul>\n<li>使用<strong>protoc.exe</strong>将.proto文件转化为.protodesc中间格式；</li>\n<li>使用<strong>protogen.exe</strong>将中间格式为.protodesc生成指定的高级语言类，我们在Unity中使用的是C#,所以结果是.cs类</li>\n</ul>\n<p>经过上述步骤之后，我们得到了协议类型对应的C#反序列化类，当我们收到服务器数据时，<strong>根据协议号找到协议类型</strong>，从而使用对应的反序列化的类对数据进行反序列化，得到最终的服务器数据内容。</p>\n<p>在这里，我们以登录为例，首先要清楚登录需要几个数据，正常情况下至少包含两个数据，即账号和密码，都是字符串类型，即定义cs_login.proto协议脚本，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">package cs;  </div><div class=\"line\">  </div><div class=\"line\">message CSLoginInfo  </div><div class=\"line\">&#123;  </div><div class=\"line\">    required string UserName = 1;//账号  </div><div class=\"line\">    required string Password = 2;//密码  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">//发送登录请求  </div><div class=\"line\">message CSLoginReq  </div><div class=\"line\">&#123;  </div><div class=\"line\">    required CSLoginInfo LoginInfo = 1;   </div><div class=\"line\">&#125;  </div><div class=\"line\">//登录请求回包数据  </div><div class=\"line\">message CSLoginRes  </div><div class=\"line\">&#123;  </div><div class=\"line\">    required uint32 result_code = 1;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>package</code>关键字后面的名称为.proto转为.cs之后的命名空间namespace的值，用message可以定义类，这里定义了一个CSLoginInfo的数据类，该类包含了账号和密码两个字符串类型的属性。然后定义了两个消息结构：</p>\n<ul>\n<li>CSLoginReq登录请求消息，携带的数据是一个CSLoginInfo类型的对象数据；</li>\n<li>CSLoginRes登录请求服务器返回的数据类型，返回结果是一个uint32无符号的整型数据，即结果码。</li>\n</ul>\n<p>上面定义的是协议类型，除此之外我们还需要为每一个协议类型定义一个协议号，这里可以用一个枚举脚本cs_enum.proto来保存，脚本内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">package cs;  </div><div class=\"line\">  </div><div class=\"line\">enum EnmCmdID  </div><div class=\"line\">&#123;  </div><div class=\"line\">    CS_LOGIN_REQ = 10001;//登录请求协议号  </div><div class=\"line\">    CS_LOGIN_RES = 10002;//登录请求回包协议号  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用protoc.exe和protogen.exe将这两个protobuf脚本得到C#类，具体步骤参考导表使用的操作，这里我直接给出自动化导表使用的批处理文件general_all.bat内容，具体文件目录可以根据自己放置情况进行调整：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">::第二步：把proto翻译成protodesc  </div><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">call proto2cs\\protoc protos\\cs_login.proto --descriptor_set_out=cs_login.protodesc  </div><div class=\"line\">call proto2cs\\protoc protos\\cs_enum.proto --descriptor_set_out=cs_enum.protodesc  </div><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">::第二步：把protodesc翻译成cs  </div><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">call proto2cs\\ProtoGen\\protogen -i:cs_login.protodesc -o:cs_login.cs  </div><div class=\"line\">call proto2cs\\ProtoGen\\protogen -i:cs_enum.protodesc -o:cs_enum.cs  </div><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">::第二步：把protodesc文件删除  </div><div class=\"line\">::---------------------------------------------------  </div><div class=\"line\">del *.protodesc  </div><div class=\"line\">  </div><div class=\"line\">pause</div></pre></td></tr></table></figure></p>\n<p>转换结束后，我们的得到了两个.cs文件分别是：cs_enum.cs和cs_login.cs，将其放入到我们的Unity项目中，以便于接下来序列化和反序列化数据的使用。</p>\n<h4 id=\"2-协议数据构建：\"><a href=\"#2-协议数据构建：\" class=\"headerlink\" title=\"2.协议数据构建：\"></a>2.协议数据构建：</h4><p>直接在项目代码中通过<code>using cs</code>引入协议解析类的命名空间，然后创建消息对象，并对对象的属性进行赋值，即可得到协议数据对象，例如登录请求对象的创建如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">CSLoginInfo mLoginInfo = new CSLoginInfo();  </div><div class=\"line\">mLoginInfo.UserName = &quot;linshuhe&quot;;  </div><div class=\"line\">mLoginInfo.Password = &quot;123456&quot;;  </div><div class=\"line\">CSLoginReq mReq = new CSLoginReq();  </div><div class=\"line\">mReq.LoginInfo = mLoginInfo;</div></pre></td></tr></table></figure></p>\n<p>从上述代码，可以得到登录请求对象mReq，里面包含了一个CSLoginInfo对象mLoginInfo，再次枚举对象中找到与此协议类型对应的协议号，即：<code>EnmCmdID.CS_LOGIN_REQ</code></p>\n<h4 id=\"3-数据的序列化和反序列化：\"><a href=\"#3-数据的序列化和反序列化：\" class=\"headerlink\" title=\"3.数据的序列化和反序列化：\"></a>3.数据的序列化和反序列化：</h4><p>数据发送的时候必须以数据流的形式进行，所以这里我们需要考虑如何<strong>将要发送的protobuf对象数据进行序列化，转化为byte[]字节数组</strong>，这就需要借助ProtoBuf库为我们提供的<code>Serializer</code>类的<code>Serialize</code>方法来完成，而反序列化则需借助<code>Deserialize</code>方法，将这两个方法封装到PackCodec类中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">using System;  </div><div class=\"line\">using ProtoBuf;  </div><div class=\"line\">  </div><div class=\"line\">/// &lt;summary&gt;  </div><div class=\"line\">/// 网络协议数据打包和解包类  </div><div class=\"line\">/// &lt;/summary&gt;  </div><div class=\"line\">public class PackCodec&#123;  </div><div class=\"line\">    /// &lt;summary&gt;  </div><div class=\"line\">    /// 序列化  </div><div class=\"line\">    /// &lt;/summary&gt;  </div><div class=\"line\">    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;  </div><div class=\"line\">    /// &lt;param name=&quot;msg&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">    /// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">    static public byte[] Serialize&lt;T&gt;(T msg)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        byte[] result = null;  </div><div class=\"line\">        if (msg != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            using (var stream = new MemoryStream())  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                Serializer.Serialize&lt;T&gt;(stream, msg);  </div><div class=\"line\">                result = stream.ToArray();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        return result;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    /// &lt;summary&gt;  </div><div class=\"line\">    /// 反序列化  </div><div class=\"line\">    /// &lt;/summary&gt;  </div><div class=\"line\">    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;  </div><div class=\"line\">    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">    /// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">    static public T Deserialize&lt;T&gt;(byte[] message)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        T result = default(T);  </div><div class=\"line\">        if (message != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            using (var stream = new MemoryStream(message))  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                result = Serializer.Deserialize&lt;T&gt;(stream);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        return result;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用方法很简单，直接传入一个数据对象即可得到字节数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">byte[] buf = PackCodec.Serialize(mReq);</div></pre></td></tr></table></figure></p>\n<p>为了检验打包和解包是否匹配，我们可以直接做一次本地测试：将打包后的数据直接解包，看看数据是否与原来的一致：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using System;  </div><div class=\"line\">using cs;  </div><div class=\"line\">using ProtoBuf;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">  </div><div class=\"line\">public class TestProtoNet : MonoBehaviour &#123;  </div><div class=\"line\">  </div><div class=\"line\">    // Use this for initialization  </div><div class=\"line\">    void Start () &#123;  </div><div class=\"line\">        CSLoginInfo mLoginInfo = new CSLoginInfo();  </div><div class=\"line\">        mLoginInfo.UserName = &quot;linshuhe&quot;;  </div><div class=\"line\">        mLoginInfo.Password = &quot;123456&quot;;  </div><div class=\"line\">        CSLoginReq mReq = new CSLoginReq();  </div><div class=\"line\">        mReq.LoginInfo = mLoginInfo;  </div><div class=\"line\">  </div><div class=\"line\">        byte[] pbdata = PackCodec.Serialize(mReq);  </div><div class=\"line\">        CSLoginReq pReq = PackCodec.Deserialize&lt;CSLoginReq&gt;(pbdata);  </div><div class=\"line\">        Debug.Log(&quot;UserName = &quot; + pReq.LoginInfo.UserName + &quot;, Password = &quot; + pReq.LoginInfo.Password);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    // Update is called once per frame  </div><div class=\"line\">    void Update () &#123;  </div><div class=\"line\">      </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125; </div><div class=\"line\">``` </div><div class=\"line\">将此脚本绑到场景中的相机上，运行得到以下结果，则说明打包和解包完全匹配：</div><div class=\"line\">![](http://img.blog.csdn.net/20160825100033496)    </div><div class=\"line\"></div><div class=\"line\">#### 4.数据发送和接收：</div><div class=\"line\">这里我们使用的网络通信方式是Socket的强联网方式，关于如何在Unity中使用Socket进行通信，可以参考我之前的文章：[Unity —— Socket通信(C#)](http://blog.csdn.net/linshuhe1/article/details/51386559)，Unity客户端需要复制此项目的**ClientSocket.cs**和**ByteBuffer.cs**两个类到当前项目中。</div><div class=\"line\"></div><div class=\"line\">此外，服务器可以参照之前的方式搭建，唯一不同的是RecieveMessage(object clientSocket)方法解析数据的过程需要进行修改，因为需要使用protobuf-net.dll进行数据解包，所以需要参考客户端的做法，把protobuf-net.dll复制到服务器项目中的Protobuf_net目录下：  </div><div class=\"line\">![](http://img.blog.csdn.net/20160825175754877)</div><div class=\"line\">假如由于直接使用源码而不用.dll会出现不安全保存，需要在Visual Studio中设置允许不安全代码，具体步骤为：在“解决方案”中选中工程，右键“数据”，选择“生成”页签，勾选“允许不安全代码”：</div><div class=\"line\">![](http://img.blog.csdn.net/20160825180841975)    </div><div class=\"line\">当然，解析数据所用的解析类和协议号两个脚本cs_login.cs和cs_enum.cs也应该添加到服务器项目中，保证客户端和服务器一直，此外PackCodec.cs也需要添加到服务器代码中但是要把其中的using UnityEngine给去掉防止报错，最终服务器目录结构如下：</div><div class=\"line\">![](http://img.blog.csdn.net/20160825191847662)</div><div class=\"line\"></div><div class=\"line\">#### 5.完整协议数据的封装：</div><div class=\"line\">从之前说过的设计思路分析，我们在发送数据的时候除了要发送关键的protobuf数据之外，还需要带上两个附件的数据：协议头（用于进行通信检验）和协议号（用于确定解析类）。假设我们的是：</div><div class=\"line\"></div><div class=\"line\">- **协议头**：用于表示后面数据的长度，一个short类型的数据：</div><div class=\"line\">```C#</div><div class=\"line\">/// &lt;summary&gt;  </div><div class=\"line\">/// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class=\"line\">/// &lt;/summary&gt;  </div><div class=\"line\">/// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">/// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">private static byte[] WriteMessage(byte[] message)  </div><div class=\"line\">&#123;  </div><div class=\"line\">    MemoryStream ms = null;  </div><div class=\"line\">    using (ms = new MemoryStream())  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        ms.Position = 0;  </div><div class=\"line\">        BinaryWriter writer = new BinaryWriter(ms);  </div><div class=\"line\">        ushort msglen = (ushort)message.Length;  </div><div class=\"line\">        writer.Write(msglen);  </div><div class=\"line\">        writer.Write(message);  </div><div class=\"line\">        writer.Flush();  </div><div class=\"line\">        return ms.ToArray();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>协议号</strong>：用于对应解析类，这里我们使用的是int类型的数据：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private byte[] CreateData(int typeId,IExtensible pbuf)  </div><div class=\"line\">  </div><div class=\"line\">byte[] pbdata = PackCodec.Serialize(pbuf);  </div><div class=\"line\">ByteBuffer buff = new ByteBuffer();  </div><div class=\"line\">buff.WriteInt(typeId);  </div><div class=\"line\">buff.WriteBytes(pbdata);  </div><div class=\"line\">return buff.ToBytes();</div></pre></td></tr></table></figure>\n<p>客户端发送登录数据时测试脚本TestProtoNet如下，测试需要将此脚本绑定到当前场景的相机上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">using UnityEngine;  </div><div class=\"line\">using System.Collections;  </div><div class=\"line\">using System;  </div><div class=\"line\">using cs;  </div><div class=\"line\">using Net;  </div><div class=\"line\">using ProtoBuf;  </div><div class=\"line\">using System.IO;  </div><div class=\"line\">  </div><div class=\"line\">public class TestProtoNet : MonoBehaviour &#123;  </div><div class=\"line\">  </div><div class=\"line\">    // Use this for initialization  </div><div class=\"line\">    void Start () &#123;  </div><div class=\"line\">  </div><div class=\"line\">  </div><div class=\"line\">        CSLoginInfo mLoginInfo = new CSLoginInfo();  </div><div class=\"line\">        mLoginInfo.UserName = &quot;linshuhe&quot;;  </div><div class=\"line\">        mLoginInfo.Password = &quot;123456&quot;;  </div><div class=\"line\">        CSLoginReq mReq = new CSLoginReq();  </div><div class=\"line\">        mReq.LoginInfo = mLoginInfo;  </div><div class=\"line\">  </div><div class=\"line\">        byte[] data = CreateData((int)EnmCmdID.CS_LOGIN_REQ, mReq);  </div><div class=\"line\">        ClientSocket mSocket = new ClientSocket();  </div><div class=\"line\">        mSocket.ConnectServer(&quot;127.0.0.1&quot;, 8088);  </div><div class=\"line\">        mSocket.SendMessage(data);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    private byte[] CreateData(int typeId,IExtensible pbuf)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        byte[] pbdata = PackCodec.Serialize(pbuf);  </div><div class=\"line\">        ByteBuffer buff = new ByteBuffer();  </div><div class=\"line\">        buff.WriteInt(typeId);  </div><div class=\"line\">        buff.WriteBytes(pbdata);  </div><div class=\"line\">        return WriteMessage(buff.ToBytes());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    /// &lt;summary&gt;  </div><div class=\"line\">    /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class=\"line\">    /// &lt;/summary&gt;  </div><div class=\"line\">    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class=\"line\">    /// &lt;returns&gt;&lt;/returns&gt;  </div><div class=\"line\">    private static byte[] WriteMessage(byte[] message)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        MemoryStream ms = null;  </div><div class=\"line\">        using (ms = new MemoryStream())  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            ms.Position = 0;  </div><div class=\"line\">            BinaryWriter writer = new BinaryWriter(ms);  </div><div class=\"line\">            ushort msglen = (ushort)message.Length;  </div><div class=\"line\">            writer.Write(msglen);  </div><div class=\"line\">            writer.Write(message);  </div><div class=\"line\">            writer.Flush();  </div><div class=\"line\">            return ms.ToArray();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    // Update is called once per frame  </div><div class=\"line\">    void Update () &#123;  </div><div class=\"line\">      </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125; </div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">服务器接受数据解包过程参考打包数据的格式，在RecieveMessage(object clientSocket)中，解析数据的核心代码如下：</div><div class=\"line\"></div><div class=\"line\">```C#</div><div class=\"line\">ByteBuffer buff = new ByteBuffer(result);  </div><div class=\"line\">int datalength = buff.ReadShort();  </div><div class=\"line\">int typeId = buff.ReadInt();  </div><div class=\"line\">byte[] pbdata = buff.ReadBytes();  </div><div class=\"line\">//通过协议号判断选择的解析类  </div><div class=\"line\">if(typeId == (int)EnmCmdID.CS_LOGIN_REQ)  </div><div class=\"line\">&#123;  </div><div class=\"line\">        CSLoginReq clientReq = PackCodec.Deserialize&lt;CSLoginReq&gt;(pbdata);  </div><div class=\"line\">        string user_name = clientReq.LoginInfo.UserName;  </div><div class=\"line\">        string pass_word = clientReq.LoginInfo.Password;  </div><div class=\"line\">        Console.WriteLine(&quot;数据内容：UserName=&#123;0&#125;,Password=&#123;1&#125;&quot;, user_name, pass_word);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面通过typeId来找到匹配的数据解析类，协议少的时候可以使用这种简单的使用if语句分支判断来实现，但是假如协议类型多了，则需要进一步封装查找方法，常用的方法有：定义一个Dictionary<int,Type>字典来存放协议号（int）和协议类型（Type）的对应关系。</p>\n<h4 id=\"6-运行结果：\"><a href=\"#6-运行结果：\" class=\"headerlink\" title=\"6.运行结果：\"></a>6.运行结果：</h4><p>启动服务器，然后运行Unity中的客户端，得到正确的结果应该如下：<br><img src=\"http://img.blog.csdn.net/20160825192659728\" alt=\"\"><br>项目服务器和客户端的完整代码可以前往此处下载：<a href=\"http://download.csdn.net/detail/linshuhe1/9613076\">protobuf-net网络协议的定制</a></p>"},{"title":"Unity3D —— 小地图制作插件NJG MiniMap","date":"2016-10-11T02:22:53.000Z","_content":"\n在很多实时PVP对战游戏（如：英雄联盟、王者荣耀等）的战斗场景中，都会有一个小地图，用于实时地显示一些比较重要因素，例如：队友和对手位置、存活炮塔位置、Boss出生死亡情况等。\n\n### NJG MiniMap插件：\n\n#### 1.下载地址：\nNJG下载地址：链接：[http://pan.baidu.com/s/1kTkzxxt](http://pan.baidu.com/s/1kTkzxxt) 密码：jwqy\n\n<!--more-->\n\n#### 2、NGUI Version：\n下载好插件后，导入到Unity中不用说，导入后可以看到NinjutsuGames文件夹，插件的所有内容都在这个文件夹下，找到NinjutsuGames/NJG MiniMap目录下的NGUI Version包双击，它会生成一个``NGUI Version``文件夹：\n\n![](http://i.imgur.com/R6Glx1B.png)\n\n#### 3、实例：\n可以在NGUI Version/Examples/Scene2中查看示例，打开示例场景``Example-BigTerain``查看效果，但是好像会有一个BUG，查看世界地图的时候会出现显示错误，可看到图中红色箭头部分：\n\n![](http://i.imgur.com/p4SuWBj.png)\n![](http://i.imgur.com/vbAVmJm.png)\n\n### 创建自己的Demo：\n\n看过官方的示例，我们可以自己创建一个场景来试试，这里我就不搭建自己的场景，直接用NJG MiniMap搭建好的场景来做：\n\n#### 1.新建场景：\n新建一个场景，这里命名为scene9，找到``NinjutsuGames\\NJG MiniMap\\ExamplesAssets\\Prefabs``目录下的``Scene.prefab``直接拖动到Hierarchy栏中，运行可以看到效果如下,这时候有些对象里可能会出现如下错误：\n\n![](http://i.imgur.com/rjBtQFX.png)\n![](http://i.imgur.com/R740xO4.png)\n\n这是因为预设里面已经绑定了相关小地图的脚本，但是现在我们还没有添加相关小地图的NGUI内容，有两个解决方法：\n\n- （1）直接删掉这个脚本；\n- （2）待后续添加相关内容即可\n\n这里把Scene里全部对象的这个脚本都删掉；\n\n#### 2添加小地图:\n小地图是用NGUI创建的\n\n- 先用NGUI创建一个2D UI：NGUI——>Create——>2D UI：\n- 把NinjutsuGames\\NJG MiniMap\\NGUI Version\\Prefabs目录下的``NJG MiniMap.prefab``文件直接拖动到UI Root下面，点击UI Root下的Camera，可以在Scene的右下角看到小地图的缩略版：\n\n这时候我们点击运行，可以看到小地图已经出现，截图如下：\n\n![](http://i.imgur.com/hMgtWtm.png)\n\n#### 3.添加其他物体：\n小地图中没有任何标识，我们需要为小地图创建主角对象以及一些敌方怪物啊、NPC等等。在目录NinjutsuGames\\NJG MiniMap\\Common\\Scripts\\Core找到脚本``NJGMapItem.cs``，添加到要标识的对象上，在这个场景中我们以Scene中的`` _Player ``为例，将脚本添加到`` _Player ``组件中，然后选择NJGMap Item(Script)中的Market Type选项，这里我们选为Me，就可以在小地图中看到表示_Player对象的标识了：\n\n![](http://i.imgur.com/ACoSWra.png)\n\n#### 4.自定义图标：\n我们还可以选择自定义图标，选择_Player的NJGMap Item组件中的``Edit NJG MiniMap``来进行编辑：\n\n![](http://i.imgur.com/h97uTEG.png)\n\n如下图：\n\n![](http://i.imgur.com/fQ4KPzi.png)\n\n- Altas选择自定义图标所在的图集；\n- 点击Add New添加新的Market Type；\n- Marker Type设置当前标识名；\n- Icon Sprite就是选择对应的图标了；\n\n#### 5.分层编辑：\n按步骤3中修改对应的Marker Type的名字即可，效果如下：\n\n![](http://i.imgur.com/uCcRIE2.png)\n\n#### 6.额外功能：\n在小地图中还可以添加迷雾效果：\n选中UI Root下的NJG MiniMap，找到NJGMap组件中的FOW项，勾选上Enabled项：\n\n![](http://i.imgur.com/nq9ZiH5.png)\n\n这时候小地图已经被迷雾覆盖，还需要设置对象物体的可视，勾选_Player中NJGMap Item中的Reveal FOW选项，调节可视距离即可，可视距离为0的话默认全部可视：\n\n![](http://i.imgur.com/H8CrEee.png)\n\n#### 7、最终结果：\n\n![](http://i.imgur.com/Cl9Ru6r.png)\n\n\n","source":"_posts/Unity3D-——-小地图制作插件NJG-MiniMap.md","raw":"---\ntitle: Unity3D —— 小地图制作插件NJG MiniMap\ndate: 2016-10-11 10:22:53\ntags: NJG,Unity\ncategories: Unity\n---\n\n在很多实时PVP对战游戏（如：英雄联盟、王者荣耀等）的战斗场景中，都会有一个小地图，用于实时地显示一些比较重要因素，例如：队友和对手位置、存活炮塔位置、Boss出生死亡情况等。\n\n### NJG MiniMap插件：\n\n#### 1.下载地址：\nNJG下载地址：链接：[http://pan.baidu.com/s/1kTkzxxt](http://pan.baidu.com/s/1kTkzxxt) 密码：jwqy\n\n<!--more-->\n\n#### 2、NGUI Version：\n下载好插件后，导入到Unity中不用说，导入后可以看到NinjutsuGames文件夹，插件的所有内容都在这个文件夹下，找到NinjutsuGames/NJG MiniMap目录下的NGUI Version包双击，它会生成一个``NGUI Version``文件夹：\n\n![](http://i.imgur.com/R6Glx1B.png)\n\n#### 3、实例：\n可以在NGUI Version/Examples/Scene2中查看示例，打开示例场景``Example-BigTerain``查看效果，但是好像会有一个BUG，查看世界地图的时候会出现显示错误，可看到图中红色箭头部分：\n\n![](http://i.imgur.com/p4SuWBj.png)\n![](http://i.imgur.com/vbAVmJm.png)\n\n### 创建自己的Demo：\n\n看过官方的示例，我们可以自己创建一个场景来试试，这里我就不搭建自己的场景，直接用NJG MiniMap搭建好的场景来做：\n\n#### 1.新建场景：\n新建一个场景，这里命名为scene9，找到``NinjutsuGames\\NJG MiniMap\\ExamplesAssets\\Prefabs``目录下的``Scene.prefab``直接拖动到Hierarchy栏中，运行可以看到效果如下,这时候有些对象里可能会出现如下错误：\n\n![](http://i.imgur.com/rjBtQFX.png)\n![](http://i.imgur.com/R740xO4.png)\n\n这是因为预设里面已经绑定了相关小地图的脚本，但是现在我们还没有添加相关小地图的NGUI内容，有两个解决方法：\n\n- （1）直接删掉这个脚本；\n- （2）待后续添加相关内容即可\n\n这里把Scene里全部对象的这个脚本都删掉；\n\n#### 2添加小地图:\n小地图是用NGUI创建的\n\n- 先用NGUI创建一个2D UI：NGUI——>Create——>2D UI：\n- 把NinjutsuGames\\NJG MiniMap\\NGUI Version\\Prefabs目录下的``NJG MiniMap.prefab``文件直接拖动到UI Root下面，点击UI Root下的Camera，可以在Scene的右下角看到小地图的缩略版：\n\n这时候我们点击运行，可以看到小地图已经出现，截图如下：\n\n![](http://i.imgur.com/hMgtWtm.png)\n\n#### 3.添加其他物体：\n小地图中没有任何标识，我们需要为小地图创建主角对象以及一些敌方怪物啊、NPC等等。在目录NinjutsuGames\\NJG MiniMap\\Common\\Scripts\\Core找到脚本``NJGMapItem.cs``，添加到要标识的对象上，在这个场景中我们以Scene中的`` _Player ``为例，将脚本添加到`` _Player ``组件中，然后选择NJGMap Item(Script)中的Market Type选项，这里我们选为Me，就可以在小地图中看到表示_Player对象的标识了：\n\n![](http://i.imgur.com/ACoSWra.png)\n\n#### 4.自定义图标：\n我们还可以选择自定义图标，选择_Player的NJGMap Item组件中的``Edit NJG MiniMap``来进行编辑：\n\n![](http://i.imgur.com/h97uTEG.png)\n\n如下图：\n\n![](http://i.imgur.com/fQ4KPzi.png)\n\n- Altas选择自定义图标所在的图集；\n- 点击Add New添加新的Market Type；\n- Marker Type设置当前标识名；\n- Icon Sprite就是选择对应的图标了；\n\n#### 5.分层编辑：\n按步骤3中修改对应的Marker Type的名字即可，效果如下：\n\n![](http://i.imgur.com/uCcRIE2.png)\n\n#### 6.额外功能：\n在小地图中还可以添加迷雾效果：\n选中UI Root下的NJG MiniMap，找到NJGMap组件中的FOW项，勾选上Enabled项：\n\n![](http://i.imgur.com/nq9ZiH5.png)\n\n这时候小地图已经被迷雾覆盖，还需要设置对象物体的可视，勾选_Player中NJGMap Item中的Reveal FOW选项，调节可视距离即可，可视距离为0的话默认全部可视：\n\n![](http://i.imgur.com/H8CrEee.png)\n\n#### 7、最终结果：\n\n![](http://i.imgur.com/Cl9Ru6r.png)\n\n\n","slug":"Unity3D-——-小地图制作插件NJG-MiniMap","published":1,"updated":"2017-06-24T02:13:49.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfl3001a9gfjfgkjagv1","content":"<p>在很多实时PVP对战游戏（如：英雄联盟、王者荣耀等）的战斗场景中，都会有一个小地图，用于实时地显示一些比较重要因素，例如：队友和对手位置、存活炮塔位置、Boss出生死亡情况等。</p>\n<h3 id=\"NJG-MiniMap插件：\"><a href=\"#NJG-MiniMap插件：\" class=\"headerlink\" title=\"NJG MiniMap插件：\"></a>NJG MiniMap插件：</h3><h4 id=\"1-下载地址：\"><a href=\"#1-下载地址：\" class=\"headerlink\" title=\"1.下载地址：\"></a>1.下载地址：</h4><p>NJG下载地址：链接：<a href=\"http://pan.baidu.com/s/1kTkzxxt\" target=\"_blank\" rel=\"external\">http://pan.baidu.com/s/1kTkzxxt</a> 密码：jwqy</p>\n<a id=\"more\"></a>\n<h4 id=\"2、NGUI-Version：\"><a href=\"#2、NGUI-Version：\" class=\"headerlink\" title=\"2、NGUI Version：\"></a>2、NGUI Version：</h4><p>下载好插件后，导入到Unity中不用说，导入后可以看到NinjutsuGames文件夹，插件的所有内容都在这个文件夹下，找到NinjutsuGames/NJG MiniMap目录下的NGUI Version包双击，它会生成一个<code>NGUI Version</code>文件夹：</p>\n<p><img src=\"http://i.imgur.com/R6Glx1B.png\" alt=\"\"></p>\n<h4 id=\"3、实例：\"><a href=\"#3、实例：\" class=\"headerlink\" title=\"3、实例：\"></a>3、实例：</h4><p>可以在NGUI Version/Examples/Scene2中查看示例，打开示例场景<code>Example-BigTerain</code>查看效果，但是好像会有一个BUG，查看世界地图的时候会出现显示错误，可看到图中红色箭头部分：</p>\n<p><img src=\"http://i.imgur.com/p4SuWBj.png\" alt=\"\"><br><img src=\"http://i.imgur.com/vbAVmJm.png\" alt=\"\"></p>\n<h3 id=\"创建自己的Demo：\"><a href=\"#创建自己的Demo：\" class=\"headerlink\" title=\"创建自己的Demo：\"></a>创建自己的Demo：</h3><p>看过官方的示例，我们可以自己创建一个场景来试试，这里我就不搭建自己的场景，直接用NJG MiniMap搭建好的场景来做：</p>\n<h4 id=\"1-新建场景：\"><a href=\"#1-新建场景：\" class=\"headerlink\" title=\"1.新建场景：\"></a>1.新建场景：</h4><p>新建一个场景，这里命名为scene9，找到<code>NinjutsuGames\\NJG MiniMap\\ExamplesAssets\\Prefabs</code>目录下的<code>Scene.prefab</code>直接拖动到Hierarchy栏中，运行可以看到效果如下,这时候有些对象里可能会出现如下错误：</p>\n<p><img src=\"http://i.imgur.com/rjBtQFX.png\" alt=\"\"><br><img src=\"http://i.imgur.com/R740xO4.png\" alt=\"\"></p>\n<p>这是因为预设里面已经绑定了相关小地图的脚本，但是现在我们还没有添加相关小地图的NGUI内容，有两个解决方法：</p>\n<ul>\n<li>（1）直接删掉这个脚本；</li>\n<li>（2）待后续添加相关内容即可</li>\n</ul>\n<p>这里把Scene里全部对象的这个脚本都删掉；</p>\n<h4 id=\"2添加小地图\"><a href=\"#2添加小地图\" class=\"headerlink\" title=\"2添加小地图:\"></a>2添加小地图:</h4><p>小地图是用NGUI创建的</p>\n<ul>\n<li>先用NGUI创建一个2D UI：NGUI——&gt;Create——&gt;2D UI：</li>\n<li>把NinjutsuGames\\NJG MiniMap\\NGUI Version\\Prefabs目录下的<code>NJG MiniMap.prefab</code>文件直接拖动到UI Root下面，点击UI Root下的Camera，可以在Scene的右下角看到小地图的缩略版：</li>\n</ul>\n<p>这时候我们点击运行，可以看到小地图已经出现，截图如下：</p>\n<p><img src=\"http://i.imgur.com/hMgtWtm.png\" alt=\"\"></p>\n<h4 id=\"3-添加其他物体：\"><a href=\"#3-添加其他物体：\" class=\"headerlink\" title=\"3.添加其他物体：\"></a>3.添加其他物体：</h4><p>小地图中没有任何标识，我们需要为小地图创建主角对象以及一些敌方怪物啊、NPC等等。在目录NinjutsuGames\\NJG MiniMap\\Common\\Scripts\\Core找到脚本<code>NJGMapItem.cs</code>，添加到要标识的对象上，在这个场景中我们以Scene中的<code>_Player</code>为例，将脚本添加到<code>_Player</code>组件中，然后选择NJGMap Item(Script)中的Market Type选项，这里我们选为Me，就可以在小地图中看到表示_Player对象的标识了：</p>\n<p><img src=\"http://i.imgur.com/ACoSWra.png\" alt=\"\"></p>\n<h4 id=\"4-自定义图标：\"><a href=\"#4-自定义图标：\" class=\"headerlink\" title=\"4.自定义图标：\"></a>4.自定义图标：</h4><p>我们还可以选择自定义图标，选择_Player的NJGMap Item组件中的<code>Edit NJG MiniMap</code>来进行编辑：</p>\n<p><img src=\"http://i.imgur.com/h97uTEG.png\" alt=\"\"></p>\n<p>如下图：</p>\n<p><img src=\"http://i.imgur.com/fQ4KPzi.png\" alt=\"\"></p>\n<ul>\n<li>Altas选择自定义图标所在的图集；</li>\n<li>点击Add New添加新的Market Type；</li>\n<li>Marker Type设置当前标识名；</li>\n<li>Icon Sprite就是选择对应的图标了；</li>\n</ul>\n<h4 id=\"5-分层编辑：\"><a href=\"#5-分层编辑：\" class=\"headerlink\" title=\"5.分层编辑：\"></a>5.分层编辑：</h4><p>按步骤3中修改对应的Marker Type的名字即可，效果如下：</p>\n<p><img src=\"http://i.imgur.com/uCcRIE2.png\" alt=\"\"></p>\n<h4 id=\"6-额外功能：\"><a href=\"#6-额外功能：\" class=\"headerlink\" title=\"6.额外功能：\"></a>6.额外功能：</h4><p>在小地图中还可以添加迷雾效果：<br>选中UI Root下的NJG MiniMap，找到NJGMap组件中的FOW项，勾选上Enabled项：</p>\n<p><img src=\"http://i.imgur.com/nq9ZiH5.png\" alt=\"\"></p>\n<p>这时候小地图已经被迷雾覆盖，还需要设置对象物体的可视，勾选_Player中NJGMap Item中的Reveal FOW选项，调节可视距离即可，可视距离为0的话默认全部可视：</p>\n<p><img src=\"http://i.imgur.com/H8CrEee.png\" alt=\"\"></p>\n<h4 id=\"7、最终结果：\"><a href=\"#7、最终结果：\" class=\"headerlink\" title=\"7、最终结果：\"></a>7、最终结果：</h4><p><img src=\"http://i.imgur.com/Cl9Ru6r.png\" alt=\"\"></p>\n","excerpt":"<p>在很多实时PVP对战游戏（如：英雄联盟、王者荣耀等）的战斗场景中，都会有一个小地图，用于实时地显示一些比较重要因素，例如：队友和对手位置、存活炮塔位置、Boss出生死亡情况等。</p>\n<h3 id=\"NJG-MiniMap插件：\"><a href=\"#NJG-MiniMap插件：\" class=\"headerlink\" title=\"NJG MiniMap插件：\"></a>NJG MiniMap插件：</h3><h4 id=\"1-下载地址：\"><a href=\"#1-下载地址：\" class=\"headerlink\" title=\"1.下载地址：\"></a>1.下载地址：</h4><p>NJG下载地址：链接：<a href=\"http://pan.baidu.com/s/1kTkzxxt\">http://pan.baidu.com/s/1kTkzxxt</a> 密码：jwqy</p>","more":"<h4 id=\"2、NGUI-Version：\"><a href=\"#2、NGUI-Version：\" class=\"headerlink\" title=\"2、NGUI Version：\"></a>2、NGUI Version：</h4><p>下载好插件后，导入到Unity中不用说，导入后可以看到NinjutsuGames文件夹，插件的所有内容都在这个文件夹下，找到NinjutsuGames/NJG MiniMap目录下的NGUI Version包双击，它会生成一个<code>NGUI Version</code>文件夹：</p>\n<p><img src=\"http://i.imgur.com/R6Glx1B.png\" alt=\"\"></p>\n<h4 id=\"3、实例：\"><a href=\"#3、实例：\" class=\"headerlink\" title=\"3、实例：\"></a>3、实例：</h4><p>可以在NGUI Version/Examples/Scene2中查看示例，打开示例场景<code>Example-BigTerain</code>查看效果，但是好像会有一个BUG，查看世界地图的时候会出现显示错误，可看到图中红色箭头部分：</p>\n<p><img src=\"http://i.imgur.com/p4SuWBj.png\" alt=\"\"><br><img src=\"http://i.imgur.com/vbAVmJm.png\" alt=\"\"></p>\n<h3 id=\"创建自己的Demo：\"><a href=\"#创建自己的Demo：\" class=\"headerlink\" title=\"创建自己的Demo：\"></a>创建自己的Demo：</h3><p>看过官方的示例，我们可以自己创建一个场景来试试，这里我就不搭建自己的场景，直接用NJG MiniMap搭建好的场景来做：</p>\n<h4 id=\"1-新建场景：\"><a href=\"#1-新建场景：\" class=\"headerlink\" title=\"1.新建场景：\"></a>1.新建场景：</h4><p>新建一个场景，这里命名为scene9，找到<code>NinjutsuGames\\NJG MiniMap\\ExamplesAssets\\Prefabs</code>目录下的<code>Scene.prefab</code>直接拖动到Hierarchy栏中，运行可以看到效果如下,这时候有些对象里可能会出现如下错误：</p>\n<p><img src=\"http://i.imgur.com/rjBtQFX.png\" alt=\"\"><br><img src=\"http://i.imgur.com/R740xO4.png\" alt=\"\"></p>\n<p>这是因为预设里面已经绑定了相关小地图的脚本，但是现在我们还没有添加相关小地图的NGUI内容，有两个解决方法：</p>\n<ul>\n<li>（1）直接删掉这个脚本；</li>\n<li>（2）待后续添加相关内容即可</li>\n</ul>\n<p>这里把Scene里全部对象的这个脚本都删掉；</p>\n<h4 id=\"2添加小地图\"><a href=\"#2添加小地图\" class=\"headerlink\" title=\"2添加小地图:\"></a>2添加小地图:</h4><p>小地图是用NGUI创建的</p>\n<ul>\n<li>先用NGUI创建一个2D UI：NGUI——&gt;Create——&gt;2D UI：</li>\n<li>把NinjutsuGames\\NJG MiniMap\\NGUI Version\\Prefabs目录下的<code>NJG MiniMap.prefab</code>文件直接拖动到UI Root下面，点击UI Root下的Camera，可以在Scene的右下角看到小地图的缩略版：</li>\n</ul>\n<p>这时候我们点击运行，可以看到小地图已经出现，截图如下：</p>\n<p><img src=\"http://i.imgur.com/hMgtWtm.png\" alt=\"\"></p>\n<h4 id=\"3-添加其他物体：\"><a href=\"#3-添加其他物体：\" class=\"headerlink\" title=\"3.添加其他物体：\"></a>3.添加其他物体：</h4><p>小地图中没有任何标识，我们需要为小地图创建主角对象以及一些敌方怪物啊、NPC等等。在目录NinjutsuGames\\NJG MiniMap\\Common\\Scripts\\Core找到脚本<code>NJGMapItem.cs</code>，添加到要标识的对象上，在这个场景中我们以Scene中的<code>_Player</code>为例，将脚本添加到<code>_Player</code>组件中，然后选择NJGMap Item(Script)中的Market Type选项，这里我们选为Me，就可以在小地图中看到表示_Player对象的标识了：</p>\n<p><img src=\"http://i.imgur.com/ACoSWra.png\" alt=\"\"></p>\n<h4 id=\"4-自定义图标：\"><a href=\"#4-自定义图标：\" class=\"headerlink\" title=\"4.自定义图标：\"></a>4.自定义图标：</h4><p>我们还可以选择自定义图标，选择_Player的NJGMap Item组件中的<code>Edit NJG MiniMap</code>来进行编辑：</p>\n<p><img src=\"http://i.imgur.com/h97uTEG.png\" alt=\"\"></p>\n<p>如下图：</p>\n<p><img src=\"http://i.imgur.com/fQ4KPzi.png\" alt=\"\"></p>\n<ul>\n<li>Altas选择自定义图标所在的图集；</li>\n<li>点击Add New添加新的Market Type；</li>\n<li>Marker Type设置当前标识名；</li>\n<li>Icon Sprite就是选择对应的图标了；</li>\n</ul>\n<h4 id=\"5-分层编辑：\"><a href=\"#5-分层编辑：\" class=\"headerlink\" title=\"5.分层编辑：\"></a>5.分层编辑：</h4><p>按步骤3中修改对应的Marker Type的名字即可，效果如下：</p>\n<p><img src=\"http://i.imgur.com/uCcRIE2.png\" alt=\"\"></p>\n<h4 id=\"6-额外功能：\"><a href=\"#6-额外功能：\" class=\"headerlink\" title=\"6.额外功能：\"></a>6.额外功能：</h4><p>在小地图中还可以添加迷雾效果：<br>选中UI Root下的NJG MiniMap，找到NJGMap组件中的FOW项，勾选上Enabled项：</p>\n<p><img src=\"http://i.imgur.com/nq9ZiH5.png\" alt=\"\"></p>\n<p>这时候小地图已经被迷雾覆盖，还需要设置对象物体的可视，勾选_Player中NJGMap Item中的Reveal FOW选项，调节可视距离即可，可视距离为0的话默认全部可视：</p>\n<p><img src=\"http://i.imgur.com/H8CrEee.png\" alt=\"\"></p>\n<h4 id=\"7、最终结果：\"><a href=\"#7、最终结果：\" class=\"headerlink\" title=\"7、最终结果：\"></a>7、最终结果：</h4><p><img src=\"http://i.imgur.com/Cl9Ru6r.png\" alt=\"\"></p>"},{"title":"《Unity Shaders and Effects Cookbook》读书笔记1","date":"2016-09-19T12:13:44.000Z","_content":"\n最近在深入学习Unity的ShaderLab，起初看了很多别人的博客，但是内容都比较杂乱零散，想着应该找本书类系统学习一番，经过搜索找到了这本书**《Unity Shaders and Effects Cookbook》**，是当前对于Unity的Shader知识有比较系统介绍的一本书，本书也有中文翻译版，名称为**《Unity着色器与屏幕特效开发秘笈》**，作者是**Kenny Lammers**。\n\n![](http://i.imgur.com/0S2JOfR.png)\n\n### 简介：\n根据书的概述，阅读本书将学到模拟人体皮肤的着色器、处理动态反射的着色器、三维场景中的渲染次序等，同时也将学习如何开发后期特效，如夜视、反射等。\n\n<!--more-->\n\n### 章节概述：\n- 第1章：Unity中构建一个着色器和着色器编写的基础知识，学习如创建默认的**漫反射光照**，从游戏的角度提供创建自定义漫反射光照的技巧；\n- 第2章：介绍如何利用**纹理**来创建不同的特效，学习如何利用着色器在精灵表单（Sprite Sheet）上实现动画纹理，以及如何利用纹理的不同通道，让着色器更有效率；\n- 第3章：创建应用最广泛的高光类型——Blinn和Phong时所需的知识，学习如何应用这些着色器效果来创建蒙版镜面、金属镜面，并学习如何创建各向异性**镜面**的技术；\n- 第4章：把反射技术写入着色器中，从Unity3D着色器中反射的基础到如何使用C#创建简单的自定义动态**反射系统**；\n- 第5章：创建更复杂的着色器，学习如何创建自定义**光照模型**来实现自定义类型的表面，可以创建自己的皮肤着色器、发光球体着色器以及车辆喷漆着色器；\n- 第6章：介绍**透明度**，在游戏制作的过程中，透明度已经成为一项必要的技术，在一定程度上，几乎所有游戏都需要使用透明度，如：图形用户界面（GUI）、树叶、贴花等。本章将学习如何使用Unity3D中的透明度，已经使用透明度时如何处理可能发生的任何问题；\n- 第7章：如何访问存储在3D网格中的每个顶点信息，学习如何得到**顶点信息**，并在着色器中使用这些信息实现诸如纹理混合和动画的效果；\n- 第8章：介绍利用Unity内置标记和内置值来**减少着色器内存开销**的方法，这对于我们处理移动平台上的着色器特别重要；\n- 第9章：学习**重用代码**的必要性，重用代码可以让着色器的编写更有效率。如何创建自定义CgInclude文件来存储需要重用的重复代码；\n- 第10章：从现代游戏如何利用**屏幕特效**（有时也称为后期特效）开始，到如何改变一个游戏的最终渲染效果。学习如何创建自己的屏幕特效，并了解如何添加颜色调整以及纹理叠加背后的秘密，从而为你的游戏制造出不一样的视觉外观；\n- 第11章：屏幕特效深入，学习如何在游戏中增强游戏氛围。学习如何创建一种老电影的屏幕特效以及夜视的屏幕特效。\n\n### 预备工作：\n需要用到几个软件：\n\n- Unity3D（10和11章需要使用专业版Unity）\n- 3D建模软件，如Maya、Max或Blender\n- 2D图像编辑软件，如Photoshop或Gimp\n\n### 额外资源：\n本书中的一些效果图，可以通过下一网站下载：[https://www.packtpub.com/sites/default/files/downloads/5084OT_Images.pdf](https://www.packtpub.com/sites/default/files/downloads/5084OT_Images.pdf)\n\n\n","source":"_posts/《Unity-Shaders-and-Effects-Cookbook》读书笔记1.md","raw":"---\ntitle: 《Unity Shaders and Effects Cookbook》读书笔记1\ndate: 2016-09-19 20:13:44\ntags: Unity,ShaderLab\ncategories: Unity\n---\n\n最近在深入学习Unity的ShaderLab，起初看了很多别人的博客，但是内容都比较杂乱零散，想着应该找本书类系统学习一番，经过搜索找到了这本书**《Unity Shaders and Effects Cookbook》**，是当前对于Unity的Shader知识有比较系统介绍的一本书，本书也有中文翻译版，名称为**《Unity着色器与屏幕特效开发秘笈》**，作者是**Kenny Lammers**。\n\n![](http://i.imgur.com/0S2JOfR.png)\n\n### 简介：\n根据书的概述，阅读本书将学到模拟人体皮肤的着色器、处理动态反射的着色器、三维场景中的渲染次序等，同时也将学习如何开发后期特效，如夜视、反射等。\n\n<!--more-->\n\n### 章节概述：\n- 第1章：Unity中构建一个着色器和着色器编写的基础知识，学习如创建默认的**漫反射光照**，从游戏的角度提供创建自定义漫反射光照的技巧；\n- 第2章：介绍如何利用**纹理**来创建不同的特效，学习如何利用着色器在精灵表单（Sprite Sheet）上实现动画纹理，以及如何利用纹理的不同通道，让着色器更有效率；\n- 第3章：创建应用最广泛的高光类型——Blinn和Phong时所需的知识，学习如何应用这些着色器效果来创建蒙版镜面、金属镜面，并学习如何创建各向异性**镜面**的技术；\n- 第4章：把反射技术写入着色器中，从Unity3D着色器中反射的基础到如何使用C#创建简单的自定义动态**反射系统**；\n- 第5章：创建更复杂的着色器，学习如何创建自定义**光照模型**来实现自定义类型的表面，可以创建自己的皮肤着色器、发光球体着色器以及车辆喷漆着色器；\n- 第6章：介绍**透明度**，在游戏制作的过程中，透明度已经成为一项必要的技术，在一定程度上，几乎所有游戏都需要使用透明度，如：图形用户界面（GUI）、树叶、贴花等。本章将学习如何使用Unity3D中的透明度，已经使用透明度时如何处理可能发生的任何问题；\n- 第7章：如何访问存储在3D网格中的每个顶点信息，学习如何得到**顶点信息**，并在着色器中使用这些信息实现诸如纹理混合和动画的效果；\n- 第8章：介绍利用Unity内置标记和内置值来**减少着色器内存开销**的方法，这对于我们处理移动平台上的着色器特别重要；\n- 第9章：学习**重用代码**的必要性，重用代码可以让着色器的编写更有效率。如何创建自定义CgInclude文件来存储需要重用的重复代码；\n- 第10章：从现代游戏如何利用**屏幕特效**（有时也称为后期特效）开始，到如何改变一个游戏的最终渲染效果。学习如何创建自己的屏幕特效，并了解如何添加颜色调整以及纹理叠加背后的秘密，从而为你的游戏制造出不一样的视觉外观；\n- 第11章：屏幕特效深入，学习如何在游戏中增强游戏氛围。学习如何创建一种老电影的屏幕特效以及夜视的屏幕特效。\n\n### 预备工作：\n需要用到几个软件：\n\n- Unity3D（10和11章需要使用专业版Unity）\n- 3D建模软件，如Maya、Max或Blender\n- 2D图像编辑软件，如Photoshop或Gimp\n\n### 额外资源：\n本书中的一些效果图，可以通过下一网站下载：[https://www.packtpub.com/sites/default/files/downloads/5084OT_Images.pdf](https://www.packtpub.com/sites/default/files/downloads/5084OT_Images.pdf)\n\n\n","slug":"《Unity-Shaders-and-Effects-Cookbook》读书笔记1","published":1,"updated":"2017-06-24T02:13:49.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfl8001e9gfj6okkm0nq","content":"<p>最近在深入学习Unity的ShaderLab，起初看了很多别人的博客，但是内容都比较杂乱零散，想着应该找本书类系统学习一番，经过搜索找到了这本书<strong>《Unity Shaders and Effects Cookbook》</strong>，是当前对于Unity的Shader知识有比较系统介绍的一本书，本书也有中文翻译版，名称为<strong>《Unity着色器与屏幕特效开发秘笈》</strong>，作者是<strong>Kenny Lammers</strong>。</p>\n<p><img src=\"http://i.imgur.com/0S2JOfR.png\" alt=\"\"></p>\n<h3 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h3><p>根据书的概述，阅读本书将学到模拟人体皮肤的着色器、处理动态反射的着色器、三维场景中的渲染次序等，同时也将学习如何开发后期特效，如夜视、反射等。</p>\n<a id=\"more\"></a>\n<h3 id=\"章节概述：\"><a href=\"#章节概述：\" class=\"headerlink\" title=\"章节概述：\"></a>章节概述：</h3><ul>\n<li>第1章：Unity中构建一个着色器和着色器编写的基础知识，学习如创建默认的<strong>漫反射光照</strong>，从游戏的角度提供创建自定义漫反射光照的技巧；</li>\n<li>第2章：介绍如何利用<strong>纹理</strong>来创建不同的特效，学习如何利用着色器在精灵表单（Sprite Sheet）上实现动画纹理，以及如何利用纹理的不同通道，让着色器更有效率；</li>\n<li>第3章：创建应用最广泛的高光类型——Blinn和Phong时所需的知识，学习如何应用这些着色器效果来创建蒙版镜面、金属镜面，并学习如何创建各向异性<strong>镜面</strong>的技术；</li>\n<li>第4章：把反射技术写入着色器中，从Unity3D着色器中反射的基础到如何使用C#创建简单的自定义动态<strong>反射系统</strong>；</li>\n<li>第5章：创建更复杂的着色器，学习如何创建自定义<strong>光照模型</strong>来实现自定义类型的表面，可以创建自己的皮肤着色器、发光球体着色器以及车辆喷漆着色器；</li>\n<li>第6章：介绍<strong>透明度</strong>，在游戏制作的过程中，透明度已经成为一项必要的技术，在一定程度上，几乎所有游戏都需要使用透明度，如：图形用户界面（GUI）、树叶、贴花等。本章将学习如何使用Unity3D中的透明度，已经使用透明度时如何处理可能发生的任何问题；</li>\n<li>第7章：如何访问存储在3D网格中的每个顶点信息，学习如何得到<strong>顶点信息</strong>，并在着色器中使用这些信息实现诸如纹理混合和动画的效果；</li>\n<li>第8章：介绍利用Unity内置标记和内置值来<strong>减少着色器内存开销</strong>的方法，这对于我们处理移动平台上的着色器特别重要；</li>\n<li>第9章：学习<strong>重用代码</strong>的必要性，重用代码可以让着色器的编写更有效率。如何创建自定义CgInclude文件来存储需要重用的重复代码；</li>\n<li>第10章：从现代游戏如何利用<strong>屏幕特效</strong>（有时也称为后期特效）开始，到如何改变一个游戏的最终渲染效果。学习如何创建自己的屏幕特效，并了解如何添加颜色调整以及纹理叠加背后的秘密，从而为你的游戏制造出不一样的视觉外观；</li>\n<li>第11章：屏幕特效深入，学习如何在游戏中增强游戏氛围。学习如何创建一种老电影的屏幕特效以及夜视的屏幕特效。</li>\n</ul>\n<h3 id=\"预备工作：\"><a href=\"#预备工作：\" class=\"headerlink\" title=\"预备工作：\"></a>预备工作：</h3><p>需要用到几个软件：</p>\n<ul>\n<li>Unity3D（10和11章需要使用专业版Unity）</li>\n<li>3D建模软件，如Maya、Max或Blender</li>\n<li>2D图像编辑软件，如Photoshop或Gimp</li>\n</ul>\n<h3 id=\"额外资源：\"><a href=\"#额外资源：\" class=\"headerlink\" title=\"额外资源：\"></a>额外资源：</h3><p>本书中的一些效果图，可以通过下一网站下载：<a href=\"https://www.packtpub.com/sites/default/files/downloads/5084OT_Images.pdf\" target=\"_blank\" rel=\"external\">https://www.packtpub.com/sites/default/files/downloads/5084OT_Images.pdf</a></p>\n","excerpt":"<p>最近在深入学习Unity的ShaderLab，起初看了很多别人的博客，但是内容都比较杂乱零散，想着应该找本书类系统学习一番，经过搜索找到了这本书<strong>《Unity Shaders and Effects Cookbook》</strong>，是当前对于Unity的Shader知识有比较系统介绍的一本书，本书也有中文翻译版，名称为<strong>《Unity着色器与屏幕特效开发秘笈》</strong>，作者是<strong>Kenny Lammers</strong>。</p>\n<p><img src=\"http://i.imgur.com/0S2JOfR.png\" alt=\"\"></p>\n<h3 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h3><p>根据书的概述，阅读本书将学到模拟人体皮肤的着色器、处理动态反射的着色器、三维场景中的渲染次序等，同时也将学习如何开发后期特效，如夜视、反射等。</p>","more":"<h3 id=\"章节概述：\"><a href=\"#章节概述：\" class=\"headerlink\" title=\"章节概述：\"></a>章节概述：</h3><ul>\n<li>第1章：Unity中构建一个着色器和着色器编写的基础知识，学习如创建默认的<strong>漫反射光照</strong>，从游戏的角度提供创建自定义漫反射光照的技巧；</li>\n<li>第2章：介绍如何利用<strong>纹理</strong>来创建不同的特效，学习如何利用着色器在精灵表单（Sprite Sheet）上实现动画纹理，以及如何利用纹理的不同通道，让着色器更有效率；</li>\n<li>第3章：创建应用最广泛的高光类型——Blinn和Phong时所需的知识，学习如何应用这些着色器效果来创建蒙版镜面、金属镜面，并学习如何创建各向异性<strong>镜面</strong>的技术；</li>\n<li>第4章：把反射技术写入着色器中，从Unity3D着色器中反射的基础到如何使用C#创建简单的自定义动态<strong>反射系统</strong>；</li>\n<li>第5章：创建更复杂的着色器，学习如何创建自定义<strong>光照模型</strong>来实现自定义类型的表面，可以创建自己的皮肤着色器、发光球体着色器以及车辆喷漆着色器；</li>\n<li>第6章：介绍<strong>透明度</strong>，在游戏制作的过程中，透明度已经成为一项必要的技术，在一定程度上，几乎所有游戏都需要使用透明度，如：图形用户界面（GUI）、树叶、贴花等。本章将学习如何使用Unity3D中的透明度，已经使用透明度时如何处理可能发生的任何问题；</li>\n<li>第7章：如何访问存储在3D网格中的每个顶点信息，学习如何得到<strong>顶点信息</strong>，并在着色器中使用这些信息实现诸如纹理混合和动画的效果；</li>\n<li>第8章：介绍利用Unity内置标记和内置值来<strong>减少着色器内存开销</strong>的方法，这对于我们处理移动平台上的着色器特别重要；</li>\n<li>第9章：学习<strong>重用代码</strong>的必要性，重用代码可以让着色器的编写更有效率。如何创建自定义CgInclude文件来存储需要重用的重复代码；</li>\n<li>第10章：从现代游戏如何利用<strong>屏幕特效</strong>（有时也称为后期特效）开始，到如何改变一个游戏的最终渲染效果。学习如何创建自己的屏幕特效，并了解如何添加颜色调整以及纹理叠加背后的秘密，从而为你的游戏制造出不一样的视觉外观；</li>\n<li>第11章：屏幕特效深入，学习如何在游戏中增强游戏氛围。学习如何创建一种老电影的屏幕特效以及夜视的屏幕特效。</li>\n</ul>\n<h3 id=\"预备工作：\"><a href=\"#预备工作：\" class=\"headerlink\" title=\"预备工作：\"></a>预备工作：</h3><p>需要用到几个软件：</p>\n<ul>\n<li>Unity3D（10和11章需要使用专业版Unity）</li>\n<li>3D建模软件，如Maya、Max或Blender</li>\n<li>2D图像编辑软件，如Photoshop或Gimp</li>\n</ul>\n<h3 id=\"额外资源：\"><a href=\"#额外资源：\" class=\"headerlink\" title=\"额外资源：\"></a>额外资源：</h3><p>本书中的一些效果图，可以通过下一网站下载：<a href=\"https://www.packtpub.com/sites/default/files/downloads/5084OT_Images.pdf\">https://www.packtpub.com/sites/default/files/downloads/5084OT_Images.pdf</a></p>"},{"title":"《从零开始搭建游戏服务器》redis操作指令和Jedis工具","date":"2017-03-03T02:48:37.000Z","_content":"\n>### 引言\n上篇已经大致完成了redis的下载安装和简单的使用，接下来我们要真正地操作redis进行一些数据的增删改查操作。\n\n<!--more-->\n\n### 常用指令：\n#### 1.增加或者修改已有数据的值：\n若此key对应的value不存在，则创建这个键值对，若已存在，则修改此key的value数值：\n```Shell\nset key value\n```\n查询key是否存在：\n```Shell\nexists key\n```\n当然还可以设置失效时间：\n```Shell\nset key time value\n```\n可以通过指令查询key的存活时间：time to live\n```Shell\nttl key\n```\n假如数值为整数，还可以进行递增（incr）递减（decr）操作：\n![](http://img.blog.csdn.net/20170228115717776)\n\n除了操作基本的数据类型，redis数据库还能操作``列表``、``集合``、``哈希表``等复杂的数据结构。\n\n#### 2.查询：\n通过key来找对应的value值是redis这种键值对结构数据库最大的优势，检索速度快：\n```Shell\nget key\n```\n当然也可以通过key的特征来模糊检索符合条件的key集合：\n```Shell\nkeys pattern\n```\n\n#### 3.删\n跟查询一致，可以通过key值来删除单条数据：\n```Shell\ndel key\n```\n![](http://img.blog.csdn.net/20170228113002419)\n\n#### 4.其他指令：\n这是一些服务器管理常用的指令：\n```Shell\ninfo   #查看服务器信息\nselect <dbsize> #选择数据库索引  select 1\nflushall #清空全部数据\nflushdb  #清空当前索引的数据库\nslaveof <服务器> <端口>  #设置为从服务器\nslaveof no one #设置为主服务器\nshutdown  #关闭服务\nquit #退出客户端\n```\n\n### Redis可视化操作工具：\n#### 1.工具简介：\n``Redis Desktop Manager``（RedisDesktopManager，RDM）是一个快速、简单、支持跨平台的 Redis 桌面管理工具，基于 Qt 5 开发，支持通过 SSH Tunnel 连接。\n\n#### 2.下载安装：\n下载安装包：[Redis Desktop](https://redisdesktop.com/)\n\n#### 3.连接查看：\n\n\n---\n### Jedis工具：\n我们在进行系统开发时，通常不通过这种低效率的指令来操作Redis数据库，而是使用封装好的操作Redis数据库的工具，这里要说到的就是Redis官方提供的Jedis，这就是Redis提供的Java API对Redis进行操作。\n\n#### 1.工具下载：\n为了在项目中使用Jedis来操作Redis，需要下载对应的客户端开发包，这里我使用的版本是：\n","source":"_posts/《从零开始搭建游戏服务器》redis操作指令和Jedis工具.md","raw":"---\ntitle: 《从零开始搭建游戏服务器》redis操作指令和Jedis工具\ndate: 2017-03-03 10:48:37\ntags: Java,Protobuf\ncategories: 服务器开发\n---\n\n>### 引言\n上篇已经大致完成了redis的下载安装和简单的使用，接下来我们要真正地操作redis进行一些数据的增删改查操作。\n\n<!--more-->\n\n### 常用指令：\n#### 1.增加或者修改已有数据的值：\n若此key对应的value不存在，则创建这个键值对，若已存在，则修改此key的value数值：\n```Shell\nset key value\n```\n查询key是否存在：\n```Shell\nexists key\n```\n当然还可以设置失效时间：\n```Shell\nset key time value\n```\n可以通过指令查询key的存活时间：time to live\n```Shell\nttl key\n```\n假如数值为整数，还可以进行递增（incr）递减（decr）操作：\n![](http://img.blog.csdn.net/20170228115717776)\n\n除了操作基本的数据类型，redis数据库还能操作``列表``、``集合``、``哈希表``等复杂的数据结构。\n\n#### 2.查询：\n通过key来找对应的value值是redis这种键值对结构数据库最大的优势，检索速度快：\n```Shell\nget key\n```\n当然也可以通过key的特征来模糊检索符合条件的key集合：\n```Shell\nkeys pattern\n```\n\n#### 3.删\n跟查询一致，可以通过key值来删除单条数据：\n```Shell\ndel key\n```\n![](http://img.blog.csdn.net/20170228113002419)\n\n#### 4.其他指令：\n这是一些服务器管理常用的指令：\n```Shell\ninfo   #查看服务器信息\nselect <dbsize> #选择数据库索引  select 1\nflushall #清空全部数据\nflushdb  #清空当前索引的数据库\nslaveof <服务器> <端口>  #设置为从服务器\nslaveof no one #设置为主服务器\nshutdown  #关闭服务\nquit #退出客户端\n```\n\n### Redis可视化操作工具：\n#### 1.工具简介：\n``Redis Desktop Manager``（RedisDesktopManager，RDM）是一个快速、简单、支持跨平台的 Redis 桌面管理工具，基于 Qt 5 开发，支持通过 SSH Tunnel 连接。\n\n#### 2.下载安装：\n下载安装包：[Redis Desktop](https://redisdesktop.com/)\n\n#### 3.连接查看：\n\n\n---\n### Jedis工具：\n我们在进行系统开发时，通常不通过这种低效率的指令来操作Redis数据库，而是使用封装好的操作Redis数据库的工具，这里要说到的就是Redis官方提供的Jedis，这就是Redis提供的Java API对Redis进行操作。\n\n#### 1.工具下载：\n为了在项目中使用Jedis来操作Redis，需要下载对应的客户端开发包，这里我使用的版本是：\n","slug":"《从零开始搭建游戏服务器》redis操作指令和Jedis工具","published":1,"updated":"2017-06-24T02:13:49.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjflb001g9gfjwszahvgd","content":"<blockquote>\n<h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>上篇已经大致完成了redis的下载安装和简单的使用，接下来我们要真正地操作redis进行一些数据的增删改查操作。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"常用指令：\"><a href=\"#常用指令：\" class=\"headerlink\" title=\"常用指令：\"></a>常用指令：</h3><h4 id=\"1-增加或者修改已有数据的值：\"><a href=\"#1-增加或者修改已有数据的值：\" class=\"headerlink\" title=\"1.增加或者修改已有数据的值：\"></a>1.增加或者修改已有数据的值：</h4><p>若此key对应的value不存在，则创建这个键值对，若已存在，则修改此key的value数值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set key value</div></pre></td></tr></table></figure></p>\n<p>查询key是否存在：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">exists key</div></pre></td></tr></table></figure></p>\n<p>当然还可以设置失效时间：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set key time value</div></pre></td></tr></table></figure></p>\n<p>可以通过指令查询key的存活时间：time to live<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ttl key</div></pre></td></tr></table></figure></p>\n<p>假如数值为整数，还可以进行递增（incr）递减（decr）操作：<br><img src=\"http://img.blog.csdn.net/20170228115717776\" alt=\"\"></p>\n<p>除了操作基本的数据类型，redis数据库还能操作<code>列表</code>、<code>集合</code>、<code>哈希表</code>等复杂的数据结构。</p>\n<h4 id=\"2-查询：\"><a href=\"#2-查询：\" class=\"headerlink\" title=\"2.查询：\"></a>2.查询：</h4><p>通过key来找对应的value值是redis这种键值对结构数据库最大的优势，检索速度快：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">get key</div></pre></td></tr></table></figure></p>\n<p>当然也可以通过key的特征来模糊检索符合条件的key集合：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">keys pattern</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-删\"><a href=\"#3-删\" class=\"headerlink\" title=\"3.删\"></a>3.删</h4><p>跟查询一致，可以通过key值来删除单条数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">del key</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://img.blog.csdn.net/20170228113002419\" alt=\"\"></p>\n<h4 id=\"4-其他指令：\"><a href=\"#4-其他指令：\" class=\"headerlink\" title=\"4.其他指令：\"></a>4.其他指令：</h4><p>这是一些服务器管理常用的指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">info   #查看服务器信息</div><div class=\"line\">select &lt;dbsize&gt; #选择数据库索引  select 1</div><div class=\"line\">flushall #清空全部数据</div><div class=\"line\">flushdb  #清空当前索引的数据库</div><div class=\"line\">slaveof &lt;服务器&gt; &lt;端口&gt;  #设置为从服务器</div><div class=\"line\">slaveof no one #设置为主服务器</div><div class=\"line\">shutdown  #关闭服务</div><div class=\"line\">quit #退出客户端</div></pre></td></tr></table></figure></p>\n<h3 id=\"Redis可视化操作工具：\"><a href=\"#Redis可视化操作工具：\" class=\"headerlink\" title=\"Redis可视化操作工具：\"></a>Redis可视化操作工具：</h3><h4 id=\"1-工具简介：\"><a href=\"#1-工具简介：\" class=\"headerlink\" title=\"1.工具简介：\"></a>1.工具简介：</h4><p><code>Redis Desktop Manager</code>（RedisDesktopManager，RDM）是一个快速、简单、支持跨平台的 Redis 桌面管理工具，基于 Qt 5 开发，支持通过 SSH Tunnel 连接。</p>\n<h4 id=\"2-下载安装：\"><a href=\"#2-下载安装：\" class=\"headerlink\" title=\"2.下载安装：\"></a>2.下载安装：</h4><p>下载安装包：<a href=\"https://redisdesktop.com/\" target=\"_blank\" rel=\"external\">Redis Desktop</a></p>\n<h4 id=\"3-连接查看：\"><a href=\"#3-连接查看：\" class=\"headerlink\" title=\"3.连接查看：\"></a>3.连接查看：</h4><hr>\n<h3 id=\"Jedis工具：\"><a href=\"#Jedis工具：\" class=\"headerlink\" title=\"Jedis工具：\"></a>Jedis工具：</h3><p>我们在进行系统开发时，通常不通过这种低效率的指令来操作Redis数据库，而是使用封装好的操作Redis数据库的工具，这里要说到的就是Redis官方提供的Jedis，这就是Redis提供的Java API对Redis进行操作。</p>\n<h4 id=\"1-工具下载：\"><a href=\"#1-工具下载：\" class=\"headerlink\" title=\"1.工具下载：\"></a>1.工具下载：</h4><p>为了在项目中使用Jedis来操作Redis，需要下载对应的客户端开发包，这里我使用的版本是：</p>\n","excerpt":"<blockquote>\n<h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>上篇已经大致完成了redis的下载安装和简单的使用，接下来我们要真正地操作redis进行一些数据的增删改查操作。</p>\n</blockquote>","more":"<h3 id=\"常用指令：\"><a href=\"#常用指令：\" class=\"headerlink\" title=\"常用指令：\"></a>常用指令：</h3><h4 id=\"1-增加或者修改已有数据的值：\"><a href=\"#1-增加或者修改已有数据的值：\" class=\"headerlink\" title=\"1.增加或者修改已有数据的值：\"></a>1.增加或者修改已有数据的值：</h4><p>若此key对应的value不存在，则创建这个键值对，若已存在，则修改此key的value数值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set key value</div></pre></td></tr></table></figure></p>\n<p>查询key是否存在：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">exists key</div></pre></td></tr></table></figure></p>\n<p>当然还可以设置失效时间：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set key time value</div></pre></td></tr></table></figure></p>\n<p>可以通过指令查询key的存活时间：time to live<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ttl key</div></pre></td></tr></table></figure></p>\n<p>假如数值为整数，还可以进行递增（incr）递减（decr）操作：<br><img src=\"http://img.blog.csdn.net/20170228115717776\" alt=\"\"></p>\n<p>除了操作基本的数据类型，redis数据库还能操作<code>列表</code>、<code>集合</code>、<code>哈希表</code>等复杂的数据结构。</p>\n<h4 id=\"2-查询：\"><a href=\"#2-查询：\" class=\"headerlink\" title=\"2.查询：\"></a>2.查询：</h4><p>通过key来找对应的value值是redis这种键值对结构数据库最大的优势，检索速度快：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">get key</div></pre></td></tr></table></figure></p>\n<p>当然也可以通过key的特征来模糊检索符合条件的key集合：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">keys pattern</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-删\"><a href=\"#3-删\" class=\"headerlink\" title=\"3.删\"></a>3.删</h4><p>跟查询一致，可以通过key值来删除单条数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">del key</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://img.blog.csdn.net/20170228113002419\" alt=\"\"></p>\n<h4 id=\"4-其他指令：\"><a href=\"#4-其他指令：\" class=\"headerlink\" title=\"4.其他指令：\"></a>4.其他指令：</h4><p>这是一些服务器管理常用的指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">info   #查看服务器信息</div><div class=\"line\">select &lt;dbsize&gt; #选择数据库索引  select 1</div><div class=\"line\">flushall #清空全部数据</div><div class=\"line\">flushdb  #清空当前索引的数据库</div><div class=\"line\">slaveof &lt;服务器&gt; &lt;端口&gt;  #设置为从服务器</div><div class=\"line\">slaveof no one #设置为主服务器</div><div class=\"line\">shutdown  #关闭服务</div><div class=\"line\">quit #退出客户端</div></pre></td></tr></table></figure></p>\n<h3 id=\"Redis可视化操作工具：\"><a href=\"#Redis可视化操作工具：\" class=\"headerlink\" title=\"Redis可视化操作工具：\"></a>Redis可视化操作工具：</h3><h4 id=\"1-工具简介：\"><a href=\"#1-工具简介：\" class=\"headerlink\" title=\"1.工具简介：\"></a>1.工具简介：</h4><p><code>Redis Desktop Manager</code>（RedisDesktopManager，RDM）是一个快速、简单、支持跨平台的 Redis 桌面管理工具，基于 Qt 5 开发，支持通过 SSH Tunnel 连接。</p>\n<h4 id=\"2-下载安装：\"><a href=\"#2-下载安装：\" class=\"headerlink\" title=\"2.下载安装：\"></a>2.下载安装：</h4><p>下载安装包：<a href=\"https://redisdesktop.com/\">Redis Desktop</a></p>\n<h4 id=\"3-连接查看：\"><a href=\"#3-连接查看：\" class=\"headerlink\" title=\"3.连接查看：\"></a>3.连接查看：</h4><hr>\n<h3 id=\"Jedis工具：\"><a href=\"#Jedis工具：\" class=\"headerlink\" title=\"Jedis工具：\"></a>Jedis工具：</h3><p>我们在进行系统开发时，通常不通过这种低效率的指令来操作Redis数据库，而是使用封装好的操作Redis数据库的工具，这里要说到的就是Redis官方提供的Jedis，这就是Redis提供的Java API对Redis进行操作。</p>\n<h4 id=\"1-工具下载：\"><a href=\"#1-工具下载：\" class=\"headerlink\" title=\"1.工具下载：\"></a>1.工具下载：</h4><p>为了在项目中使用Jedis来操作Redis，需要下载对应的客户端开发包，这里我使用的版本是：</p>"},{"title":"《从零开始搭建游戏服务器》使用Protobuf定义网络协议","date":"2017-03-03T02:28:37.000Z","_content":"\n>引言：\n之前我们说过使用Protobuff编解码方式来对网络通信数据进行编码，也就是可以用这种方式来定义通信协议，那么具体要怎么做呢？关于此工具的详细资料和使用操作可以参考我之前写过的博客：[Unity3D —— protobuf网络框架](http://blog.csdn.net/linshuhe1/article/details/51781749)\n\n<!--more-->\n---\n\n### 准备工具：\n这里我就直接用之前编写的登录案例中的登录协议文件来进行本次案例的测试，工具下载地址如下：[protobuf-java-2.5.0.zip](http://download.csdn.net/detail/yangheng362/8516923)，主要使用到的文件有：\n- **protoc.exe**工具：通过此工具将从自定义的协议文件（.proto）得到相应（.java）的Java类文件；\n- 对应proto.exe版本的**protobuf-java.jar**包，用于解析上面得到的.java类，这里我使用的是2.5.0版本的protobuf；\n- cs_login.proto协议文件，关于proto协议文件的书写语法详细的可以查看：[Protobuf语言指南](http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html)，cs_login.proto内容如下（包名package可以根据当前服务器应用的包名进行修改）：\n    ```java\n    package com.tw.login.proto;\n\n    message CSLoginInfo\n    {\n        required string UserName = 1;//账号\n        required string Password = 2;//密码\n    }\n\n    //发送登录请求\n    message CSLoginReq\n    {\n        required CSLoginInfo LoginInfo = 1; \n    }\n    //登录请求回包数据\n    message CSLoginRes\n    {\n        required uint32 result_code = 1; \n    }\n    ```\n\tcs_enum.proto协议类型枚举文件，用于列举所有协议数据结构的编号：\n    ```java\n    package com.tw.login.proto;\n\n    enum EnmCmdID\n    {\n        CS_LOGIN_REQ = 10001;//登录请求协议号\n        CS_LOGIN_RES = 10002;//登录请求回包协议号\n    }\n\t```\n- 将.proto转化为Java类文件的处理脚本，这里其实只是一句命令行指令：\n\t```\n\tprotoc --java_out=(.java输出目录) (.proto文件存放目录)\\cs_login.proto\n\t```\n\t这里我根据实际项目目录结构定义了一个转文件的.bat批处理文件：\n    ```\n    echo on\n    call protoc --version\n\n    call protoc --java_out=..\\src\\ cs_login.proto\n    call protoc --java_out=..\\src\\ cs_enum.proto\n\n    PAUSE\n    ```\n    tool文件夹在当前java工程的根目录下，其下有三种文件：.proto的协议文件、转化文件用的protoc.exe工具和批处理文件general_java.bat：\n    ![](http://img.blog.csdn.net/20161220205058824)\n\n---\n### 在Netty服务器验证：\n####1. 转化协议：\n双击打开general_java.bat，转.proto协议得到.java脚本，转化成功现象如下，并且在package指定的目录下生产对应的.java类：\n\t![](http://img.blog.csdn.net/20161220205533580)\n    ![](http://img.blog.csdn.net/20161220205648112)\n\n####2.修改对通道**ChannelPipeline**中编解码格式的设置：\n 有一定网络通信协议基础的应该知道（不知道的赶紧补一下）：应用层位于传输层之上，当应用层要从传输层的Socket读取数据时，是从下向上层的传输，也就是``Upstream``；而反过来，从应用层向传输层的Socket写入并发数据时，则为``Downstream``。\n Upstream 和 Downstream 都是在 Pipeline 中“流动”的，所以影响 Upstream 和 Downstream 行为的 UpstreamHandler 和 DownstreamHandler，也要被放到 Pipeline 里。了解了上述这两个概念之后，我们就可以开始修改管道ChannelPipeline的参数，包括：\n    - ``frameDecoder``和``protobufDecoder``对应的handler用于解码Protobuf package数据包，他们都是Upstream Handles；\n    - ``frameEncoder``和``protobufEncoder``对应的handler用于编码Protobuf package数据包，他们都是Downstream Handles；\n    - 此外还有一个handler，是一个自定义的Upstream Handles，**用于开发者从网络数据中解析得到自己所需的数据**。\n\n 添加到Pipeline中的handler其实有特定的执行顺序，例如：\n    ```java\n\tpipeline.addLast(\"frameDecoder\",\n\t\t\t\t\t\tnew ProtobufVarint32FrameDecoder());\n\tpipeline.addLast(\"protobufDecoder\", new ProtobufDecoder(CsLogin.CSLoginReq.getDefaultInstance()));\n\tpipeline.addLast(\"frameEncoder\",new ProtobufVarint32LengthFieldPrepender());\n\tpipeline.addLast(\"protobufEncoder\", new ProtobufEncoder());\n\tpipeline.addLast(\"handler\",new SocketServerHandler());\n    ```\n 上例的执行顺序为：\n\t```java\n    upstream:frameDecoder,protobufDecoder,handler \t//解码从Socket收到的数据\n    downstream:frameEncoder,protobufEncoder\t\t\t//编码要通过Socket发送出去的数据\n    ```\n 这里我们假设协议数据的格式为纯protobuf数据格式，不进行如何加密操作，需要注意的一点：**protobufDecoder仅仅负责编码，并不支持读半包**，所以在之前一定要有**读半包的处理器**，即这里用到的frameDecoder，通常用此处理器读取包的数据长度，有三种方式可以选择：\n\t- 使用netty提供的 ``ProtobufVarint32FrameDecoder``；\n\t- 继承netty提供的通用半包处理器 ``LengthFieldBasedFrameDecoder``；\n\t- 继承netty提供的通用半包处理器 ``LengthFieldBasedFrameDecoder``。\n---\n### protobuf数据通信过程：\n####1.客户端创建数据：\n要构建一个protobuf数据，需要通过对应协议文件的数据结构，先通过每个数据类型的newBuilder()方法来创建对应的Builder对象，再对Builder中的属性进行赋值，最后才能使用Builder来build()数据对象，在客户端的自定义handler控制器``SocketClientHandler``中的**channelActive**方法中发送数据（注：当客户端和服务端建立tcp成功之后，Netty的NIO线程会调用channelActive）：\n```java\n@Override\npublic void channelActive(ChannelHandlerContext ctx) {\n\tCSLoginReq.Builder req_builder = CSLoginReq.newBuilder();\n    CSLoginInfo.Builder info_builder = CSLoginInfo.newBuilder();\n    info_builder.setUserName(\"linshuhe\");\n    info_builder.setPassword(\"123456\");\n    CSLoginInfo info = info_builder.build();\n    req_builder.setLoginInfo(info);\n    CSLoginReq req = req_builder.build();\n    ctx.writeAndFlush(req);\n}\n```\n最后，需要将数据对象通过writeAndFlush()发送出去用Socket传输。\n####2.服务器解析数据：\n在服务器自定义的handler控制器``SocketServerHandler``的**ChannelRead**方法中进行数据解析：\n```java\npublic void channelRead(ChannelHandlerContext arg0, Object msg) throws Exception {\n\t// TODO Auto-generated method stub\n\tCSLoginReq clientReq = (CSLoginReq)msg;\n    String user_name = clientReq.getLoginInfo().getUserName();\n    String pass_word = clientReq.getLoginInfo().getPassword();\n    logger.info(\"数据内容：UserName=\"+user_name+\",Password=\"+pass_word);\n}\n```\n####3.执行结果：\n服务器打印输出结果如下：\n![](http://img.blog.csdn.net/20170221133626442)\n\n---\n####备注：\n假如自定义的handler出现接受数据时只执行``channelReadComplete``方法而不执行``ChannelRead``方法，则说明数据发送的格式不对，因为只执行channelReadComplete说明收到消息没有能够被frameDecoder识别的指定的结束标志，例如：frameDecoder设置为lineBasedFrameDecoder时，结束标志为换行符。\n","source":"_posts/《从零开始搭建游戏服务器》使用Protobuf定义网络协议.md","raw":"---\ntitle: 《从零开始搭建游戏服务器》使用Protobuf定义网络协议\ndate: 2017-03-03 10:28:37\ntags: Java,Protobuf\ncategories: 服务器开发\n---\n\n>引言：\n之前我们说过使用Protobuff编解码方式来对网络通信数据进行编码，也就是可以用这种方式来定义通信协议，那么具体要怎么做呢？关于此工具的详细资料和使用操作可以参考我之前写过的博客：[Unity3D —— protobuf网络框架](http://blog.csdn.net/linshuhe1/article/details/51781749)\n\n<!--more-->\n---\n\n### 准备工具：\n这里我就直接用之前编写的登录案例中的登录协议文件来进行本次案例的测试，工具下载地址如下：[protobuf-java-2.5.0.zip](http://download.csdn.net/detail/yangheng362/8516923)，主要使用到的文件有：\n- **protoc.exe**工具：通过此工具将从自定义的协议文件（.proto）得到相应（.java）的Java类文件；\n- 对应proto.exe版本的**protobuf-java.jar**包，用于解析上面得到的.java类，这里我使用的是2.5.0版本的protobuf；\n- cs_login.proto协议文件，关于proto协议文件的书写语法详细的可以查看：[Protobuf语言指南](http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html)，cs_login.proto内容如下（包名package可以根据当前服务器应用的包名进行修改）：\n    ```java\n    package com.tw.login.proto;\n\n    message CSLoginInfo\n    {\n        required string UserName = 1;//账号\n        required string Password = 2;//密码\n    }\n\n    //发送登录请求\n    message CSLoginReq\n    {\n        required CSLoginInfo LoginInfo = 1; \n    }\n    //登录请求回包数据\n    message CSLoginRes\n    {\n        required uint32 result_code = 1; \n    }\n    ```\n\tcs_enum.proto协议类型枚举文件，用于列举所有协议数据结构的编号：\n    ```java\n    package com.tw.login.proto;\n\n    enum EnmCmdID\n    {\n        CS_LOGIN_REQ = 10001;//登录请求协议号\n        CS_LOGIN_RES = 10002;//登录请求回包协议号\n    }\n\t```\n- 将.proto转化为Java类文件的处理脚本，这里其实只是一句命令行指令：\n\t```\n\tprotoc --java_out=(.java输出目录) (.proto文件存放目录)\\cs_login.proto\n\t```\n\t这里我根据实际项目目录结构定义了一个转文件的.bat批处理文件：\n    ```\n    echo on\n    call protoc --version\n\n    call protoc --java_out=..\\src\\ cs_login.proto\n    call protoc --java_out=..\\src\\ cs_enum.proto\n\n    PAUSE\n    ```\n    tool文件夹在当前java工程的根目录下，其下有三种文件：.proto的协议文件、转化文件用的protoc.exe工具和批处理文件general_java.bat：\n    ![](http://img.blog.csdn.net/20161220205058824)\n\n---\n### 在Netty服务器验证：\n####1. 转化协议：\n双击打开general_java.bat，转.proto协议得到.java脚本，转化成功现象如下，并且在package指定的目录下生产对应的.java类：\n\t![](http://img.blog.csdn.net/20161220205533580)\n    ![](http://img.blog.csdn.net/20161220205648112)\n\n####2.修改对通道**ChannelPipeline**中编解码格式的设置：\n 有一定网络通信协议基础的应该知道（不知道的赶紧补一下）：应用层位于传输层之上，当应用层要从传输层的Socket读取数据时，是从下向上层的传输，也就是``Upstream``；而反过来，从应用层向传输层的Socket写入并发数据时，则为``Downstream``。\n Upstream 和 Downstream 都是在 Pipeline 中“流动”的，所以影响 Upstream 和 Downstream 行为的 UpstreamHandler 和 DownstreamHandler，也要被放到 Pipeline 里。了解了上述这两个概念之后，我们就可以开始修改管道ChannelPipeline的参数，包括：\n    - ``frameDecoder``和``protobufDecoder``对应的handler用于解码Protobuf package数据包，他们都是Upstream Handles；\n    - ``frameEncoder``和``protobufEncoder``对应的handler用于编码Protobuf package数据包，他们都是Downstream Handles；\n    - 此外还有一个handler，是一个自定义的Upstream Handles，**用于开发者从网络数据中解析得到自己所需的数据**。\n\n 添加到Pipeline中的handler其实有特定的执行顺序，例如：\n    ```java\n\tpipeline.addLast(\"frameDecoder\",\n\t\t\t\t\t\tnew ProtobufVarint32FrameDecoder());\n\tpipeline.addLast(\"protobufDecoder\", new ProtobufDecoder(CsLogin.CSLoginReq.getDefaultInstance()));\n\tpipeline.addLast(\"frameEncoder\",new ProtobufVarint32LengthFieldPrepender());\n\tpipeline.addLast(\"protobufEncoder\", new ProtobufEncoder());\n\tpipeline.addLast(\"handler\",new SocketServerHandler());\n    ```\n 上例的执行顺序为：\n\t```java\n    upstream:frameDecoder,protobufDecoder,handler \t//解码从Socket收到的数据\n    downstream:frameEncoder,protobufEncoder\t\t\t//编码要通过Socket发送出去的数据\n    ```\n 这里我们假设协议数据的格式为纯protobuf数据格式，不进行如何加密操作，需要注意的一点：**protobufDecoder仅仅负责编码，并不支持读半包**，所以在之前一定要有**读半包的处理器**，即这里用到的frameDecoder，通常用此处理器读取包的数据长度，有三种方式可以选择：\n\t- 使用netty提供的 ``ProtobufVarint32FrameDecoder``；\n\t- 继承netty提供的通用半包处理器 ``LengthFieldBasedFrameDecoder``；\n\t- 继承netty提供的通用半包处理器 ``LengthFieldBasedFrameDecoder``。\n---\n### protobuf数据通信过程：\n####1.客户端创建数据：\n要构建一个protobuf数据，需要通过对应协议文件的数据结构，先通过每个数据类型的newBuilder()方法来创建对应的Builder对象，再对Builder中的属性进行赋值，最后才能使用Builder来build()数据对象，在客户端的自定义handler控制器``SocketClientHandler``中的**channelActive**方法中发送数据（注：当客户端和服务端建立tcp成功之后，Netty的NIO线程会调用channelActive）：\n```java\n@Override\npublic void channelActive(ChannelHandlerContext ctx) {\n\tCSLoginReq.Builder req_builder = CSLoginReq.newBuilder();\n    CSLoginInfo.Builder info_builder = CSLoginInfo.newBuilder();\n    info_builder.setUserName(\"linshuhe\");\n    info_builder.setPassword(\"123456\");\n    CSLoginInfo info = info_builder.build();\n    req_builder.setLoginInfo(info);\n    CSLoginReq req = req_builder.build();\n    ctx.writeAndFlush(req);\n}\n```\n最后，需要将数据对象通过writeAndFlush()发送出去用Socket传输。\n####2.服务器解析数据：\n在服务器自定义的handler控制器``SocketServerHandler``的**ChannelRead**方法中进行数据解析：\n```java\npublic void channelRead(ChannelHandlerContext arg0, Object msg) throws Exception {\n\t// TODO Auto-generated method stub\n\tCSLoginReq clientReq = (CSLoginReq)msg;\n    String user_name = clientReq.getLoginInfo().getUserName();\n    String pass_word = clientReq.getLoginInfo().getPassword();\n    logger.info(\"数据内容：UserName=\"+user_name+\",Password=\"+pass_word);\n}\n```\n####3.执行结果：\n服务器打印输出结果如下：\n![](http://img.blog.csdn.net/20170221133626442)\n\n---\n####备注：\n假如自定义的handler出现接受数据时只执行``channelReadComplete``方法而不执行``ChannelRead``方法，则说明数据发送的格式不对，因为只执行channelReadComplete说明收到消息没有能够被frameDecoder识别的指定的结束标志，例如：frameDecoder设置为lineBasedFrameDecoder时，结束标志为换行符。\n","slug":"《从零开始搭建游戏服务器》使用Protobuf定义网络协议","published":1,"updated":"2017-06-24T02:13:49.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjfle001j9gfjvjbw4cvo","content":"<blockquote>\n<p>引言：<br>之前我们说过使用Protobuff编解码方式来对网络通信数据进行编码，也就是可以用这种方式来定义通信协议，那么具体要怎么做呢？关于此工具的详细资料和使用操作可以参考我之前写过的博客：<a href=\"http://blog.csdn.net/linshuhe1/article/details/51781749\" target=\"_blank\" rel=\"external\">Unity3D —— protobuf网络框架</a></p>\n</blockquote>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><h3 id=\"准备工具：\"><a href=\"#准备工具：\" class=\"headerlink\" title=\"准备工具：\"></a>准备工具：</h3><p>这里我就直接用之前编写的登录案例中的登录协议文件来进行本次案例的测试，工具下载地址如下：<a href=\"http://download.csdn.net/detail/yangheng362/8516923\" target=\"_blank\" rel=\"external\">protobuf-java-2.5.0.zip</a>，主要使用到的文件有：</p>\n<ul>\n<li><strong>protoc.exe</strong>工具：通过此工具将从自定义的协议文件（.proto）得到相应（.java）的Java类文件；</li>\n<li>对应proto.exe版本的<strong>protobuf-java.jar</strong>包，用于解析上面得到的.java类，这里我使用的是2.5.0版本的protobuf；</li>\n<li><p>cs_login.proto协议文件，关于proto协议文件的书写语法详细的可以查看：<a href=\"http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html\" target=\"_blank\" rel=\"external\">Protobuf语言指南</a>，cs_login.proto内容如下（包名package可以根据当前服务器应用的包名进行修改）：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.tw.login.proto;</div><div class=\"line\"></div><div class=\"line\">message CSLoginInfo</div><div class=\"line\">&#123;</div><div class=\"line\">    required string UserName = <span class=\"number\">1</span>;<span class=\"comment\">//账号</span></div><div class=\"line\">    required string Password = <span class=\"number\">2</span>;<span class=\"comment\">//密码</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//发送登录请求</span></div><div class=\"line\">message CSLoginReq</div><div class=\"line\">&#123;</div><div class=\"line\">    required CSLoginInfo LoginInfo = <span class=\"number\">1</span>; </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//登录请求回包数据</span></div><div class=\"line\">message CSLoginRes</div><div class=\"line\">&#123;</div><div class=\"line\">    required uint32 result_code = <span class=\"number\">1</span>; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  cs_enum.proto协议类型枚举文件，用于列举所有协议数据结构的编号：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.tw.login.proto;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">enum</span> EnmCmdID</div><div class=\"line\">&#123;</div><div class=\"line\">    CS_LOGIN_REQ = <span class=\"number\">10001</span>;<span class=\"comment\">//登录请求协议号</span></div><div class=\"line\">    CS_LOGIN_RES = <span class=\"number\">10002</span>;<span class=\"comment\">//登录请求回包协议号</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>将.proto转化为Java类文件的处理脚本，这里其实只是一句命令行指令：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protoc --java_out=(.java输出目录) (.proto文件存放目录)\\cs_login.proto</div></pre></td></tr></table></figure>\n<p>  这里我根据实际项目目录结构定义了一个转文件的.bat批处理文件：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo on</div><div class=\"line\">call protoc --version</div><div class=\"line\"></div><div class=\"line\">call protoc --java_out=..\\src\\ cs_login.proto</div><div class=\"line\">call protoc --java_out=..\\src\\ cs_enum.proto</div><div class=\"line\"></div><div class=\"line\">PAUSE</div></pre></td></tr></table></figure>\n<p>  tool文件夹在当前java工程的根目录下，其下有三种文件：.proto的协议文件、转化文件用的protoc.exe工具和批处理文件general_java.bat：<br>  <img src=\"http://img.blog.csdn.net/20161220205058824\" alt=\"\"></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"在Netty服务器验证：\"><a href=\"#在Netty服务器验证：\" class=\"headerlink\" title=\"在Netty服务器验证：\"></a>在Netty服务器验证：</h3><p>####1. 转化协议：<br>双击打开general_java.bat，转.proto协议得到.java脚本，转化成功现象如下，并且在package指定的目录下生产对应的.java类：<br>    <img src=\"http://img.blog.csdn.net/20161220205533580\" alt=\"\"><br>    <img src=\"http://img.blog.csdn.net/20161220205648112\" alt=\"\"></p>\n<p>####2.修改对通道<strong>ChannelPipeline</strong>中编解码格式的设置：<br> 有一定网络通信协议基础的应该知道（不知道的赶紧补一下）：应用层位于传输层之上，当应用层要从传输层的Socket读取数据时，是从下向上层的传输，也就是<code>Upstream</code>；而反过来，从应用层向传输层的Socket写入并发数据时，则为<code>Downstream</code>。<br> Upstream 和 Downstream 都是在 Pipeline 中“流动”的，所以影响 Upstream 和 Downstream 行为的 UpstreamHandler 和 DownstreamHandler，也要被放到 Pipeline 里。了解了上述这两个概念之后，我们就可以开始修改管道ChannelPipeline的参数，包括：</p>\n<pre><code>- ``frameDecoder``和``protobufDecoder``对应的handler用于解码Protobuf package数据包，他们都是Upstream Handles；\n- ``frameEncoder``和``protobufEncoder``对应的handler用于编码Protobuf package数据包，他们都是Downstream Handles；\n- 此外还有一个handler，是一个自定义的Upstream Handles，**用于开发者从网络数据中解析得到自己所需的数据**。\n</code></pre><p> 添加到Pipeline中的handler其实有特定的执行顺序，例如：<br>    <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">pipeline.addLast(<span class=\"string\">\"frameDecoder\"</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">new</span> ProtobufVarint32FrameDecoder());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"protobufDecoder\"</span>, <span class=\"keyword\">new</span> ProtobufDecoder(CsLogin.CSLoginReq.getDefaultInstance()));</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"frameEncoder\"</span>,<span class=\"keyword\">new</span> ProtobufVarint32LengthFieldPrepender());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"protobufEncoder\"</span>, <span class=\"keyword\">new</span> ProtobufEncoder());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"handler\"</span>,<span class=\"keyword\">new</span> SocketServerHandler());</div></pre></td></tr></table></figure></p>\n<p> 上例的执行顺序为：<br>    <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">upstream:frameDecoder,protobufDecoder,handler \t<span class=\"comment\">//解码从Socket收到的数据</span></div><div class=\"line\">downstream:frameEncoder,protobufEncoder\t\t\t<span class=\"comment\">//编码要通过Socket发送出去的数据</span></div></pre></td></tr></table></figure></p>\n<p> 这里我们假设协议数据的格式为纯protobuf数据格式，不进行如何加密操作，需要注意的一点：<strong>protobufDecoder仅仅负责编码，并不支持读半包</strong>，所以在之前一定要有<strong>读半包的处理器</strong>，即这里用到的frameDecoder，通常用此处理器读取包的数据长度，有三种方式可以选择：</p>\n<pre><code>- 使用netty提供的 ``ProtobufVarint32FrameDecoder``；\n- 继承netty提供的通用半包处理器 ``LengthFieldBasedFrameDecoder``；\n- 继承netty提供的通用半包处理器 ``LengthFieldBasedFrameDecoder``。\n</code></pre><hr>\n<h3 id=\"protobuf数据通信过程：\"><a href=\"#protobuf数据通信过程：\" class=\"headerlink\" title=\"protobuf数据通信过程：\"></a>protobuf数据通信过程：</h3><p>####1.客户端创建数据：<br>要构建一个protobuf数据，需要通过对应协议文件的数据结构，先通过每个数据类型的newBuilder()方法来创建对应的Builder对象，再对Builder中的属性进行赋值，最后才能使用Builder来build()数据对象，在客户端的自定义handler控制器<code>SocketClientHandler</code>中的<strong>channelActive</strong>方法中发送数据（注：当客户端和服务端建立tcp成功之后，Netty的NIO线程会调用channelActive）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class=\"line\">\tCSLoginReq.Builder req_builder = CSLoginReq.newBuilder();</div><div class=\"line\">    CSLoginInfo.Builder info_builder = CSLoginInfo.newBuilder();</div><div class=\"line\">    info_builder.setUserName(<span class=\"string\">\"linshuhe\"</span>);</div><div class=\"line\">    info_builder.setPassword(<span class=\"string\">\"123456\"</span>);</div><div class=\"line\">    CSLoginInfo info = info_builder.build();</div><div class=\"line\">    req_builder.setLoginInfo(info);</div><div class=\"line\">    CSLoginReq req = req_builder.build();</div><div class=\"line\">    ctx.writeAndFlush(req);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后，需要将数据对象通过writeAndFlush()发送出去用Socket传输。</p>\n<p>####2.服务器解析数据：<br>在服务器自定义的handler控制器<code>SocketServerHandler</code>的<strong>ChannelRead</strong>方法中进行数据解析：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead</span><span class=\"params\">(ChannelHandlerContext arg0, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\tCSLoginReq clientReq = (CSLoginReq)msg;</div><div class=\"line\">    String user_name = clientReq.getLoginInfo().getUserName();</div><div class=\"line\">    String pass_word = clientReq.getLoginInfo().getPassword();</div><div class=\"line\">    logger.info(<span class=\"string\">\"数据内容：UserName=\"</span>+user_name+<span class=\"string\">\",Password=\"</span>+pass_word);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>####3.执行结果：<br>服务器打印输出结果如下：<br><img src=\"http://img.blog.csdn.net/20170221133626442\" alt=\"\"></p>\n<hr>\n<p>####备注：<br>假如自定义的handler出现接受数据时只执行<code>channelReadComplete</code>方法而不执行<code>ChannelRead</code>方法，则说明数据发送的格式不对，因为只执行channelReadComplete说明收到消息没有能够被frameDecoder识别的指定的结束标志，例如：frameDecoder设置为lineBasedFrameDecoder时，结束标志为换行符。</p>\n","excerpt":"<blockquote>\n<p>引言：<br>之前我们说过使用Protobuff编解码方式来对网络通信数据进行编码，也就是可以用这种方式来定义通信协议，那么具体要怎么做呢？关于此工具的详细资料和使用操作可以参考我之前写过的博客：<a href=\"http://blog.csdn.net/linshuhe1/article/details/51781749\">Unity3D —— protobuf网络框架</a></p>\n</blockquote>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><h3 id=\"准备工具：\"><a href=\"#准备工具：\" class=\"headerlink\" title=\"准备工具：\"></a>准备工具：</h3><p>这里我就直接用之前编写的登录案例中的登录协议文件来进行本次案例的测试，工具下载地址如下：<a href=\"http://download.csdn.net/detail/yangheng362/8516923\">protobuf-java-2.5.0.zip</a>，主要使用到的文件有：</p>\n<ul>\n<li><strong>protoc.exe</strong>工具：通过此工具将从自定义的协议文件（.proto）得到相应（.java）的Java类文件；</li>\n<li>对应proto.exe版本的<strong>protobuf-java.jar</strong>包，用于解析上面得到的.java类，这里我使用的是2.5.0版本的protobuf；</li>\n<li><p>cs_login.proto协议文件，关于proto协议文件的书写语法详细的可以查看：<a href=\"http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html\">Protobuf语言指南</a>，cs_login.proto内容如下（包名package可以根据当前服务器应用的包名进行修改）：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.tw.login.proto;</div><div class=\"line\"></div><div class=\"line\">message CSLoginInfo</div><div class=\"line\">&#123;</div><div class=\"line\">    required string UserName = <span class=\"number\">1</span>;<span class=\"comment\">//账号</span></div><div class=\"line\">    required string Password = <span class=\"number\">2</span>;<span class=\"comment\">//密码</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//发送登录请求</span></div><div class=\"line\">message CSLoginReq</div><div class=\"line\">&#123;</div><div class=\"line\">    required CSLoginInfo LoginInfo = <span class=\"number\">1</span>; </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//登录请求回包数据</span></div><div class=\"line\">message CSLoginRes</div><div class=\"line\">&#123;</div><div class=\"line\">    required uint32 result_code = <span class=\"number\">1</span>; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  cs_enum.proto协议类型枚举文件，用于列举所有协议数据结构的编号：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.tw.login.proto;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">enum</span> EnmCmdID</div><div class=\"line\">&#123;</div><div class=\"line\">    CS_LOGIN_REQ = <span class=\"number\">10001</span>;<span class=\"comment\">//登录请求协议号</span></div><div class=\"line\">    CS_LOGIN_RES = <span class=\"number\">10002</span>;<span class=\"comment\">//登录请求回包协议号</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>将.proto转化为Java类文件的处理脚本，这里其实只是一句命令行指令：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protoc --java_out=(.java输出目录) (.proto文件存放目录)\\cs_login.proto</div></pre></td></tr></table></figure>\n<p>  这里我根据实际项目目录结构定义了一个转文件的.bat批处理文件：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo on</div><div class=\"line\">call protoc --version</div><div class=\"line\"></div><div class=\"line\">call protoc --java_out=..\\src\\ cs_login.proto</div><div class=\"line\">call protoc --java_out=..\\src\\ cs_enum.proto</div><div class=\"line\"></div><div class=\"line\">PAUSE</div></pre></td></tr></table></figure>\n<p>  tool文件夹在当前java工程的根目录下，其下有三种文件：.proto的协议文件、转化文件用的protoc.exe工具和批处理文件general_java.bat：<br>  <img src=\"http://img.blog.csdn.net/20161220205058824\" alt=\"\"></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"在Netty服务器验证：\"><a href=\"#在Netty服务器验证：\" class=\"headerlink\" title=\"在Netty服务器验证：\"></a>在Netty服务器验证：</h3><p>####1. 转化协议：<br>双击打开general_java.bat，转.proto协议得到.java脚本，转化成功现象如下，并且在package指定的目录下生产对应的.java类：<br>    <img src=\"http://img.blog.csdn.net/20161220205533580\" alt=\"\"><br>    <img src=\"http://img.blog.csdn.net/20161220205648112\" alt=\"\"></p>\n<p>####2.修改对通道<strong>ChannelPipeline</strong>中编解码格式的设置：<br> 有一定网络通信协议基础的应该知道（不知道的赶紧补一下）：应用层位于传输层之上，当应用层要从传输层的Socket读取数据时，是从下向上层的传输，也就是<code>Upstream</code>；而反过来，从应用层向传输层的Socket写入并发数据时，则为<code>Downstream</code>。<br> Upstream 和 Downstream 都是在 Pipeline 中“流动”的，所以影响 Upstream 和 Downstream 行为的 UpstreamHandler 和 DownstreamHandler，也要被放到 Pipeline 里。了解了上述这两个概念之后，我们就可以开始修改管道ChannelPipeline的参数，包括：</p>\n<pre><code>- ``frameDecoder``和``protobufDecoder``对应的handler用于解码Protobuf package数据包，他们都是Upstream Handles；\n- ``frameEncoder``和``protobufEncoder``对应的handler用于编码Protobuf package数据包，他们都是Downstream Handles；\n- 此外还有一个handler，是一个自定义的Upstream Handles，**用于开发者从网络数据中解析得到自己所需的数据**。\n</code></pre><p> 添加到Pipeline中的handler其实有特定的执行顺序，例如：<br>    <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">pipeline.addLast(<span class=\"string\">\"frameDecoder\"</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">new</span> ProtobufVarint32FrameDecoder());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"protobufDecoder\"</span>, <span class=\"keyword\">new</span> ProtobufDecoder(CsLogin.CSLoginReq.getDefaultInstance()));</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"frameEncoder\"</span>,<span class=\"keyword\">new</span> ProtobufVarint32LengthFieldPrepender());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"protobufEncoder\"</span>, <span class=\"keyword\">new</span> ProtobufEncoder());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"handler\"</span>,<span class=\"keyword\">new</span> SocketServerHandler());</div></pre></td></tr></table></figure></p>\n<p> 上例的执行顺序为：<br>    <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">upstream:frameDecoder,protobufDecoder,handler \t<span class=\"comment\">//解码从Socket收到的数据</span></div><div class=\"line\">downstream:frameEncoder,protobufEncoder\t\t\t<span class=\"comment\">//编码要通过Socket发送出去的数据</span></div></pre></td></tr></table></figure></p>\n<p> 这里我们假设协议数据的格式为纯protobuf数据格式，不进行如何加密操作，需要注意的一点：<strong>protobufDecoder仅仅负责编码，并不支持读半包</strong>，所以在之前一定要有<strong>读半包的处理器</strong>，即这里用到的frameDecoder，通常用此处理器读取包的数据长度，有三种方式可以选择：</p>\n<pre><code>- 使用netty提供的 ``ProtobufVarint32FrameDecoder``；\n- 继承netty提供的通用半包处理器 ``LengthFieldBasedFrameDecoder``；\n- 继承netty提供的通用半包处理器 ``LengthFieldBasedFrameDecoder``。\n</code></pre><hr>\n<h3 id=\"protobuf数据通信过程：\"><a href=\"#protobuf数据通信过程：\" class=\"headerlink\" title=\"protobuf数据通信过程：\"></a>protobuf数据通信过程：</h3><p>####1.客户端创建数据：<br>要构建一个protobuf数据，需要通过对应协议文件的数据结构，先通过每个数据类型的newBuilder()方法来创建对应的Builder对象，再对Builder中的属性进行赋值，最后才能使用Builder来build()数据对象，在客户端的自定义handler控制器<code>SocketClientHandler</code>中的<strong>channelActive</strong>方法中发送数据（注：当客户端和服务端建立tcp成功之后，Netty的NIO线程会调用channelActive）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class=\"line\">\tCSLoginReq.Builder req_builder = CSLoginReq.newBuilder();</div><div class=\"line\">    CSLoginInfo.Builder info_builder = CSLoginInfo.newBuilder();</div><div class=\"line\">    info_builder.setUserName(<span class=\"string\">\"linshuhe\"</span>);</div><div class=\"line\">    info_builder.setPassword(<span class=\"string\">\"123456\"</span>);</div><div class=\"line\">    CSLoginInfo info = info_builder.build();</div><div class=\"line\">    req_builder.setLoginInfo(info);</div><div class=\"line\">    CSLoginReq req = req_builder.build();</div><div class=\"line\">    ctx.writeAndFlush(req);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后，需要将数据对象通过writeAndFlush()发送出去用Socket传输。</p>\n<p>####2.服务器解析数据：<br>在服务器自定义的handler控制器<code>SocketServerHandler</code>的<strong>ChannelRead</strong>方法中进行数据解析：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead</span><span class=\"params\">(ChannelHandlerContext arg0, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\tCSLoginReq clientReq = (CSLoginReq)msg;</div><div class=\"line\">    String user_name = clientReq.getLoginInfo().getUserName();</div><div class=\"line\">    String pass_word = clientReq.getLoginInfo().getPassword();</div><div class=\"line\">    logger.info(<span class=\"string\">\"数据内容：UserName=\"</span>+user_name+<span class=\"string\">\",Password=\"</span>+pass_word);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>####3.执行结果：<br>服务器打印输出结果如下：<br><img src=\"http://img.blog.csdn.net/20170221133626442\" alt=\"\"></p>\n<hr>\n<p>####备注：<br>假如自定义的handler出现接受数据时只执行<code>channelReadComplete</code>方法而不执行<code>ChannelRead</code>方法，则说明数据发送的格式不对，因为只执行channelReadComplete说明收到消息没有能够被frameDecoder识别的指定的结束标志，例如：frameDecoder设置为lineBasedFrameDecoder时，结束标志为换行符。</p>"},{"title":"《从零开始搭建游戏服务器》多个Protobuf协议的改造","date":"2017-03-03T02:38:37.000Z","_content":"\n>### 引言\n通过上篇 [《从零开始搭建游戏服务器》使用Protobuf定义网络协议](http://blog.csdn.net/linshuhe1/article/details/56280797) 的实践之后，我们知道在设置ChannelPiple的handler时，只能设置一个解码器，即protobufDecoder，但是在实际的网络通信过程中，我们需要传输的数据类型必然有很多种，这就需要通过某个标识来帮助我们在进行数据解析时进行数据类型的判断。\n\n<!--more-->\n\n### 解决方案：\n#### 方案一\n这是protobuf官方的一种实现方式，通过自定义解析类，将要进行传输的protobuf类型数据都先转换为字节数组，放在一个byte数组里面，定义额外的属性来描述对应的proto文件和协议数据类型，格式如下:\n\n```\nmessage SelfDescribingMessage {\n  // Set of .proto files which define the type.\n  required FileDescriptorSet proto_files = 1;\n\n  // Name of the message type.  Must be defined by one of the files in\n  // proto_files.\n  required string type_name = 2;\n\n  // The message data.\n  required bytes message_data = 3;\n}\n```\n - ##### 优点：\n如此，信道上传输的实际类型就是SelfDescribingMessage类型，由于message_data的兼容性，此数据类型可以承载任何类型的数据。\n - ##### 缺点：\n由于每次传输数据，序列化步骤包括：普通数据类型序列化为protobuf类型，protobuf类型序列化为byte数组，反序列化也是一个逆过程，如此就需要进行两次序列化和两次反序列化，这对于那些对延迟和性能比较敏感的系统，显然不是一个好的选择。\n\n#### 方案二\n直接在protobuf序列化数据的前面，加上一个自定义的协议头，协议头里包含序列数据的长度和对应的数据类型，在数据解包的时候根据包头来进行反序列化。\n\n##### 协议头定义\n关于这一块，我打算先采取比较简单的办法，结构如下：\n![](http://img.blog.csdn.net/20160824100320406)\n协议号是自定义的一个``int``类型的枚举（当然，假如协议吧比较少的话，可以用一个``short``来代替int以缩小数据包），这个协议号与协议类型是一一对应的，而协议头通常使用数据总长度来填入，具体过程如下：\n - 当客户端向服务器发送数据时，会根据协议类型加上协议号，然后使用protobuf序列化之后再发送给服务器；\n - 当服务器发送数据给客户端时，根据协议号，确定protobuf协议类型以反序列化数据，并调用相应回调方法。\n\n这个办法是我之前在C#中尝试过的，具体情况可以参考：[Unity3D —— protobuf网络框架](http://blog.csdn.net/linshuhe1/article/details/51781749)。\n\n##### 自定义的编码器和解码器\n - **编码器**：\n参考netty自带的编码器``ProtobufEncoder``可以发现，被绑定到ChannelPipeline上用于序列化协议数据的编码器，必须继承``MessageToByteEncoder<MessageLite>``这个基类，并通过重写``protected void encode(ChannelHandlerContext ctx, MessageLite msg, ByteBuf out)``这个方法来实现自定义协议格式的目的：\n\n    ```java\n    package com.tw.login.tools;\n\n    import com.google.protobuf.MessageLite;\n    import com.tw.login.proto.CsEnum.EnmCmdID;\n    import com.tw.login.proto.CsLogin;\n\n    import io.netty.buffer.ByteBuf;\n    import io.netty.channel.ChannelHandlerContext;\n    import io.netty.handler.codec.MessageToByteEncoder;\n    /**\n     * 自定义编码器\n     * @author linsh\n     *\n     */\n    public class PackEncoder extends MessageToByteEncoder<MessageLite> {\n\n        /**\n         * 传入协议数据，产生携带包头之后的数据\n         */\n        @Override\n        protected void encode(ChannelHandlerContext ctx, MessageLite msg, ByteBuf out) throws Exception {\n            // TODO Auto-generated method stub\n            byte[] body = msg.toByteArray();\n            byte[] header = encodeHeader(msg, (short)body.length);\n\n            out.writeBytes(header);\n            out.writeBytes(body);\n            return;\n        }\n\n        /**\n         * 获得一个协议头\n         * @param msg\n         * @param bodyLength\n         * @return\n         */\n        private byte[] encodeHeader(MessageLite msg,short bodyLength){\n            short _typeId = 0;\n            if(msg instanceof CsLogin.CSLoginReq){\n                _typeId = EnmCmdID.CS_LOGIN_REQ_VALUE;\n            }else if(msg instanceof CsLogin.CSLoginRes){\n                _typeId = EnmCmdID.CS_LOGIN_RES_VALUE;\n            }\n\t\t\t//存放两个short数据\n            byte[] header = new byte[4];\n            //前两位放数据长度\n            header[0] = (byte) (bodyLength & 0xff);\n            header[1] = (byte) ((bodyLength >> 8) & 0xff);\n            //后两个字段存协议id\n            header[2] = (byte) (_typeId & 0xff);\n            header[3] = (byte) ((_typeId >> 8) & 0xff);\n            return header;\n        }\n    }\n    ```\n\n - **解码器**：\n参考netty自带的编码器``ProtobufDecoder``可以发现，被绑定到ChannelPipeline上用于序列化协议数据的解码器，必须继承``ByteToMessageDecoder``这个基类，并通过重写``protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)``这个方法来实现解析自定义协议格式的目的：\n\n\t```java\n    package com.tw.login.tools;\n\n    import java.util.List;\n\n    import com.google.protobuf.MessageLite;\n    import com.tw.login.proto.CsEnum.EnmCmdID;\n    import com.tw.login.proto.CsLogin.CSLoginReq;\n    import com.tw.login.proto.CsLogin.CSLoginRes;\n\n    import io.netty.buffer.ByteBuf;\n    import io.netty.channel.ChannelHandlerContext;\n    import io.netty.handler.codec.ByteToMessageDecoder;\n\n    public class PackDecoder extends ByteToMessageDecoder {\n\n        @Override\n        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n            // 获取包头中的body长度\n            byte low = in.readByte();\n            byte high = in.readByte();\n            short s0 = (short) (low & 0xff);\n            short s1 = (short) (high & 0xff);\n            s1 <<= 8;\n            short length = (short) (s0 | s1);\n\n            // 获取包头中的protobuf类型\n            byte low_type = in.readByte();\n            byte high_type = in.readByte();\n            short s0_type = (short) (low_type & 0xff);\n            short s1_type = (short) (high_type & 0xff);\n            s1_type <<= 8;\n            short dataTypeId = (short) (s0_type | s1_type);\n\n            // 如果可读长度小于body长度，恢复读指针，退出。\n            if (in.readableBytes() < length) {\n                in.resetReaderIndex();\n                return;\n            }\n\n            //开始读取核心protobuf数据\n            ByteBuf bodyByteBuf = in.readBytes(length);\n            byte[] array;\n            //反序列化数据的起始点\n            int offset;\n            //可读的数据字节长度\n            int readableLen= bodyByteBuf.readableBytes();\n            //分为包含数组数据和不包含数组数据两种形式\n            if (bodyByteBuf.hasArray()) {\n                array = bodyByteBuf.array();\n                offset = bodyByteBuf.arrayOffset() + bodyByteBuf.readerIndex();\n            } else {\n                array = new byte[readableLen];\n                bodyByteBuf.getBytes(bodyByteBuf.readerIndex(), array, 0, readableLen);\n                offset = 0;\n            }\n\n            //反序列化\n            MessageLite result = decodeBody(dataTypeId, array, offset, readableLen);\n            out.add(result);\n        }\n\n        /**\n         * 根据协议号用响应的protobuf类型来解析协议数据\n         * @param _typeId\n         * @param array\n         * @param offset\n         * @param length\n         * @return\n         * @throws Exception\n         */\n        public MessageLite decodeBody(int _typeId,byte[] array,int offset,int length) throws Exception{\n            if(_typeId == EnmCmdID.CS_LOGIN_REQ_VALUE){\n                return CSLoginReq.getDefaultInstance().getParserForType().parseFrom(array,offset,length);\n            }\n            else if(_typeId == EnmCmdID.CS_LOGIN_RES_VALUE){\n                return CSLoginRes.getDefaultInstance().getParserForType().parseFrom(array,offset,length);\n            }\n            return null;\n        }\n    }\n    ```\n    \n#### 修改Socket管道绑定的编解码器：\n在创建Socket管道的时候，将编解码器替换为自定义的编解码器，而具体数据发送和接受过程无需做任何修改：\n```java\nChannelPipeline pipeline = ch.pipeline();\n// 协议数据的编解码器\npipeline.addLast(\"frameDecoder\",new ProtobufVarint32FrameDecoder());\npipeline.addLast(\"protobufDecoder\",new PackDecoder());\npipeline.addLast(\"frameEncoder\",new ProtobufVarint32LengthFieldPrepender());\npipeline.addLast(\"protobufEncoder\", new PackEncoder());\npipeline.addLast(\"handler\",new SocketServerHandler());\n```","source":"_posts/《从零开始搭建游戏服务器》多个Protobuf协议的改造.md","raw":"---\ntitle: 《从零开始搭建游戏服务器》多个Protobuf协议的改造\ndate: 2017-03-03 10:38:37\ntags: Java,Protobuf\ncategories: 服务器开发\n---\n\n>### 引言\n通过上篇 [《从零开始搭建游戏服务器》使用Protobuf定义网络协议](http://blog.csdn.net/linshuhe1/article/details/56280797) 的实践之后，我们知道在设置ChannelPiple的handler时，只能设置一个解码器，即protobufDecoder，但是在实际的网络通信过程中，我们需要传输的数据类型必然有很多种，这就需要通过某个标识来帮助我们在进行数据解析时进行数据类型的判断。\n\n<!--more-->\n\n### 解决方案：\n#### 方案一\n这是protobuf官方的一种实现方式，通过自定义解析类，将要进行传输的protobuf类型数据都先转换为字节数组，放在一个byte数组里面，定义额外的属性来描述对应的proto文件和协议数据类型，格式如下:\n\n```\nmessage SelfDescribingMessage {\n  // Set of .proto files which define the type.\n  required FileDescriptorSet proto_files = 1;\n\n  // Name of the message type.  Must be defined by one of the files in\n  // proto_files.\n  required string type_name = 2;\n\n  // The message data.\n  required bytes message_data = 3;\n}\n```\n - ##### 优点：\n如此，信道上传输的实际类型就是SelfDescribingMessage类型，由于message_data的兼容性，此数据类型可以承载任何类型的数据。\n - ##### 缺点：\n由于每次传输数据，序列化步骤包括：普通数据类型序列化为protobuf类型，protobuf类型序列化为byte数组，反序列化也是一个逆过程，如此就需要进行两次序列化和两次反序列化，这对于那些对延迟和性能比较敏感的系统，显然不是一个好的选择。\n\n#### 方案二\n直接在protobuf序列化数据的前面，加上一个自定义的协议头，协议头里包含序列数据的长度和对应的数据类型，在数据解包的时候根据包头来进行反序列化。\n\n##### 协议头定义\n关于这一块，我打算先采取比较简单的办法，结构如下：\n![](http://img.blog.csdn.net/20160824100320406)\n协议号是自定义的一个``int``类型的枚举（当然，假如协议吧比较少的话，可以用一个``short``来代替int以缩小数据包），这个协议号与协议类型是一一对应的，而协议头通常使用数据总长度来填入，具体过程如下：\n - 当客户端向服务器发送数据时，会根据协议类型加上协议号，然后使用protobuf序列化之后再发送给服务器；\n - 当服务器发送数据给客户端时，根据协议号，确定protobuf协议类型以反序列化数据，并调用相应回调方法。\n\n这个办法是我之前在C#中尝试过的，具体情况可以参考：[Unity3D —— protobuf网络框架](http://blog.csdn.net/linshuhe1/article/details/51781749)。\n\n##### 自定义的编码器和解码器\n - **编码器**：\n参考netty自带的编码器``ProtobufEncoder``可以发现，被绑定到ChannelPipeline上用于序列化协议数据的编码器，必须继承``MessageToByteEncoder<MessageLite>``这个基类，并通过重写``protected void encode(ChannelHandlerContext ctx, MessageLite msg, ByteBuf out)``这个方法来实现自定义协议格式的目的：\n\n    ```java\n    package com.tw.login.tools;\n\n    import com.google.protobuf.MessageLite;\n    import com.tw.login.proto.CsEnum.EnmCmdID;\n    import com.tw.login.proto.CsLogin;\n\n    import io.netty.buffer.ByteBuf;\n    import io.netty.channel.ChannelHandlerContext;\n    import io.netty.handler.codec.MessageToByteEncoder;\n    /**\n     * 自定义编码器\n     * @author linsh\n     *\n     */\n    public class PackEncoder extends MessageToByteEncoder<MessageLite> {\n\n        /**\n         * 传入协议数据，产生携带包头之后的数据\n         */\n        @Override\n        protected void encode(ChannelHandlerContext ctx, MessageLite msg, ByteBuf out) throws Exception {\n            // TODO Auto-generated method stub\n            byte[] body = msg.toByteArray();\n            byte[] header = encodeHeader(msg, (short)body.length);\n\n            out.writeBytes(header);\n            out.writeBytes(body);\n            return;\n        }\n\n        /**\n         * 获得一个协议头\n         * @param msg\n         * @param bodyLength\n         * @return\n         */\n        private byte[] encodeHeader(MessageLite msg,short bodyLength){\n            short _typeId = 0;\n            if(msg instanceof CsLogin.CSLoginReq){\n                _typeId = EnmCmdID.CS_LOGIN_REQ_VALUE;\n            }else if(msg instanceof CsLogin.CSLoginRes){\n                _typeId = EnmCmdID.CS_LOGIN_RES_VALUE;\n            }\n\t\t\t//存放两个short数据\n            byte[] header = new byte[4];\n            //前两位放数据长度\n            header[0] = (byte) (bodyLength & 0xff);\n            header[1] = (byte) ((bodyLength >> 8) & 0xff);\n            //后两个字段存协议id\n            header[2] = (byte) (_typeId & 0xff);\n            header[3] = (byte) ((_typeId >> 8) & 0xff);\n            return header;\n        }\n    }\n    ```\n\n - **解码器**：\n参考netty自带的编码器``ProtobufDecoder``可以发现，被绑定到ChannelPipeline上用于序列化协议数据的解码器，必须继承``ByteToMessageDecoder``这个基类，并通过重写``protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)``这个方法来实现解析自定义协议格式的目的：\n\n\t```java\n    package com.tw.login.tools;\n\n    import java.util.List;\n\n    import com.google.protobuf.MessageLite;\n    import com.tw.login.proto.CsEnum.EnmCmdID;\n    import com.tw.login.proto.CsLogin.CSLoginReq;\n    import com.tw.login.proto.CsLogin.CSLoginRes;\n\n    import io.netty.buffer.ByteBuf;\n    import io.netty.channel.ChannelHandlerContext;\n    import io.netty.handler.codec.ByteToMessageDecoder;\n\n    public class PackDecoder extends ByteToMessageDecoder {\n\n        @Override\n        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n            // 获取包头中的body长度\n            byte low = in.readByte();\n            byte high = in.readByte();\n            short s0 = (short) (low & 0xff);\n            short s1 = (short) (high & 0xff);\n            s1 <<= 8;\n            short length = (short) (s0 | s1);\n\n            // 获取包头中的protobuf类型\n            byte low_type = in.readByte();\n            byte high_type = in.readByte();\n            short s0_type = (short) (low_type & 0xff);\n            short s1_type = (short) (high_type & 0xff);\n            s1_type <<= 8;\n            short dataTypeId = (short) (s0_type | s1_type);\n\n            // 如果可读长度小于body长度，恢复读指针，退出。\n            if (in.readableBytes() < length) {\n                in.resetReaderIndex();\n                return;\n            }\n\n            //开始读取核心protobuf数据\n            ByteBuf bodyByteBuf = in.readBytes(length);\n            byte[] array;\n            //反序列化数据的起始点\n            int offset;\n            //可读的数据字节长度\n            int readableLen= bodyByteBuf.readableBytes();\n            //分为包含数组数据和不包含数组数据两种形式\n            if (bodyByteBuf.hasArray()) {\n                array = bodyByteBuf.array();\n                offset = bodyByteBuf.arrayOffset() + bodyByteBuf.readerIndex();\n            } else {\n                array = new byte[readableLen];\n                bodyByteBuf.getBytes(bodyByteBuf.readerIndex(), array, 0, readableLen);\n                offset = 0;\n            }\n\n            //反序列化\n            MessageLite result = decodeBody(dataTypeId, array, offset, readableLen);\n            out.add(result);\n        }\n\n        /**\n         * 根据协议号用响应的protobuf类型来解析协议数据\n         * @param _typeId\n         * @param array\n         * @param offset\n         * @param length\n         * @return\n         * @throws Exception\n         */\n        public MessageLite decodeBody(int _typeId,byte[] array,int offset,int length) throws Exception{\n            if(_typeId == EnmCmdID.CS_LOGIN_REQ_VALUE){\n                return CSLoginReq.getDefaultInstance().getParserForType().parseFrom(array,offset,length);\n            }\n            else if(_typeId == EnmCmdID.CS_LOGIN_RES_VALUE){\n                return CSLoginRes.getDefaultInstance().getParserForType().parseFrom(array,offset,length);\n            }\n            return null;\n        }\n    }\n    ```\n    \n#### 修改Socket管道绑定的编解码器：\n在创建Socket管道的时候，将编解码器替换为自定义的编解码器，而具体数据发送和接受过程无需做任何修改：\n```java\nChannelPipeline pipeline = ch.pipeline();\n// 协议数据的编解码器\npipeline.addLast(\"frameDecoder\",new ProtobufVarint32FrameDecoder());\npipeline.addLast(\"protobufDecoder\",new PackDecoder());\npipeline.addLast(\"frameEncoder\",new ProtobufVarint32LengthFieldPrepender());\npipeline.addLast(\"protobufEncoder\", new PackEncoder());\npipeline.addLast(\"handler\",new SocketServerHandler());\n```","slug":"《从零开始搭建游戏服务器》多个Protobuf协议的改造","published":1,"updated":"2017-06-24T02:13:49.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4anjflh001m9gfj2nh2l358","content":"<blockquote>\n<h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>通过上篇 <a href=\"http://blog.csdn.net/linshuhe1/article/details/56280797\" target=\"_blank\" rel=\"external\">《从零开始搭建游戏服务器》使用Protobuf定义网络协议</a> 的实践之后，我们知道在设置ChannelPiple的handler时，只能设置一个解码器，即protobufDecoder，但是在实际的网络通信过程中，我们需要传输的数据类型必然有很多种，这就需要通过某个标识来帮助我们在进行数据解析时进行数据类型的判断。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><h4 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h4><p>这是protobuf官方的一种实现方式，通过自定义解析类，将要进行传输的protobuf类型数据都先转换为字节数组，放在一个byte数组里面，定义额外的属性来描述对应的proto文件和协议数据类型，格式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">message SelfDescribingMessage &#123;</div><div class=\"line\">  // Set of .proto files which define the type.</div><div class=\"line\">  required FileDescriptorSet proto_files = 1;</div><div class=\"line\"></div><div class=\"line\">  // Name of the message type.  Must be defined by one of the files in</div><div class=\"line\">  // proto_files.</div><div class=\"line\">  required string type_name = 2;</div><div class=\"line\"></div><div class=\"line\">  // The message data.</div><div class=\"line\">  required bytes message_data = 3;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h5 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h5>如此，信道上传输的实际类型就是SelfDescribingMessage类型，由于message_data的兼容性，此数据类型可以承载任何类型的数据。</li>\n<li><h5 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h5>由于每次传输数据，序列化步骤包括：普通数据类型序列化为protobuf类型，protobuf类型序列化为byte数组，反序列化也是一个逆过程，如此就需要进行两次序列化和两次反序列化，这对于那些对延迟和性能比较敏感的系统，显然不是一个好的选择。</li>\n</ul>\n<h4 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h4><p>直接在protobuf序列化数据的前面，加上一个自定义的协议头，协议头里包含序列数据的长度和对应的数据类型，在数据解包的时候根据包头来进行反序列化。</p>\n<h5 id=\"协议头定义\"><a href=\"#协议头定义\" class=\"headerlink\" title=\"协议头定义\"></a>协议头定义</h5><p>关于这一块，我打算先采取比较简单的办法，结构如下：<br><img src=\"http://img.blog.csdn.net/20160824100320406\" alt=\"\"><br>协议号是自定义的一个<code>int</code>类型的枚举（当然，假如协议吧比较少的话，可以用一个<code>short</code>来代替int以缩小数据包），这个协议号与协议类型是一一对应的，而协议头通常使用数据总长度来填入，具体过程如下：</p>\n<ul>\n<li>当客户端向服务器发送数据时，会根据协议类型加上协议号，然后使用protobuf序列化之后再发送给服务器；</li>\n<li>当服务器发送数据给客户端时，根据协议号，确定protobuf协议类型以反序列化数据，并调用相应回调方法。</li>\n</ul>\n<p>这个办法是我之前在C#中尝试过的，具体情况可以参考：<a href=\"http://blog.csdn.net/linshuhe1/article/details/51781749\" target=\"_blank\" rel=\"external\">Unity3D —— protobuf网络框架</a>。</p>\n<h5 id=\"自定义的编码器和解码器\"><a href=\"#自定义的编码器和解码器\" class=\"headerlink\" title=\"自定义的编码器和解码器\"></a>自定义的编码器和解码器</h5><ul>\n<li><p><strong>编码器</strong>：<br>参考netty自带的编码器<code>ProtobufEncoder</code>可以发现，被绑定到ChannelPipeline上用于序列化协议数据的编码器，必须继承<code>MessageToByteEncoder&lt;MessageLite&gt;</code>这个基类，并通过重写<code>protected void encode(ChannelHandlerContext ctx, MessageLite msg, ByteBuf out)</code>这个方法来实现自定义协议格式的目的：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">package</span> com.tw.login.tools;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">import</span> com.google.protobuf.MessageLite;</div><div class=\"line\"> <span class=\"keyword\">import</span> com.tw.login.proto.CsEnum.EnmCmdID;</div><div class=\"line\"> <span class=\"keyword\">import</span> com.tw.login.proto.CsLogin;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</div><div class=\"line\"> <span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</div><div class=\"line\"> <span class=\"keyword\">import</span> io.netty.handler.codec.MessageToByteEncoder;</div><div class=\"line\"> <span class=\"comment\">/**</span></div><div class=\"line\">  * 自定义编码器</div><div class=\"line\">  * <span class=\"doctag\">@author</span> linsh</div><div class=\"line\">  *</div><div class=\"line\">  */</div><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PackEncoder</span> <span class=\"keyword\">extends</span> <span class=\"title\">MessageToByteEncoder</span>&lt;<span class=\"title\">MessageLite</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">/**</span></div><div class=\"line\">      * 传入协议数据，产生携带包头之后的数据</div><div class=\"line\">      */</div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(ChannelHandlerContext ctx, MessageLite msg, ByteBuf out)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">         <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">         <span class=\"keyword\">byte</span>[] body = msg.toByteArray();</div><div class=\"line\">         <span class=\"keyword\">byte</span>[] header = encodeHeader(msg, (<span class=\"keyword\">short</span>)body.length);</div><div class=\"line\"></div><div class=\"line\">         out.writeBytes(header);</div><div class=\"line\">         out.writeBytes(body);</div><div class=\"line\">         <span class=\"keyword\">return</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">/**</span></div><div class=\"line\">      * 获得一个协议头</div><div class=\"line\">      * <span class=\"doctag\">@param</span> msg</div><div class=\"line\">      * <span class=\"doctag\">@param</span> bodyLength</div><div class=\"line\">      * <span class=\"doctag\">@return</span></div><div class=\"line\">      */</div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] encodeHeader(MessageLite msg,<span class=\"keyword\">short</span> bodyLength)&#123;</div><div class=\"line\">         <span class=\"keyword\">short</span> _typeId = <span class=\"number\">0</span>;</div><div class=\"line\">         <span class=\"keyword\">if</span>(msg <span class=\"keyword\">instanceof</span> CsLogin.CSLoginReq)&#123;</div><div class=\"line\">             _typeId = EnmCmdID.CS_LOGIN_REQ_VALUE;</div><div class=\"line\">         &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(msg <span class=\"keyword\">instanceof</span> CsLogin.CSLoginRes)&#123;</div><div class=\"line\">             _typeId = EnmCmdID.CS_LOGIN_RES_VALUE;</div><div class=\"line\">         &#125;</div><div class=\"line\"><span class=\"comment\">//存放两个short数据</span></div><div class=\"line\">         <span class=\"keyword\">byte</span>[] header = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">4</span>];</div><div class=\"line\">         <span class=\"comment\">//前两位放数据长度</span></div><div class=\"line\">         header[<span class=\"number\">0</span>] = (<span class=\"keyword\">byte</span>) (bodyLength &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">         header[<span class=\"number\">1</span>] = (<span class=\"keyword\">byte</span>) ((bodyLength &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">         <span class=\"comment\">//后两个字段存协议id</span></div><div class=\"line\">         header[<span class=\"number\">2</span>] = (<span class=\"keyword\">byte</span>) (_typeId &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">         header[<span class=\"number\">3</span>] = (<span class=\"keyword\">byte</span>) ((_typeId &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">         <span class=\"keyword\">return</span> header;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>解码器</strong>：<br>参考netty自带的编码器<code>ProtobufDecoder</code>可以发现，被绑定到ChannelPipeline上用于序列化协议数据的解码器，必须继承<code>ByteToMessageDecoder</code>这个基类，并通过重写<code>protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code>这个方法来实现解析自定义协议格式的目的：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.tw.login.tools;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.google.protobuf.MessageLite;</div><div class=\"line\"><span class=\"keyword\">import</span> com.tw.login.proto.CsEnum.EnmCmdID;</div><div class=\"line\"><span class=\"keyword\">import</span> com.tw.login.proto.CsLogin.CSLoginReq;</div><div class=\"line\"><span class=\"keyword\">import</span> com.tw.login.proto.CsLogin.CSLoginRes;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</div><div class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</div><div class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.ByteToMessageDecoder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PackDecoder</span> <span class=\"keyword\">extends</span> <span class=\"title\">ByteToMessageDecoder</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 获取包头中的body长度</span></div><div class=\"line\">        <span class=\"keyword\">byte</span> low = in.readByte();</div><div class=\"line\">        <span class=\"keyword\">byte</span> high = in.readByte();</div><div class=\"line\">        <span class=\"keyword\">short</span> s0 = (<span class=\"keyword\">short</span>) (low &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">        <span class=\"keyword\">short</span> s1 = (<span class=\"keyword\">short</span>) (high &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">        s1 &lt;&lt;= <span class=\"number\">8</span>;</div><div class=\"line\">        <span class=\"keyword\">short</span> length = (<span class=\"keyword\">short</span>) (s0 | s1);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 获取包头中的protobuf类型</span></div><div class=\"line\">        <span class=\"keyword\">byte</span> low_type = in.readByte();</div><div class=\"line\">        <span class=\"keyword\">byte</span> high_type = in.readByte();</div><div class=\"line\">        <span class=\"keyword\">short</span> s0_type = (<span class=\"keyword\">short</span>) (low_type &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">        <span class=\"keyword\">short</span> s1_type = (<span class=\"keyword\">short</span>) (high_type &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">        s1_type &lt;&lt;= <span class=\"number\">8</span>;</div><div class=\"line\">        <span class=\"keyword\">short</span> dataTypeId = (<span class=\"keyword\">short</span>) (s0_type | s1_type);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果可读长度小于body长度，恢复读指针，退出。</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (in.readableBytes() &lt; length) &#123;</div><div class=\"line\">            in.resetReaderIndex();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//开始读取核心protobuf数据</span></div><div class=\"line\">        ByteBuf bodyByteBuf = in.readBytes(length);</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] array;</div><div class=\"line\">        <span class=\"comment\">//反序列化数据的起始点</span></div><div class=\"line\">        <span class=\"keyword\">int</span> offset;</div><div class=\"line\">        <span class=\"comment\">//可读的数据字节长度</span></div><div class=\"line\">        <span class=\"keyword\">int</span> readableLen= bodyByteBuf.readableBytes();</div><div class=\"line\">        <span class=\"comment\">//分为包含数组数据和不包含数组数据两种形式</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (bodyByteBuf.hasArray()) &#123;</div><div class=\"line\">            array = bodyByteBuf.array();</div><div class=\"line\">            offset = bodyByteBuf.arrayOffset() + bodyByteBuf.readerIndex();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            array = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readableLen];</div><div class=\"line\">            bodyByteBuf.getBytes(bodyByteBuf.readerIndex(), array, <span class=\"number\">0</span>, readableLen);</div><div class=\"line\">            offset = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//反序列化</span></div><div class=\"line\">        MessageLite result = decodeBody(dataTypeId, array, offset, readableLen);</div><div class=\"line\">        out.add(result);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 根据协议号用响应的protobuf类型来解析协议数据</div><div class=\"line\">     * <span class=\"doctag\">@param</span> _typeId</div><div class=\"line\">     * <span class=\"doctag\">@param</span> array</div><div class=\"line\">     * <span class=\"doctag\">@param</span> offset</div><div class=\"line\">     * <span class=\"doctag\">@param</span> length</div><div class=\"line\">     * <span class=\"doctag\">@return</span></div><div class=\"line\">     * <span class=\"doctag\">@throws</span> Exception</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MessageLite <span class=\"title\">decodeBody</span><span class=\"params\">(<span class=\"keyword\">int</span> _typeId,<span class=\"keyword\">byte</span>[] array,<span class=\"keyword\">int</span> offset,<span class=\"keyword\">int</span> length)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(_typeId == EnmCmdID.CS_LOGIN_REQ_VALUE)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> CSLoginReq.getDefaultInstance().getParserForType().parseFrom(array,offset,length);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(_typeId == EnmCmdID.CS_LOGIN_RES_VALUE)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> CSLoginRes.getDefaultInstance().getParserForType().parseFrom(array,offset,length);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"修改Socket管道绑定的编解码器：\"><a href=\"#修改Socket管道绑定的编解码器：\" class=\"headerlink\" title=\"修改Socket管道绑定的编解码器：\"></a>修改Socket管道绑定的编解码器：</h4><p>在创建Socket管道的时候，将编解码器替换为自定义的编解码器，而具体数据发送和接受过程无需做任何修改：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\"><span class=\"comment\">// 协议数据的编解码器</span></div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"frameDecoder\"</span>,<span class=\"keyword\">new</span> ProtobufVarint32FrameDecoder());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"protobufDecoder\"</span>,<span class=\"keyword\">new</span> PackDecoder());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"frameEncoder\"</span>,<span class=\"keyword\">new</span> ProtobufVarint32LengthFieldPrepender());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"protobufEncoder\"</span>, <span class=\"keyword\">new</span> PackEncoder());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"handler\"</span>,<span class=\"keyword\">new</span> SocketServerHandler());</div></pre></td></tr></table></figure></p>\n","excerpt":"<blockquote>\n<h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>通过上篇 <a href=\"http://blog.csdn.net/linshuhe1/article/details/56280797\">《从零开始搭建游戏服务器》使用Protobuf定义网络协议</a> 的实践之后，我们知道在设置ChannelPiple的handler时，只能设置一个解码器，即protobufDecoder，但是在实际的网络通信过程中，我们需要传输的数据类型必然有很多种，这就需要通过某个标识来帮助我们在进行数据解析时进行数据类型的判断。</p>\n</blockquote>","more":"<h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><h4 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h4><p>这是protobuf官方的一种实现方式，通过自定义解析类，将要进行传输的protobuf类型数据都先转换为字节数组，放在一个byte数组里面，定义额外的属性来描述对应的proto文件和协议数据类型，格式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">message SelfDescribingMessage &#123;</div><div class=\"line\">  // Set of .proto files which define the type.</div><div class=\"line\">  required FileDescriptorSet proto_files = 1;</div><div class=\"line\"></div><div class=\"line\">  // Name of the message type.  Must be defined by one of the files in</div><div class=\"line\">  // proto_files.</div><div class=\"line\">  required string type_name = 2;</div><div class=\"line\"></div><div class=\"line\">  // The message data.</div><div class=\"line\">  required bytes message_data = 3;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h5 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h5>如此，信道上传输的实际类型就是SelfDescribingMessage类型，由于message_data的兼容性，此数据类型可以承载任何类型的数据。</li>\n<li><h5 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h5>由于每次传输数据，序列化步骤包括：普通数据类型序列化为protobuf类型，protobuf类型序列化为byte数组，反序列化也是一个逆过程，如此就需要进行两次序列化和两次反序列化，这对于那些对延迟和性能比较敏感的系统，显然不是一个好的选择。</li>\n</ul>\n<h4 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h4><p>直接在protobuf序列化数据的前面，加上一个自定义的协议头，协议头里包含序列数据的长度和对应的数据类型，在数据解包的时候根据包头来进行反序列化。</p>\n<h5 id=\"协议头定义\"><a href=\"#协议头定义\" class=\"headerlink\" title=\"协议头定义\"></a>协议头定义</h5><p>关于这一块，我打算先采取比较简单的办法，结构如下：<br><img src=\"http://img.blog.csdn.net/20160824100320406\" alt=\"\"><br>协议号是自定义的一个<code>int</code>类型的枚举（当然，假如协议吧比较少的话，可以用一个<code>short</code>来代替int以缩小数据包），这个协议号与协议类型是一一对应的，而协议头通常使用数据总长度来填入，具体过程如下：</p>\n<ul>\n<li>当客户端向服务器发送数据时，会根据协议类型加上协议号，然后使用protobuf序列化之后再发送给服务器；</li>\n<li>当服务器发送数据给客户端时，根据协议号，确定protobuf协议类型以反序列化数据，并调用相应回调方法。</li>\n</ul>\n<p>这个办法是我之前在C#中尝试过的，具体情况可以参考：<a href=\"http://blog.csdn.net/linshuhe1/article/details/51781749\">Unity3D —— protobuf网络框架</a>。</p>\n<h5 id=\"自定义的编码器和解码器\"><a href=\"#自定义的编码器和解码器\" class=\"headerlink\" title=\"自定义的编码器和解码器\"></a>自定义的编码器和解码器</h5><ul>\n<li><p><strong>编码器</strong>：<br>参考netty自带的编码器<code>ProtobufEncoder</code>可以发现，被绑定到ChannelPipeline上用于序列化协议数据的编码器，必须继承<code>MessageToByteEncoder&lt;MessageLite&gt;</code>这个基类，并通过重写<code>protected void encode(ChannelHandlerContext ctx, MessageLite msg, ByteBuf out)</code>这个方法来实现自定义协议格式的目的：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">package</span> com.tw.login.tools;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">import</span> com.google.protobuf.MessageLite;</div><div class=\"line\"> <span class=\"keyword\">import</span> com.tw.login.proto.CsEnum.EnmCmdID;</div><div class=\"line\"> <span class=\"keyword\">import</span> com.tw.login.proto.CsLogin;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</div><div class=\"line\"> <span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</div><div class=\"line\"> <span class=\"keyword\">import</span> io.netty.handler.codec.MessageToByteEncoder;</div><div class=\"line\"> <span class=\"comment\">/**</div><div class=\"line\">  * 自定义编码器</div><div class=\"line\">  * <span class=\"doctag\">@author</span> linsh</div><div class=\"line\">  *</div><div class=\"line\">  */</span></div><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PackEncoder</span> <span class=\"keyword\">extends</span> <span class=\"title\">MessageToByteEncoder</span>&lt;<span class=\"title\">MessageLite</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">/**</div><div class=\"line\">      * 传入协议数据，产生携带包头之后的数据</div><div class=\"line\">      */</span></div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(ChannelHandlerContext ctx, MessageLite msg, ByteBuf out)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">         <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">         <span class=\"keyword\">byte</span>[] body = msg.toByteArray();</div><div class=\"line\">         <span class=\"keyword\">byte</span>[] header = encodeHeader(msg, (<span class=\"keyword\">short</span>)body.length);</div><div class=\"line\"></div><div class=\"line\">         out.writeBytes(header);</div><div class=\"line\">         out.writeBytes(body);</div><div class=\"line\">         <span class=\"keyword\">return</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">/**</div><div class=\"line\">      * 获得一个协议头</div><div class=\"line\">      * <span class=\"doctag\">@param</span> msg</div><div class=\"line\">      * <span class=\"doctag\">@param</span> bodyLength</div><div class=\"line\">      * <span class=\"doctag\">@return</span></div><div class=\"line\">      */</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] encodeHeader(MessageLite msg,<span class=\"keyword\">short</span> bodyLength)&#123;</div><div class=\"line\">         <span class=\"keyword\">short</span> _typeId = <span class=\"number\">0</span>;</div><div class=\"line\">         <span class=\"keyword\">if</span>(msg <span class=\"keyword\">instanceof</span> CsLogin.CSLoginReq)&#123;</div><div class=\"line\">             _typeId = EnmCmdID.CS_LOGIN_REQ_VALUE;</div><div class=\"line\">         &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(msg <span class=\"keyword\">instanceof</span> CsLogin.CSLoginRes)&#123;</div><div class=\"line\">             _typeId = EnmCmdID.CS_LOGIN_RES_VALUE;</div><div class=\"line\">         &#125;</div><div class=\"line\"><span class=\"comment\">//存放两个short数据</span></div><div class=\"line\">         <span class=\"keyword\">byte</span>[] header = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">4</span>];</div><div class=\"line\">         <span class=\"comment\">//前两位放数据长度</span></div><div class=\"line\">         header[<span class=\"number\">0</span>] = (<span class=\"keyword\">byte</span>) (bodyLength &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">         header[<span class=\"number\">1</span>] = (<span class=\"keyword\">byte</span>) ((bodyLength &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">         <span class=\"comment\">//后两个字段存协议id</span></div><div class=\"line\">         header[<span class=\"number\">2</span>] = (<span class=\"keyword\">byte</span>) (_typeId &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">         header[<span class=\"number\">3</span>] = (<span class=\"keyword\">byte</span>) ((_typeId &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">         <span class=\"keyword\">return</span> header;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>解码器</strong>：<br>参考netty自带的编码器<code>ProtobufDecoder</code>可以发现，被绑定到ChannelPipeline上用于序列化协议数据的解码器，必须继承<code>ByteToMessageDecoder</code>这个基类，并通过重写<code>protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code>这个方法来实现解析自定义协议格式的目的：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.tw.login.tools;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.google.protobuf.MessageLite;</div><div class=\"line\"><span class=\"keyword\">import</span> com.tw.login.proto.CsEnum.EnmCmdID;</div><div class=\"line\"><span class=\"keyword\">import</span> com.tw.login.proto.CsLogin.CSLoginReq;</div><div class=\"line\"><span class=\"keyword\">import</span> com.tw.login.proto.CsLogin.CSLoginRes;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</div><div class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</div><div class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.ByteToMessageDecoder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PackDecoder</span> <span class=\"keyword\">extends</span> <span class=\"title\">ByteToMessageDecoder</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 获取包头中的body长度</span></div><div class=\"line\">        <span class=\"keyword\">byte</span> low = in.readByte();</div><div class=\"line\">        <span class=\"keyword\">byte</span> high = in.readByte();</div><div class=\"line\">        <span class=\"keyword\">short</span> s0 = (<span class=\"keyword\">short</span>) (low &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">        <span class=\"keyword\">short</span> s1 = (<span class=\"keyword\">short</span>) (high &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">        s1 &lt;&lt;= <span class=\"number\">8</span>;</div><div class=\"line\">        <span class=\"keyword\">short</span> length = (<span class=\"keyword\">short</span>) (s0 | s1);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 获取包头中的protobuf类型</span></div><div class=\"line\">        <span class=\"keyword\">byte</span> low_type = in.readByte();</div><div class=\"line\">        <span class=\"keyword\">byte</span> high_type = in.readByte();</div><div class=\"line\">        <span class=\"keyword\">short</span> s0_type = (<span class=\"keyword\">short</span>) (low_type &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">        <span class=\"keyword\">short</span> s1_type = (<span class=\"keyword\">short</span>) (high_type &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">        s1_type &lt;&lt;= <span class=\"number\">8</span>;</div><div class=\"line\">        <span class=\"keyword\">short</span> dataTypeId = (<span class=\"keyword\">short</span>) (s0_type | s1_type);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果可读长度小于body长度，恢复读指针，退出。</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (in.readableBytes() &lt; length) &#123;</div><div class=\"line\">            in.resetReaderIndex();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//开始读取核心protobuf数据</span></div><div class=\"line\">        ByteBuf bodyByteBuf = in.readBytes(length);</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] array;</div><div class=\"line\">        <span class=\"comment\">//反序列化数据的起始点</span></div><div class=\"line\">        <span class=\"keyword\">int</span> offset;</div><div class=\"line\">        <span class=\"comment\">//可读的数据字节长度</span></div><div class=\"line\">        <span class=\"keyword\">int</span> readableLen= bodyByteBuf.readableBytes();</div><div class=\"line\">        <span class=\"comment\">//分为包含数组数据和不包含数组数据两种形式</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (bodyByteBuf.hasArray()) &#123;</div><div class=\"line\">            array = bodyByteBuf.array();</div><div class=\"line\">            offset = bodyByteBuf.arrayOffset() + bodyByteBuf.readerIndex();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            array = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readableLen];</div><div class=\"line\">            bodyByteBuf.getBytes(bodyByteBuf.readerIndex(), array, <span class=\"number\">0</span>, readableLen);</div><div class=\"line\">            offset = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//反序列化</span></div><div class=\"line\">        MessageLite result = decodeBody(dataTypeId, array, offset, readableLen);</div><div class=\"line\">        out.add(result);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 根据协议号用响应的protobuf类型来解析协议数据</div><div class=\"line\">     * <span class=\"doctag\">@param</span> _typeId</div><div class=\"line\">     * <span class=\"doctag\">@param</span> array</div><div class=\"line\">     * <span class=\"doctag\">@param</span> offset</div><div class=\"line\">     * <span class=\"doctag\">@param</span> length</div><div class=\"line\">     * <span class=\"doctag\">@return</span></div><div class=\"line\">     * <span class=\"doctag\">@throws</span> Exception</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MessageLite <span class=\"title\">decodeBody</span><span class=\"params\">(<span class=\"keyword\">int</span> _typeId,<span class=\"keyword\">byte</span>[] array,<span class=\"keyword\">int</span> offset,<span class=\"keyword\">int</span> length)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(_typeId == EnmCmdID.CS_LOGIN_REQ_VALUE)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> CSLoginReq.getDefaultInstance().getParserForType().parseFrom(array,offset,length);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(_typeId == EnmCmdID.CS_LOGIN_RES_VALUE)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> CSLoginRes.getDefaultInstance().getParserForType().parseFrom(array,offset,length);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"修改Socket管道绑定的编解码器：\"><a href=\"#修改Socket管道绑定的编解码器：\" class=\"headerlink\" title=\"修改Socket管道绑定的编解码器：\"></a>修改Socket管道绑定的编解码器：</h4><p>在创建Socket管道的时候，将编解码器替换为自定义的编解码器，而具体数据发送和接受过程无需做任何修改：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\"><span class=\"comment\">// 协议数据的编解码器</span></div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"frameDecoder\"</span>,<span class=\"keyword\">new</span> ProtobufVarint32FrameDecoder());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"protobufDecoder\"</span>,<span class=\"keyword\">new</span> PackDecoder());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"frameEncoder\"</span>,<span class=\"keyword\">new</span> ProtobufVarint32LengthFieldPrepender());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"protobufEncoder\"</span>, <span class=\"keyword\">new</span> PackEncoder());</div><div class=\"line\">pipeline.addLast(<span class=\"string\">\"handler\"</span>,<span class=\"keyword\">new</span> SocketServerHandler());</div></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj4anjfhe00029gfjmw4o8rjp","category_id":"cj4anjfiu00079gfjo9zfitk1","_id":"cj4anjfjs000h9gfjg0zxwncl"},{"post_id":"cj4anjfi400059gfj0iwxh7o1","category_id":"cj4anjfiu00079gfjo9zfitk1","_id":"cj4anjfk3000n9gfjtkat67yw"},{"post_id":"cj4anjfiz00089gfj3msl2hql","category_id":"cj4anjfiu00079gfjo9zfitk1","_id":"cj4anjfkg000t9gfjylhiyi0j"},{"post_id":"cj4anjfjd000a9gfj4zejvdgt","category_id":"cj4anjfk7000p9gfj5wdoach0","_id":"cj4anjfkr00109gfjhi3sldp3"},{"post_id":"cj4anjfji000d9gfjd7nh6b2g","category_id":"cj4anjfkl000w9gfjrkqsx0bo","_id":"cj4anjfky00169gfjyna6q3kr"},{"post_id":"cj4anjfjn000f9gfj2usghmf4","category_id":"cj4anjfkr00129gfjo370dqsc","_id":"cj4anjfl8001c9gfjn4auseth"},{"post_id":"cj4anjfjt000i9gfjpcbe27eq","category_id":"cj4anjfky00189gfj1ztrcxcq","_id":"cj4anjfle001i9gfjnnhazp8f"},{"post_id":"cj4anjflb001g9gfjwszahvgd","category_id":"cj4anjfkl000w9gfjrkqsx0bo","_id":"cj4anjflj001o9gfj7up04rfs"},{"post_id":"cj4anjfjy000l9gfj06djy52o","category_id":"cj4anjfl9001f9gfjnaxksr8z","_id":"cj4anjfll001r9gfj5cqdkdo9"},{"post_id":"cj4anjfle001j9gfjvjbw4cvo","category_id":"cj4anjfkl000w9gfjrkqsx0bo","_id":"cj4anjfln001s9gfjhje3iv8k"},{"post_id":"cj4anjflh001m9gfj2nh2l358","category_id":"cj4anjfkl000w9gfjrkqsx0bo","_id":"cj4anjflr001w9gfjzkuorxzr"},{"post_id":"cj4anjfk4000o9gfjrtble11z","category_id":"cj4anjflg001l9gfjt5zsq0hi","_id":"cj4anjfls001x9gfjdn3wr7xs"},{"post_id":"cj4anjfkc000r9gfj7nk44ptb","category_id":"cj4anjfkr00129gfjo370dqsc","_id":"cj4anjflt001z9gfj28nk6k4h"},{"post_id":"cj4anjfkh000u9gfjlnhvalj3","category_id":"cj4anjflr001u9gfj81jfcyx7","_id":"cj4anjflu00239gfjitse46zo"},{"post_id":"cj4anjfkl000x9gfj3pd7gaiz","category_id":"cj4anjflr001u9gfj81jfcyx7","_id":"cj4anjflx00279gfj57wa1vr3"},{"post_id":"cj4anjfkp000z9gfjzybx1irx","category_id":"cj4anjflr001u9gfj81jfcyx7","_id":"cj4anjflz002a9gfj70vxve2d"},{"post_id":"cj4anjfkt00139gfj1x5a4vgw","category_id":"cj4anjflr001u9gfj81jfcyx7","_id":"cj4anjfm1002e9gfjx9cq0lgc"},{"post_id":"cj4anjfkw00159gfjf42ervea","category_id":"cj4anjflr001u9gfj81jfcyx7","_id":"cj4anjfmc002i9gfjwyhlk7v3"},{"post_id":"cj4anjfkz00199gfjiquqy0t8","category_id":"cj4anjflr001u9gfj81jfcyx7","_id":"cj4anjfmf002m9gfjd1996i00"},{"post_id":"cj4anjfl3001a9gfjfgkjagv1","category_id":"cj4anjflr001u9gfj81jfcyx7","_id":"cj4anjfmk002q9gfjjheke0el"},{"post_id":"cj4anjfl8001e9gfj6okkm0nq","category_id":"cj4anjflr001u9gfj81jfcyx7","_id":"cj4anjfmo002t9gfjmpeyuchv"}],"PostTag":[{"post_id":"cj4anjfgx00009gfjlsoem3i0","tag_id":"cj4anjfho00049gfj8xeenoan","_id":"cj4anjfji000c9gfj8ybi00d6"},{"post_id":"cj4anjfhe00029gfjmw4o8rjp","tag_id":"cj4anjfjf000b9gfj692rzfb6","_id":"cj4anjfjx000k9gfjqmxs3pen"},{"post_id":"cj4anjfi400059gfj0iwxh7o1","tag_id":"cj4anjfjf000b9gfj692rzfb6","_id":"cj4anjfk9000q9gfj8hxer0fz"},{"post_id":"cj4anjfiz00089gfj3msl2hql","tag_id":"cj4anjfjf000b9gfj692rzfb6","_id":"cj4anjfkk000v9gfjekir0yad"},{"post_id":"cj4anjfjd000a9gfj4zejvdgt","tag_id":"cj4anjfkf000s9gfjo5b0xnof","_id":"cj4anjfkr00119gfjmaxs29ux"},{"post_id":"cj4anjfji000d9gfjd7nh6b2g","tag_id":"cj4anjfko000y9gfjx6p20fq1","_id":"cj4anjfky00179gfjio7glr7u"},{"post_id":"cj4anjfjn000f9gfj2usghmf4","tag_id":"cj4anjfkv00149gfj2u3hdnn5","_id":"cj4anjfl8001d9gfjg7feaq60"},{"post_id":"cj4anjfjt000i9gfjpcbe27eq","tag_id":"cj4anjfl6001b9gfjtxv0erao","_id":"cj4anjflf001k9gfjc6feky2c"},{"post_id":"cj4anjfjy000l9gfj06djy52o","tag_id":"cj4anjfld001h9gfjtzgrsg5y","_id":"cj4anjflk001p9gfj1c46fk7y"},{"post_id":"cj4anjfk4000o9gfjrtble11z","tag_id":"cj4anjflj001n9gfjvkt6uv1a","_id":"cj4anjflr001v9gfjam5kn05u"},{"post_id":"cj4anjfkc000r9gfj7nk44ptb","tag_id":"cj4anjflo001t9gfj9eox78za","_id":"cj4anjflt00219gfjbco5c1ku"},{"post_id":"cj4anjfkh000u9gfjlnhvalj3","tag_id":"cj4anjfls001y9gfjz32pz41j","_id":"cj4anjflw00259gfjkj5hvt5t"},{"post_id":"cj4anjfkl000x9gfj3pd7gaiz","tag_id":"cj4anjfls001y9gfjz32pz41j","_id":"cj4anjfly00299gfj1u2vctzn"},{"post_id":"cj4anjfkp000z9gfjzybx1irx","tag_id":"cj4anjflx00269gfjmw7jh78r","_id":"cj4anjfm1002d9gfjfkv3js7c"},{"post_id":"cj4anjfkt00139gfj1x5a4vgw","tag_id":"cj4anjflz002b9gfji9l8tgf9","_id":"cj4anjfm6002h9gfjit32uirj"},{"post_id":"cj4anjfkw00159gfjf42ervea","tag_id":"cj4anjfm5002g9gfj1264vplz","_id":"cj4anjfme002l9gfjvnzykv72"},{"post_id":"cj4anjfkz00199gfjiquqy0t8","tag_id":"cj4anjfm5002g9gfj1264vplz","_id":"cj4anjfmh002p9gfjqibfa1cw"},{"post_id":"cj4anjfl3001a9gfjfgkjagv1","tag_id":"cj4anjfmg002o9gfj7cczs5kw","_id":"cj4anjfmo002s9gfjwlhivn4q"},{"post_id":"cj4anjfl8001e9gfj6okkm0nq","tag_id":"cj4anjfls001y9gfjz32pz41j","_id":"cj4anjfmq002v9gfjze56t1cm"},{"post_id":"cj4anjflb001g9gfjwszahvgd","tag_id":"cj4anjfmp002u9gfj2wd3srgp","_id":"cj4anjfms002x9gfjsit9lcd5"},{"post_id":"cj4anjfle001j9gfjvjbw4cvo","tag_id":"cj4anjfmp002u9gfj2wd3srgp","_id":"cj4anjfmv002z9gfjgyi8qojd"},{"post_id":"cj4anjflh001m9gfj2nh2l358","tag_id":"cj4anjfmp002u9gfj2wd3srgp","_id":"cj4anjfmw00309gfj3p7r475w"}],"Tag":[{"name":"批处理","_id":"cj4anjfho00049gfj8xeenoan"},{"name":"手绘","_id":"cj4anjfjf000b9gfj692rzfb6"},{"name":"Hexo","_id":"cj4anjfkf000s9gfjo5b0xnof"},{"name":"Java,Lua","_id":"cj4anjfko000y9gfjx6p20fq1"},{"name":"Unity","_id":"cj4anjfkv00149gfj2u3hdnn5"},{"name":"Hexo,Next","_id":"cj4anjfl6001b9gfjtxv0erao"},{"name":"Python","_id":"cj4anjfld001h9gfjtzgrsg5y"},{"name":"Redis","_id":"cj4anjflj001n9gfjvkt6uv1a"},{"name":"UE4","_id":"cj4anjflo001t9gfj9eox78za"},{"name":"Unity,ShaderLab","_id":"cj4anjfls001y9gfjz32pz41j"},{"name":"Unity,ShaderLab,Cg","_id":"cj4anjflx00269gfjmw7jh78r"},{"name":"Socket,C#","_id":"cj4anjflz002b9gfji9l8tgf9"},{"name":"protobuf,Unity","_id":"cj4anjfm5002g9gfj1264vplz"},{"name":"NJG,Unity","_id":"cj4anjfmg002o9gfj7cczs5kw"},{"name":"Java,Protobuf","_id":"cj4anjfmp002u9gfj2wd3srgp"}]}}